Body
"<pre><code>void loop(){
  if(Serial.available() &gt;= 3){
    // fill array
    for (int i = 0; i &lt; 3; i++){
      incoming[i] = Serial.read();
    }
    // use the values
    servo0.write(incoming[0]);
    servo1.write(incoming[1]);
    servo2.write(incoming[2]);
  }
}
</code></pre>
"
"<p>I am having some strange issue. I am using Linkit One board, which is a based on Arduino. </p>

<p>I am using rfid reader RC522 which is cheapest and most common. </p>

<p>I cant get its official library get it work. I tried to search for problem or differences but nothing help. I am looking for some to take a fresh look because its been 4 days and i am stuck.</p>

<p>Not Working <a href=""https://github.com/miguelbalboa/rfid"" rel=""nofollow"">https://github.com/miguelbalboa/rfid</a></p>

<p>Working (this is full ino in single file) <a href=""http://www.grantgibson.co.uk/blog/wp-content/uploads/2012/04/ggrfid_en_ino.txt"" rel=""nofollow"">http://www.grantgibson.co.uk/blog/wp-content/uploads/2012/04/ggrfid_en_ino.txt</a></p>
"
"<p>I am trying to call a HTTP GET using my Arduino via SIM900A.</p>

<p>When I run the commands manually via the USB port, I am able to get the commands to run. Now, when I put the same sequence on arduino, the <code>setup()</code> is called repeatedly after the <code>sendATcommand(httpAuthCommand, ""OK"", 2000);</code>. Looks like a reset issue.</p>

<p>I read, this link to put all my code into <code>loop</code> to avoid the <code>setup()</code> reset issue. But seems like this is did not fix the issue.</p>

<p>I have debugged it to this one change.</p>

<p><strong>This Works</strong></p>

<pre><code>char httpAuthCommand[] = ""AT+HTTPPARA=\""URL\"",\""http://www.m2msupport.net/m2msupport/http_get_test.php\"""" ;
</code></pre>

<p><strong>This Does Not work</strong></p>

<pre><code>char httpAuthCommand[] = ""AT+HTTPPARA=\""URL\"",\""http://1.1.1.1:8080/mytomcatservice/mypath/mycommand/Request?identity=%2B1234567890&amp;identityType=1\"""" ;
</code></pre>

<p>I debugged this a bit more, it does not work when I add <code>?identity=%2B0123456789&amp;identityType=1</code> to the httpAuthCommand. Something crazy while sending parameters ??</p>

<p><strong>In loop()</strong></p>

<pre><code>sendATcommand(httpAuthCommand, ""OK"", 2000); 
</code></pre>

<p><strong>sendATcommand method</strong></p>

<pre><code>int8_t sendATcommand(char* ATcommand, char* expected_answer, unsigned int timeout){

    uint8_t x=0,  answer=0;
    char response[100];
    unsigned long previous;
    memset(response, '\0', 100);    // Initialice the string
    delay(100);
    while( Serial.available() &gt; 0) Serial.read();    // Clean the input buffer
    Serial.println(ATcommand);    // Send the AT command 
    x = 0;
    previous = millis();
    // this loop waits for the answer
    do{
        // if there are data in the UART input buffer, reads it and checks for the asnwer
        if(Serial.available() != 0){    
            response[x] = Serial.read();
            x++;
            // check if the desired answer is in the response of the module
            if (strstr(response, expected_answer) != NULL)    
            {
                answer = 1;
            }
        }
    // Waits for the asnwer with time out
    }while((answer == 0) &amp;&amp; ((millis() - previous) &lt; timeout));    

    return answer;
}
</code></pre>

<p>Raw commands work on Chrome</p>

<blockquote>
  <p><a href=""http://www.m2msupport.net/m2msupport/http_get_test.php"" rel=""nofollow"">http://www.m2msupport.net/m2msupport/http_get_test.php</a> </p>
  
  <p><a href=""http://1.1.1.1:8080/mytomcatservice/mypath/mycommand/Request?identity=%2B918177900460&amp;identityType=1"" rel=""nofollow"">http://1.1.1.1:8080/mytomcatservice/mypath/mycommand/Request?identity=%2B918177900460&amp;identityType=1</a></p>
</blockquote>

<p><strong>My Guess</strong></p>

<p>I am missing some escape sequence characters in the command (especially in the parameters section <code>?identity=%2B0123456789&amp;identityType=1</code>).</p>
"
"<p>""Something crazy while sending parameters ??""</p>

<p>Possibly your power supply is to weak so 5V drops low and the processor resets when the transmitter sends a message.</p>
"
"<p>I executed the following steps in order to burn a bootloader into an  AVR328P-PU chip I acquired on ebay.</p>

<ol>
<li><p>I have set up AVR328P-PU on a breadboard as described here: <a href=""http://arduino.cc/en/main/standalone"" rel=""nofollow"">http://arduino.cc/en/main/standalone</a></p></li>
<li><p>I have uploaded the ArduinoISP sketch into Arduion Uno.</p></li>
<li><p>Connected the wires in a way described here <a href=""http://arduino.cc/en/Tutorial/ArduinoToBreadboard"" rel=""nofollow"">http://arduino.cc/en/Tutorial/ArduinoToBreadboard</a> ( the setup with external clock)</p></li>
<li><p>Chose ""Tools -> Programmer -> Arduion as ISP"" in the IDE.</p></li>
<li><p>Chose ""Burn Bootloader"" from the IDE.</p></li>
<li><p>Got and error <code>avrdude: Yikes!  Invalid device signature.</code>, noticed that I connected the wires in the wrong order.</p></li>
<li><p>Fixed the wired, but still got the error:</p></li>
</ol>

<p>avrdude: Version 6.0.1</p>

<pre><code>     System wide configuration file is ""C:\Program Files\Arduino/hardware/tools/avr/etc/avrdude.conf""

     Using Port                    : COM3
     Using Programmer              : stk500v1
     Overriding Baud Rate          : 19200
     AVR Part                      : ATmega328P
     Chip Erase delay              : 9000 us
     PAGEL                         : PD7
     BS2                           : PC2
     RESET disposition             : dedicated
     RETRY pulse                   : SCK
     serial program mode           : yes
     parallel program mode         : yes
     Timeout                       : 200
     StabDelay                     : 100
     CmdexeDelay                   : 25
     SyncLoops                     : 32
     ByteDelay                     : 0
     PollIndex                     : 3
     PollValue                     : 0x53
     Memory Detail                 :

                              Block Poll               Page                       Polled
       Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack
       ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------
       eeprom        65    20     4    0 no       1024    4      0  3600  3600 0xff 0xff
       flash         65     6   128    0 yes     32768  128    256  4500  4500 0xff 0xff
       lfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
       hfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
       efuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
       lock           0     0     0    0 no          1    0      0  4500  4500 0x00 0x00
       calibration    0     0     0    0 no          1    0      0     0     0 0x00 0x00
       signature      0     0     0    0 no          3    0      0     0     0 0x00 0x00

     Programmer Type : STK500
     Description     : Atmel STK500 Version 1.x firmware
     Hardware Version: 2
     Firmware Version: 1.18
     Topcard         : Unknown
     Vtarget         : 0.0 V
     Varef           : 0.0 V
     Oscillator      : Off
     SCK period      : 0.1 us

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.06s

avrdude: Device signature = 0x000000 (retrying)

Reading | ################################################## | 100% 0.05s

avrdude: Device signature = 0x000000 (retrying)

Error while burning bootloader.
Reading | ################################################## | 100% 0.07s

avrdude: Device signature = 0x000000
avrdude: Yikes!  Invalid device signature.
     Double check connections and try again, or use -F to override
     this check.


avrdude done.  Thank you.
</code></pre>

<p><img src=""http://i.stack.imgur.com/2hTrr.jpg"" alt=""Breadboard + Arduino""></p>

<p><img src=""http://i.stack.imgur.com/ReuMi.jpg"" alt=""Breadboard Close-Up""></p>

<h1>My questions</h1>

<ol>
<li><p>I understand that this can be caused by poor breadboard quality. How can I test this hypothesis before buying new breadboard?</p></li>
<li><p>Could the wrong wiring from step 5 ruin the chip?</p></li>
</ol>
"
"<p>Is it possible to use a custom bootloader, that loads and executes a main program which is stored for example on SD-card? The idea is to make it possible to update the Arduino remotely.</p>

<p>I tried this with a bootloader, that writes the program into the flash storage with a 32KiB offset and then uses a function pointer with that address (0x88000) to continue execution there. (The 0x80000 is as far as I am informed the address offset of the flash storage.) It can be written on Due boards with this library: <a href=""https://github.com/sebnil/DueFlashStorage"" rel=""nofollow"">https://github.com/sebnil/DueFlashStorage</a>. The problem was that this just hasn't worked, the Arduino simply stopped responding after the function pointer being executed. I would appreciate any information or hints on this topic.</p>
"
"<p><a href=""http://forum.arduino.cc/index.php?topic=38627.0"" rel=""nofollow"">This page</a> says to run a shell command I need a ""proxy code"" running on my computer (Linux Ubuntu). What do they mean by this, and how should I make one?</p>
"
"

<p>I have a project using the RC522 RFID module with my Arduino Uno board and miguelbalboa's rfid library. The example code and every other code I find on the internet work pooling the device in order to know if there is a new card present, but I intend to work with a interrupt-driven approach. I have the proper knowledge to do the hardware/arduino part, but I'm having trouble generating an interrupt in the IRQ pin when the card is present. Have anyone succeded on this?</p>

<p>Edit:
Connection:
RST -> 8</p>

<p>SS-> 9</p>

<p>MOSI -> 11</p>

<p>MISO -> 12</p>

<p>SCK -> 13</p>

<p>IRQ -> 2</p>

<p>Code:</p>

<pre class=""lang-C++ prettyprint-override""><code>#include &lt;SPI.h&gt;
#include &lt;MFRC522.h&gt;
#include &lt;String.h&gt;

#define RST_PIN     8 
#define SS_PIN      9

MFRC522 mfrc522(SS_PIN, RST_PIN);   // Create MFRC522 instance

void setup() 
{
  Serial.begin(9600);       // Initialize serial communications with the PC
  while (!Serial);      // Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
  SPI.begin();          // Init SPI bus
  mfrc522.PCD_Init();       // Init MFRC522
  mfrc522.PCD_WriteRegister(MFRC522::ComIrqReg, 0x80); //Clear interrupts
  mfrc522.PCD_WriteRegister(MFRC522::ComIEnReg, 0x7F); //Enable all interrupts
  mfrc522.PCD_WriteRegister(MFRC522::DivIEnReg, 0x14);
  Serial.println(F(""Ready...""));
  attachInterrupt(0, isr, RISING);
}

void loop() 
{
}

void isr()
{
  Serial.println(F(""Interrupt""));
  mfrc522.PCD_WriteRegister(MFRC522::ComIrqReg, 0x80); //Clear interrupts
}
</code></pre>

<p>Result:
I only get the ""Ready..."" on the Serial Monitor, no matter if there is a card present or not.</p>
"
"<p>First of all, I cannot say if your protocol will work or not since I don't have the details. However, switching protocols will give you the same result. Also, you do not need a transistor for this usage.</p>

<p>The solution is to connect the grounds of the different power sources. Since voltage is relative, having the grounds disconnected will lead one device to think that the voltage is higher/lower than the other one thinks (they have different reference point).</p>
"
"<p>I am trying to send and receive data using I2C between an Arduino Uno and an ATTiny85. The Arduino Uno is using the Wire library. The ATTiny85 is using the TinyWire library and is programmed (and powered) using the Sparkfun Tiny AVR Programmer.</p>

<p>I am not receiving any data.</p>

<p>Arduino Uno I2C master code</p>

<pre><code>#include &lt;Wire.h&gt;

#define SLAVE_ADDR 0x50

void setup()
{
  Wire.begin();
  Serial.begin(9600);
}

void loop()
{
  Wire.requestFrom(SLAVE_ADDR, 1);

  while(Wire.available())
  { 
    byte byteReceived = Wire.read();
    Serial.println(byteReceived, DEC);
  }
}
</code></pre>

<p>ATTiny85 I2C slave code</p>

<pre><code>#include ""TinyWireS.h""

#define SLAVE_ADDR 0x50

void setup()
{
  TinyWireS.begin(SLAVE_ADDR);
  TinyWireS.onRequest(requestEvent);
}


void loop()
{
}

void requestEvent()
{
  byte byteToSend = 23;
  TinyWireS.send(byteToSend);
}
</code></pre>
"
"<p>I'm not familiar with the term <em>proxy code,</em> but I'm assuming that it's a piece of code on your computer that acts as a man in the middle.</p>

<p>You cannot directly use Arduino to run a shell command, so you'll need to create a program on your computer that listens to <strong><a href=""http://arduino.cc/en/reference/serial"" rel=""nofollow"">serial</a></strong> and then executes a command.</p>

<p>For the ""proxy code"" Python would be a good choice because of the <strong><a href=""http://pyserial.sourceforge.net/"" rel=""nofollow"">pySerial library</a></strong> that plays nicely with Arduino. It seems <a href=""http://stackoverflow.com/questions/89228/calling-an-external-command-in-python"">fairly easy to execute a shell command with Python</a>.</p>

<p>As per the Arduino code, something like this would work good:</p>

<pre><code>setup() {
  Serial.begin(9600);
}

loop() {
  if(state == true) {
    Serial.print('A');
  }
}
</code></pre>
"
"<p>This is a visualization of my Arduino connections: </p>

<p><img src=""http://i.stack.imgur.com/FMI00.png"" alt=""enter image description here""></p>

<p>I wish to read the data using the <a href=""http://playground.arduino.cc/Main/CapacitiveSensor?from=Main.CapSense"" rel=""nofollow"">Capacitive sensor Library</a>. iv'e tried the following code but variables <code>total1</code>, <code>total2</code>, <code>total3</code> always have the value <code>0</code> and i don't know what is wrong.</p>

<p><strong>My code:</strong></p>

<pre><code>// Import the CapacitiveSensor Library.
#include &lt;CapacitiveSensor.h&gt;


// Name the pin as led. 
#define speaker 11


// Set the Send Pin &amp; Receive Pin.
CapacitiveSensor   cs_2_3 = CapacitiveSensor(2,3);        // 10M resistor between pins 4 &amp; 2, pin 2 is sensor pin, add a wire and or foil if desired
CapacitiveSensor   cs_2_4 = CapacitiveSensor(2,4);        // 10M resistor between pins 4 &amp; 6, pin 6 is sensor pin, add a wire and or foil
CapacitiveSensor   cs_2_5 = CapacitiveSensor(2,5);        // 10M resistor between pins 4 &amp; 8, pin 8 is sensor pin, add a wire and or foil
CapacitiveSensor   cs_2_6 = CapacitiveSensor(2,6);        // 10M resistor between pins 4 &amp; 8, pin 8 is sensor pin, add a wire and or foil
CapacitiveSensor   cs_2_7 = CapacitiveSensor(2,7);        // 10M resistor between pins 4 &amp; 8, pin 8 is sensor pin, add a wire and or foil
CapacitiveSensor   cs_2_8 = CapacitiveSensor(2,8);        // 10M resistor between pins 4 &amp; 8, pin 8 is sensor pin, add a wire and or foil
CapacitiveSensor   cs_2_9 = CapacitiveSensor(2,9);        // 10M resistor between pins 4 &amp; 8, pin 8 is sensor pin, add a wire and or foil


void setup()                    
{
  cs_2_3.set_CS_AutocaL_Millis(0xFFFFFFFF);     // turn off autocalibrate on channel 1 - just as an example

  // Arduino start communicate with computer.
  Serial.begin(9600);
}

void loop()                    
{
  // Set a timer.
  long start = millis();

  // Set the sensitivity of the sensors.
  long total1 =  cs_2_3.capacitiveSensor(60);
  long total2 =  cs_2_4.capacitiveSensor(60);
  long total3 =  cs_2_5.capacitiveSensor(60);
 /* long total4 =  cs_2_6.capacitiveSensor(60);
  long total5 =  cs_2_7.capacitiveSensor(60);
  long total6 =  cs_2_8.capacitiveSensor(60);
  long total7 =  cs_2_9.capacitiveSensor(60);*/



  Serial.print(millis() - start);        // check on performance in milliseconds
  Serial.print(""\t"");                    // tab character for debug windown spacing

  Serial.print(total1);                  // print sensor output 1
  Serial.print(""\t"");                    // Leave some space before print the next output
  Serial.print(total2);                  // print sensor output 2
  Serial.print(""\t"");                    // Leave some space before print the next output
  Serial.print(total3);                  // print sensor output 3
  Serial.print(""\t"");                    // Leave some space before print the next output
  Serial.print(""\n"");
}
</code></pre>
"
"<p>Could you have exceeded the rather limited RAM?
First experiment: Replace the added string with ""xxx....x"". If you have the same problem, then it's not the contents of the string but its length.
Second experiment (or jump straight to this one): <a href=""http://www.arduino.cc/en/Serial/Print"" rel=""nofollow"">Compile your strings in flash</a> instead of in RAM. Note this will only help if you have a number of them, since your code will have to copy each one to RAM (at run-time) in order to use it, taking up some of the space you had saved. If there is only one string moved to flash, your code will need a temporary buffer of equal size (though only during the actual print call). A possible way around this is to break up the long string into a number of short ones, put all of them in flash, then print them sequentially at run time. That will need a buffer only as large as your largest substring. The cost will be increased use of flash, both for string storage and for the extra number of print calls; and slightly slower execution (probably not an issue).</p>

<p>This may be telling you that you need a more capable processor (one with more RAM space) or that you need to start getting creative about fitting your application into the one you've got.</p>
"
"<p>OS: Ubuntu 14.04
Board: Teensy 3.1 and Arduino UNO</p>

<p>I've ran many tests and concluded that the issue is within the Arduino IDE itself.</p>

<p>The issue: Instead of a smooth stream of data displaying from the serial port, the terminal displays big chunks of data periodically. </p>

<p>I tested it with minicom and the stream of data is smooth.</p>

<p>Any solutions?</p>
"
"<p>I've got a BlueSMIRF Silver (RN-42) Bluetooth module.
I am trying to create a basic keyboard I can play with on an iPad Air.</p>

<p>At the moment barely manage to get the module to pair with OSX
but only through using Bluetooth Setup Assistant and using ""<strong>Passcode Options...use a specific code</strong>"". </p>

<p>With this option, the module pairs, but the connection resets about every 5 seconds. </p>

<p>On iPad it tries to use a generate number really fast and fails straight away, being unable to connect.</p>

<p>I noticed there is a BlueSMIRF HID version, but from what I can tell, the hardware is the same, 
just the firmware is different. I've gone through the whole <a href=""https://dlnmh9ip6v2uc.cloudfront.net/assets/1/e/e/5/d/5217b297757b7fd3748b4567.pdf"" rel=""nofollow"">Bluetooth Data Module Command Reference &amp; Advanced Information User’s Guide</a>(pdf link) manual and from what I can gather,
even though I have Silver firmware burned onto my module, I should be able to set and use the HID profile
(from the default SPP):</p>

<blockquote>
  <p>Roving Networks modules shipped with firmware version 6.11 and higher
  support the HID profile. You do not need special firmware if your
  module is running firmware 6.11 or higher.</p>
</blockquote>

<p>and my module reports version as:</p>

<pre><code>Ver 6.15 04/26/2013
(c) Roving Networks
</code></pre>

<p>I've also gone through the <a href=""http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Wireless/Bluetooth/RN-HID-User%20Guide-1.1r.pdf"" rel=""nofollow"">Bluetooth HID Profile</a>(pdf link) guide from Roving Networks, but the same information is present in Chapter 5 of the advanced user's guide mentioned above.</p>

<p>I've setup the following settings (with commands used):</p>

<ul>
<li>HID Profile (<code>S~,6</code>) </li>
<li>Device discovery and pairing is set to automatic, without using GPIO6(<code>SM,6</code>) </li>
<li>HID Flag is set to Keyboard (<code>SH,0000</code>) </li>
<li>Authentication is set to open (<code>SA,0</code>)</li>
</ul>

<p>I've also tried the inquiry scan(<code>SI,0800</code>)  and page scan(<code>SJ,0800</code>)  windows to maximum 
in the hope it would increase the odds of successful pairing and made sure I rebooted the module and checked the settings again.</p>

<p>I have used the same module with the SPP profile just fine, but I'm still fairly new to Bluetooth
and this is the first time I try to use the HID profile.</p>

<p><strong>How can I use the BlueSMIRF Silver as a basic Bluetooth Keyboard for an iPad Air ?</strong></p>
"
"<p>I am attempting to connect an Arduino Uno to a Modern Device RBB Arduino. One is the base and the other the remote. They need to set up a simple handshake to communicate an on and off condition from the remote.The hardware and software work for both the base and remote using Tera Term to simulate the opposite node. I am running Tera Term on a notebook connecting to the node through a BT dongle. In other words if I manually respond to the opposite node on the Tera Term they both operate as they should individually. When I try to get them to interact autonomously they will not handshake. The HC05s are paired and connected but the handshake data will not flow back and forth.</p>

<p>Remote Code:</p>

<pre><code> int pinInt =2; //interrupt pin

 int ack = 2; //acknowledge

 void setup() {

  pinMode(3,OUTPUT); //power to bluetooth

  pinMode(pinInt,INPUT); //interrupt pin mode

}
// Still needs sleep and interrupt processing

  void loop() {

  delay(5000);//sim sleep remove or adjust for wake up delay


  digitalWrite(3,HIGH);//switches power to bluetooth

  delay(10000);//BT active adjust as necessary

  Serial.begin(9600); 

  Serial.print('?');//send am I connected

   while(Serial.available()==0){}//idle until incoming serial

     int heatCall=digitalRead(pinInt);//read interrupt pin

     if (Serial.available() &gt; 0) {ack = Serial.read();}//read ack

     if (ack=='1'){Serial.print(heatCall);}//send state of heatCall

  while(Serial.available()==0){}//idle until incoming serial

    if (Serial.available() &gt; 0) {ack = Serial.read();}//read ack

    if (ack=='0'){Serial.end();digitalWrite(3,LOW);}//BT off 

   //sleepNow();//put back to sleep


}
</code></pre>

<p>Base Code:</p>

<pre><code>int relayPin =13; //relay pin

 char itsOn = 0; //remote calling variable

 int heatCall = 0; //state of TH135

 int ack = 2; //hand shake

  void setup() {

  pinMode(relayPin,OUTPUT); //power to relay
  Serial.begin(9600);
}

  void loop() {

  while (Serial.available()==0);{}//idle until incoming serial

  if (Serial.available() &gt; 0) {itsOn = Serial.read();//remote calling

    if (itsOn=='?')ack=1;Serial.print(ack);}//send connected ack

  while (Serial.available()==0);{}//idle until incoming serial

  if (Serial.available() &gt; 0) {heatCall = Serial.read();}//incoming heatCall

    if (heatCall=='1'){digitalWrite(relayPin,HIGH);}//turn zone relay ON

     else {digitalWrite(relayPin,LOW);}//turn zone relay OFF

  delay(5000);
  ack=0;
  Serial.print(ack);//turn remote BT OFF
  }
</code></pre>

<p>Is there some BT protocol that I am missing? </p>

<p>UPDATE: I have determined that data is being transferred from remote to base and back. The data is not the expected values.</p>
"
"<p>i am trying to send data via Labview to my arduino board using serial communication.My problem is that the arduino reads only the first byte of sent data then when i change it ,it doesn't react.<br>
For example when i start the communication i send '0' to arduino.I sees it.but while it is running i send '1' but it doesn't behave accordingly to it.<br>
I noticed also that the board 'sees' sometime the new value after a random period of time.</p>

<pre><code>    void setup() { 
      Serial.begin(9600); 
      pinMode(13,OUTPUT); 
     } 

  char data='F';
  void loop() 
    { 



 data=Serial.read();



 delay(50);
 if (data=='0')
  {
    digitalWrite(13,HIGH);
    delay(1000);
   digitalWrite(13,LOW);
 delay(1000);
 } 

if (data=='1')
 {
  digitalWrite(13,HIGH);
  delay(4000);
  digitalWrite(13,LOW);
  delay(4000);
 } 
 data='4';

           } 
</code></pre>
"
"<p>I am currently playing with a MindWave Mobile headset. I am parsing bluetooth data received from a connected BlueSMIRF Silver.
The code I started from is a <a href=""http://developer.neurosky.com/docs/doku.php?id=mindwave_mobile_and_arduino"" rel=""nofollow"">sample from the MindWave wiki</a> and it works using hardware Serial.
For reference here is the original code:</p>

<pre><code>////////////////////////////////////////////////////////////////////////
// Arduino Bluetooth Interface with Mindwave
// 
// This is example code provided by NeuroSky, Inc. and is provided
// license free.
////////////////////////////////////////////////////////////////////////

#define LED 13
#define BAUDRATE 57600
#define DEBUGOUTPUT 1

#define GREENLED1  3
#define GREENLED2  4
#define GREENLED3  5
#define YELLOWLED1 6
#define YELLOWLED2 7
#define YELLOWLED3 8
#define YELLOWLED4 9
#define REDLED1    10
#define REDLED2    11
#define REDLED3    12

#define powercontrol 10

// checksum variables
byte generatedChecksum = 0;
byte checksum = 0; 
int payloadLength = 0;
byte payloadData[64] = {
  0};
byte poorQuality = 0;
byte attention = 0;
byte meditation = 0;

// system variables
long lastReceivedPacket = 0;
boolean bigPacket = false;

//////////////////////////
// Microprocessor Setup //
//////////////////////////
void setup() {

  pinMode(GREENLED1, OUTPUT);
  pinMode(GREENLED2, OUTPUT);
  pinMode(GREENLED3, OUTPUT);
  pinMode(YELLOWLED1, OUTPUT);
  pinMode(YELLOWLED2, OUTPUT);
  pinMode(YELLOWLED3, OUTPUT);
  pinMode(YELLOWLED4, OUTPUT);
  pinMode(REDLED1, OUTPUT);
  pinMode(REDLED2, OUTPUT);
  pinMode(REDLED3, OUTPUT);

  pinMode(LED, OUTPUT);
  Serial.begin(BAUDRATE);           // USB

}

////////////////////////////////
// Read data from Serial UART //
////////////////////////////////
byte ReadOneByte() {
  int ByteRead;

  while(!Serial.available());
  ByteRead = Serial.read();

#if DEBUGOUTPUT  
  Serial.print((char)ByteRead);   // echo the same byte out the USB serial (for debug purposes)
#endif

  return ByteRead;
}

/////////////
//MAIN LOOP//
/////////////
void loop() {


  // Look for sync bytes
  if(ReadOneByte() == 170) {
    if(ReadOneByte() == 170) {

      payloadLength = ReadOneByte();
      if(payloadLength &gt; 169)                      //Payload length can not be greater than 169
          return;

      generatedChecksum = 0;        
      for(int i = 0; i &lt; payloadLength; i++) {  
        payloadData[i] = ReadOneByte();            //Read payload into memory
        generatedChecksum += payloadData[i];
      }   

      checksum = ReadOneByte();                      //Read checksum byte from stream      
      generatedChecksum = 255 - generatedChecksum;   //Take one's compliment of generated checksum

        if(checksum == generatedChecksum) {    

        poorQuality = 200;
        attention = 0;
        meditation = 0;

        for(int i = 0; i &lt; payloadLength; i++) {    // Parse the payload
          switch (payloadData[i]) {
          case 2:
            i++;            
            poorQuality = payloadData[i];
            bigPacket = true;            
            break;
          case 4:
            i++;
            attention = payloadData[i];                        
            break;
          case 5:
            i++;
            meditation = payloadData[i];
            break;
          case 0x80:
            i = i + 3;
            break;
          case 0x83:
            i = i + 25;      
            break;
          default:
            break;
          } // switch
        } // for loop

#if !DEBUGOUTPUT

        // *** Add your code here ***

        if(bigPacket) {
          if(poorQuality == 0)
            digitalWrite(LED, HIGH);
          else
            digitalWrite(LED, LOW);
          Serial.print(""PoorQuality: "");
          Serial.print(poorQuality, DEC);
          Serial.print("" Attention: "");
          Serial.print(attention, DEC);
          Serial.print("" Time since last packet: "");
          Serial.print(millis() - lastReceivedPacket, DEC);
          lastReceivedPacket = millis();
          Serial.print(""\n"");                     
        }
#endif        
        bigPacket = false;        
      }
      else {
        // Checksum Error
      }  // end if else for checksum
    } // end if read 0xAA byte
  } // end if read 0xAA byte
}
</code></pre>

<p>One problem I have is the blocking while loop in the ReadOneByte function:</p>

<pre><code>byte ReadOneByte() {
  int ByteRead;

  while(!Serial.available());
  ByteRead = Serial.read();

#if DEBUGOUTPUT  
  Serial.print((char)ByteRead);   // echo the same byte out the USB serial (for debug purposes)
#endif

  return ByteRead;
}
</code></pre>

<p>I am trying to avoid this so I started drafting a basic state machine approach:</p>

<pre><code>#define BAUDRATE 57600

// checksum variables
byte generatedChecksum = 0;
byte checksum = 0; 
int payloadLength = 0;
byte payloadData[169] = {0};
byte poorQuality = 0;
byte attention = 0;
byte meditation = 0;

// system variables
long lastReceivedPacket = 0;
boolean bigPacket = false;

int payloadIndex;

int state = 0;
const int STATE_WAIT_FOR_FIRST_A        = 0;
const int STATE_WAIT_FOR_SECOND_A       = 1;
const int STATE_WAIT_FOR_PAYLOAD_LENGTH = 2;
const int STATE_WAIT_FOR_PAYLOAD        = 3;
const int STATE_WAIT_FOR_CHECKSUM       = 4;
const String stateNames[5] = {""waiting for first A"",""waiting for second A"",""waiting for payload length"",""accumulating payload"",""waiting for checksum""};

void setup() {
  Serial.begin(BAUDRATE);           // USB
}
void loop() {}
void parsePayload(){
  poorQuality = 200;
  attention = 0;
  meditation = 0;

  for(int i = 0; i &lt; payloadLength; i++) {    // Parse the payload
    switch (payloadData[i]) {
    case 2:
      i++;            
      poorQuality = payloadData[i];
      bigPacket = true;            
      break;
    case 4:
      i++;
      attention = payloadData[i];                        
      break;
    case 5:
      i++;
      meditation = payloadData[i];
      break;
    case 0x80:
      i = i + 3;
      break;
    case 0x83:
      i = i + 25;      
      break;
    default:
      break;
    } // switch
  } // for loop
  Serial.print(""bigPacket:"");
  Serial.println(bigPacket);
  if(bigPacket) {
    Serial.print(""PoorQuality: "");
    Serial.print(poorQuality, DEC);
    Serial.print("" Attention: "");
    Serial.print(attention, DEC);
    Serial.print("" Time since last packet: "");
    Serial.print(millis() - lastReceivedPacket, DEC);
    lastReceivedPacket = millis();
    Serial.print(""\n"");                     
  }
  bigPacket = false;   
}

void printState(){
  Serial.print(""state:"");
  Serial.println(stateNames[state]);
}
void serialEvent(){
  if(Serial.available() &gt; 0){
    switch(state){
      case STATE_WAIT_FOR_FIRST_A:
        printState();
        if(Serial.read() == 170) state = STATE_WAIT_FOR_SECOND_A;
      break;
      case STATE_WAIT_FOR_SECOND_A:
        printState();
        if(Serial.read() == 170) state = STATE_WAIT_FOR_PAYLOAD_LENGTH;
      break;
      case STATE_WAIT_FOR_PAYLOAD_LENGTH:
        printState();
        payloadLength = Serial.read();
        Serial.print(""payloadLength:"");Serial.println(payloadLength);
        if(payloadLength &gt; 169){
          Serial.println(payloadLength &gt; 169);
          state = STATE_WAIT_FOR_FIRST_A;
          return;
        }
        generatedChecksum = payloadIndex = 0;
        state = STATE_WAIT_FOR_PAYLOAD;
      break;
      case STATE_WAIT_FOR_PAYLOAD:
        printState();
        if(payloadIndex &lt; payloadLength){
          payloadData[payloadIndex] = Serial.read();
          generatedChecksum += payloadData[payloadIndex];
          Serial.print(""payloadData["");Serial.print(payloadIndex);Serial.print("" of "");Serial.print(payloadLength);Serial.print(""]: "");
          Serial.println(payloadData[payloadIndex]);
        }else{
          state = STATE_WAIT_FOR_CHECKSUM;
        }
      break;
      case STATE_WAIT_FOR_CHECKSUM:
        printState();
        checksum = Serial.read();
        generatedChecksum = 255 - generatedChecksum;
        if(checksum == generatedChecksum) {
          Serial.println(""checksum MATCH! parsing payload"");
          parsePayload();
          state = STATE_WAIT_FOR_FIRST_A;
        }else{
          Serial.println(""checksum FAIL!"");
          state = STATE_WAIT_FOR_FIRST_A;
        }
      break;
    }
  }
}
</code></pre>

<p>As far as I can understand from the <a href=""http://arduino.cc/en/Reference/SerialEvent"" rel=""nofollow"">serialEvent() reference</a> this function would be called only when a new byte is available. I've also added a condition to check if <code>Serial.available() &gt; 0</code>.</p>

<p>I can see the messages I expect when parsing the data, but only small packets(usually 4 bytes long) end up having a correct checksum and never receive a payload with the useful EEG data I'm looking for. </p>

<p>How can I check that my approach is correct or not/ I'm not loosing bytes using <code>serialEvent()</code> instead of the blocking <code>while(!Serial.available())</code> ? 
If so, how can I rewrite the while loop in a non blocking way ?</p>

<p>I've not super experienced with Arduino, but I started reading on interrupts. Would a <code>USART_RX</code> interrupt help at all ? (or would it do the same as serialEvent -> trigger when a new byte is available?)</p>

<p><strong>Update!</strong>
Using Wirewrap's suggestion to use read() which returns -1 if there is no data, I've used <a href=""http://file://localhost/Applications/Arduino.app/Contents/Resources/Java/reference/Serial_Peek.html"" rel=""nofollow"">peek()</a> which does almost the same, except it doesn't remove the character peeked at from the buffer.
For reference here is the code used:</p>

<pre><code>#define BAUDRATE 57600
#define DEBUGOUTPUT 1


// checksum variables
byte generatedChecksum = 0;
byte checksum = 0; 
int payloadLength = 0;
int payloadIndex;
byte payloadData[169] = {0};
byte poorQuality = 0;
byte attention = 0;
byte meditation = 0;

// system variables
long lastReceivedPacket = 0;
boolean bigPacket = false;

int state = 0;
const int STATE_WAIT_FOR_FIRST_A        = 0;
const int STATE_WAIT_FOR_SECOND_A       = 1;
const int STATE_WAIT_FOR_PAYLOAD_LENGTH = 2;
const int STATE_WAIT_FOR_PAYLOAD        = 3;
const int STATE_WAIT_FOR_CHECKSUM       = 4;

void setup() {
  Serial.begin(BAUDRATE);           // USB  
}
void loop() {}
void parsePayload(){
  poorQuality = 200;
  attention = 0;
  meditation = 0;

  for(int i = 0; i &lt; payloadLength; i++) {    // Parse the payload
    switch (payloadData[i]) {
    case 2:
      i++;            
      poorQuality = payloadData[i];
      bigPacket = true;            
      break;
    case 4:
      i++;
      attention = payloadData[i];                        
      break;
    case 5:
      i++;
      meditation = payloadData[i];
      break;
    case 0x80:
      i = i + 3;
      break;
    case 0x83:
      i = i + 25;      
      break;
    default:
      break;
    } // switch
  } // for loop
  if(bigPacket) {
    Serial.print(""PoorQuality: "");
    Serial.print(poorQuality, DEC);
    Serial.print("" Attention: "");
    Serial.print(attention, DEC);
    Serial.print("" Time since last packet: "");
    Serial.print(millis() - lastReceivedPacket, DEC);
    lastReceivedPacket = millis();
    Serial.print(""\n"");                     
  }
  bigPacket = false;   
}

void serialEvent(){
  if(Serial.peek() &gt;= 0){
    switch(state){
      case STATE_WAIT_FOR_FIRST_A:
        if(Serial.read() == 170) state = STATE_WAIT_FOR_SECOND_A;
      break;
      case STATE_WAIT_FOR_SECOND_A:
        if(Serial.read() == 170) state = STATE_WAIT_FOR_PAYLOAD_LENGTH;
      break;
      case STATE_WAIT_FOR_PAYLOAD_LENGTH:
        payloadLength = Serial.read();
        if(payloadLength &gt; 169){
          state = STATE_WAIT_FOR_FIRST_A;
          return;
        }
        generatedChecksum = payloadIndex = 0;
        state = STATE_WAIT_FOR_PAYLOAD;
      break;
      case STATE_WAIT_FOR_PAYLOAD:
        if(payloadIndex &lt; payloadLength){
          payloadData[payloadIndex] = Serial.read();
          generatedChecksum += payloadData[payloadIndex];
          payloadIndex++;
        }else{
          state = STATE_WAIT_FOR_CHECKSUM;
        }
      break;
      case STATE_WAIT_FOR_CHECKSUM:
        checksum = Serial.read();
        generatedChecksum = 255 - generatedChecksum;
        if(checksum == generatedChecksum) {
          parsePayload();
          state = STATE_WAIT_FOR_FIRST_A;
        }else{
          state = STATE_WAIT_FOR_FIRST_A;
        }
      break;
    }
  }
}
</code></pre>
"
"<p>Being from eBay, I would assume the seller ""bricked"" the chip beyond his/her capability to fix.  Fortunately, you know about stack exchange!</p>

<p>My immediate suggestion is to find, borrow or build a high-voltage programmer.  This is a special programmer that can un-brick the chip no matter what's been done to it. The concept is easy, but you need to protect the programmer's pins from the 12v reset signal.</p>

<p>Googling ""avr high voltage programmer"" gives several useful links.
I'll get the actual links when I get back to a real computer.</p>

<p>Ok, so life got in the way, sorry about that.
This is the one I built which worked perfectly:
<a href=""http://mightyohm.com/blog/products/hv-rescue-shield-2-x/design-files/"" rel=""nofollow"">MightyOhm</a></p>

<p>However hooking up the AVR to a ""high voltage programmer"" is well documented in the data sheets.  These should be very much similar <a href=""https://www.google.com/search?q=Schematic%20of%20a%20%22High%20Voltage%20Parallel-Programmer&amp;ie=utf-8&amp;oe=utf-8"" rel=""nofollow"">circuits on Google</a>.</p>
"
"<p>the network parts are ""owned""by the yun side of the board.
the yun acts like a mini linux pc, who can seperatly connect trough a bridge library to the arduino. so.. i think you could do it or make it a router that would probaply be easier, but this all wouldnt depend on arduino code, more depend on if there are WRT packages who can do this.. i thinks they should exist as this linux variant is in other routers too.</p>

<p>(better route then repeat btw, repeats puts delays on your entire lan)</p>
"
"<p>Arduino Day is so popular! Many boards are cheap during arduino day. So should I buy a <a href=""https://day.arduino.cc/#/"" rel=""nofollow"">genuine arduino board</a> or <a href=""http://eepurl.com/biaWzT"" rel=""nofollow"">a sainsmart board?</a></p>
"
"<p>In the current project I'm programming simultaneously an UNO board and a Leonardo one. </p>

<p>Switching back and forth between the two boards in the <strong>Tools</strong> menu takes too much time because of the other 18 boards that I do not own anyway.</p>

<p>Is there a way to remove those boards from the Tools menu?</p>
"
"<p>After some more investigation of the IDE folder, I found a text file called <strong>boards.txt</strong> in the following path.</p>

<pre><code> [Arduino Path]/hardware/arduino/boards.txt
</code></pre>

<p>EDIT: Be sure to make a copy of the file in case you mess up the following part.</p>

<p>Between two series of '<strong>#</strong>' characters there will be all the information on a specific microcontroller (e.g <em>uno.name=Arduino Uno</em>). Deleting every line of text between the two '<strong>#</strong>' series will have the desired effect of removing the board from the <strong>Tools</strong> menu.</p>
"
"<p>My arduino has these two capacitors</p>

<p><img src=""http://i.stack.imgur.com/0wRA6.jpg"" alt=""enter image description here""></p>

<p>But I can't find any 47uf capacitors on the schematic. Is this not the value but instead a code? Where are these in the schematic?</p>

<p><img src=""http://i.stack.imgur.com/psqR4.png"" alt=""enter image description here""></p>
"
"<p>Buying an official board can be a good choice for a couple of main reasons. First of all, you're guaranteed a good quality board which conforms to the official schematic, and is definitely compatible with any relevant official software and hardware. If the board turns out to be faulty when you get it, you'll be able to get it replaced. Additionally, buying official boards means some of the money you spend goes towards funding future Arduino projects.</p>

<p>As you've no doubt seen, cloned (i.e. unofficial) boards based on Arduino are often much cheaper. Nonetheless, many of the boards are very good. Functionally, you might not see any difference whatsoever from the official/genuine boards. Some of them actually have some additional features which you might find useful depending on your project, such as switching the IO pins between 3.3v and 5v.</p>

<p>However, not all cloned boards are worth using. Some of them may have lower quality components. It's even possible that they weren't designed/constructed correctly in the first place. This could lead to a range of problems, from incompatibilities through to outright failure of the hardware. Given the geographic location of some of the manufacturers/sellers, you may not have any way to get a refund if something goes wrong.</p>

<p>If you choose to use a clone, look for a brand which other people have had success with. Also do your best to ensure the board uses the correct microcontroller (e.g. the Atmega328 for boards based on the Uno).</p>

<p>Ultimately, the decision is up to you. There's no 'right' answer necessarily.</p>
"
"<p>I am working with Arduino UNO + AdaFruit CC3000 Wi-Fi shield. I ran it with a lot of websites and webpages, but for now I am going to get sub-domain from <a href=""https://en.wikipedia.org/wiki/Heroku"" rel=""nofollow"">Heroku</a>, and it has no IP address. The sub-domain is <code>myapp.herokuapp.com</code>. </p>

<p>So, how can I send a GET request to such an application like that?</p>

<p>Here's the code :</p>

<pre><code> // Library headers section
 #include &lt;Adafruit_CC3000.h&gt;
 #include &lt;ccspi.h&gt;
 #include &lt;SPI.h&gt;
 #include &lt;string.h&gt;
 #include ""utility/debug.h""

 // Constants area
 #define ADAFRUIT_CC3000_IRQ  3 // must be an interrupt pin (2 or 3)
 #define ADAFRUIT_CC3000_VBAT  5 // any pin
 #define ADAFRUIT_CC3000_CS  10 // any pin

 //use hardware SPI for remaining pins
 // Uno: SCK=13, MISO=12, MOSI=11
 Adafruit_CC3000 cc3000 = Adafruit_CC3000(ADAFRUIT_CC3000_CS,      ADAFRUIT_CC3000_IRQ,
                                          ADAFRUIT_CC3000_VBAT,      SPI_CLOCK_DIVIDER);
 #define WLAN_SSID  ""Ibtikar.AP2""
 #define WLAN_PASS  ""#ibtik@r#""
 // set security type
 // WLAN_SEC_UNSEC, WLAN_SEC_WEP, WLAN_SEC_WPA, WLAN_SEC_WPA2
 #define WLAN_SECURITY  WLAN_SEC_WPA2
 #define IDLE_TIMEOUT_MS  3000 // amount of time to wait with no date      recieved
                               // before rejecting/closing the collection
 #define WEBSITE  ""myapp.herokuapp.com""
 uint32_t ip;
 void setup() {
   // put your setup code here, to run once:
    Serial.begin(115200);
    Serial.print(""Free RAM: ""); Serial.println(getFreeRam(), DEC);
/* Initialise the module */
    Serial.println(F(""\nInitializing...""));
    delay(100);
    if (!cc3000.begin())
    {
      Serial.println(F(""Couldn't begin()! Check your wiring?""));
      while(1);
    }
    Serial.print(F(""\nAttempting to connect to ""));           Serial.println(WLAN_SSID);
     if (!cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY)) {
       Serial.println(F(""Failed!""));
       while(1);
     } 
    Serial.println(F(""Connected!""));
    /* Wait for DHCP to complete */
    Serial.println(F(""Request DHCP""));
    while (!cc3000.checkDHCP())
    {
       delay(100); // ToDo: Insert a DHCP timeout!
    }  

   /* Display the IP address DNS, Gateway, etc. */  
   while (! displayConnectionDetails()) {
     delay(1000);
   }

    ip = 0;
   // Try looking up the website's IP address
   Serial.print(WEBSITE); Serial.print(F("" -&gt; ""));
   while (ip == 0) {
     if (! cc3000.getHostByName(WEBSITE, &amp;ip)) {
       Serial.println(F(""Couldn't resolve!""));
     }
     delay(500);
   }
   cc3000.printIPdotsRev(ip);

   // Optional: Do a ping test on the website
   Serial.print(F(""\n\rPinging "")); cc3000.printIPdotsRev(ip);      Serial.print(""..."");  
   int replies = cc3000.ping(ip, 5);
   Serial.print(replies); Serial.println(F("" replies""));
 }

 void loop() {
    /* Try connecting to the website.
      Note: HTTP/1.1 protocol is used to keep the server from closing the           connection before all data is read.
   */
    Adafruit_CC3000_Client www = cc3000.connectTCP(ip, 80);
   if (www.connected()) {
     www.fastrprint(F(""GET ""));
     www.fastrprint(F("" HTTP/1.1\r\n""));
     www.fastrprint(F(""Host: myapp.herokuapp.com"")); 
     //www.fastrprint(WEBSITE); 
     www.fastrprint(F(""\r\n""));
     www.println();
   } else {
     Serial.println(F(""Connection failed""));    
     return;
   }
   Serial.println(F(""-------------------------------------""));
   unsigned long lastRead = millis();
   while (www.connected() &amp;&amp; (millis() - lastRead &lt; IDLE_TIMEOUT_MS)) {
     while (www.available()) {
       char c = www.read();
       Serial.print(c);
       lastRead = millis();
     }
   }
   www.close();
   Serial.println(F(""-------------------------------------""));

   /* You need to make sure to clean up after yourself or the CC3000 can           freak out */
   /* the next time your try to connect ... */
        Serial.println(F(""\n\nDisconnecting""));
   cc3000.disconnect();
   delay(1000);
 }


 /**************************************************************************/
 /*!
     @brief  Begins an SSID scan and prints out all the visible networks
 */
 /**************************************************************************/

 void listSSIDResults(void)
 {     
   uint32_t index;
   uint8_t valid, rssi, sec;
   char ssidname[33]; 

   if (!cc3000.startSSIDscan(&amp;index)) {
          Serial.println(F(""SSID scan failed!""));
          return;
   }

   Serial.print(F(""Networks found: "")); Serial.println(index);
   Serial.println(F(""================================================""));

   while (index) {
     index--;

     valid = cc3000.getNextSSID(&amp;rssi, &amp;sec, ssidname);

     Serial.print(F(""SSID Name    : "")); Serial.print(ssidname);
     Serial.println();
     Serial.print(F(""RSSI         : ""));
     Serial.println(rssi);
     Serial.print(F(""Security Mode: ""));
     Serial.println(sec);
     Serial.println();
   }
   Serial.println(F(""================================================""));

   cc3000.stopSSIDscan();
 }

      /**************************************************************************/
 /*!
     @brief  Tries to read the IP address and other connection details
 */
 /**************************************************************************/
 bool displayConnectionDetails(void)
 {
   uint32_t ipAddress, netmask, gateway, dhcpserv, dnsserv;

   if(!cc3000.getIPAddress(&amp;ipAddress, &amp;netmask, &amp;gateway, &amp;dhcpserv,      &amp;dnsserv))
   {
     Serial.println(F(""Unable to retrieve the IP Address!\r\n""));
     return false;
   }
   else
   {
     Serial.print(F(""\nIP Addr: "")); cc3000.printIPdotsRev(ipAddress);
     Serial.print(F(""\nNetmask: "")); cc3000.printIPdotsRev(netmask);
     Serial.print(F(""\nGateway: "")); cc3000.printIPdotsRev(gateway);
     Serial.print(F(""\nDHCPsrv: "")); cc3000.printIPdotsRev(dhcpserv);
     Serial.print(F(""\nDNSserv: "")); cc3000.printIPdotsRev(dnsserv);
     Serial.println();
     return true;
   }
 }
</code></pre>
"
"<p>I really need all the help I can get...
It's been a week now and I'm still not able to solve the problem.</p>

<p>I have text file on a server. The whole address is www.example.com/test.txt
I want to read the file using a GET request every 3-5 secs and parse it for further actions. But the arduino codes that I've tried till now use software serial and it keeps misbehaving. Sometimes it skips a few serial-print commands and loops back sometimes it reads the file 3-4 times and then hangs. Basically I'm getting the response only a few times but then it stops working properly. </p>

<p>I want to solve this...I need a working arduino code to work with ESP8266 so that I can successfully poll a text file from server without any problems.</p>

<p>Here is my current code - </p>

<pre><code> #include&lt;SoftwareSerial.h&gt;

    #define led 13
    SoftwareSerial esp(11, 12);
    String domain = ""www.example.com"";
    String request = ""GET /test.txt HTTP/1.0\r\n\r\n"";


    void SerialDo(String command, float time, bool debug) {
      delay(100);
      esp.print(command);

      int i = millis();
      while (millis() - i &lt; (time * 1000)) {
        while ( (esp.available())) {
          if (debug) {
            Serial.print((char)esp.read());
          }
        }
      }

      Serial.flush();
    }

    void setup() {
      // put your setup code here, to run once:
      digitalWrite(led, OUTPUT);
      Serial.begin(9600);
      esp.begin(9600);
      esp.setTimeout(3000);
      digitalWrite(led, LOW);
      Serial.println(""Hello"");
      //delay(2000);
      SerialDo(""AT+RST\r\n"", 5, true);
      Serial.flush();
      SerialDo(""AT+CWMODE=1\r\n"", 0.5, true);

      delay(1000);
      //SerialDo(""AT+CWLAP\r\n"", 5, true);
      SerialDo(""AT+CWJAP=\""Sherlock\"",\""Watson@11\""\r\n"", 10, true);
      SerialDo(""AT+CIPMUX=0\r\n"", 0.5, true);

    }

    void loop() {


      delay(1000);
      Serial.print(""loop\r\n"");

      SerialDo(""AT+CIPMUX=0\r\n"", 0.5, true);
      SerialDo(""AT+CIPSTART=\""TCP\"",\"""" + domain + ""\"",80\r\n"", 1.5, true);
      esp.flush();

      esp.print(""AT+CIPSEND="" + String(request.length()) + ""\r\n"");
      delay(100);
      esp.print(request);

      String t = """";
      int i = millis();
      while (millis() - i &lt; 1500) {
        while ((esp.available() &gt; 0)) {
          if (true) {
            char c = (char)esp.read();
            t += c;
            Serial.print(c);
          }
        }
      }

      esp.print(""AT+CIPCLOSE\r\n"");

      if (t.indexOf(""hello world"") &gt; -1) {
        digitalWrite(led, !digitalRead(led));
      }
  }
</code></pre>
"
"<p>I am trying to design a bicycle LED lighting system, and for that I bought an Arduino yesterday (so very beginner with Arduino).</p>

<p>My final system will operate at 6V, so I plan to put everything on a breadbord and tune everything (blinking times, resistor values, etc.) and for that I want to keep my Arduino plugged to USB during development.</p>

<p>So my question is:</p>

<p>How should I connect USB-powered Arduino to a higher-voltage-powered breadbord (between 6 and 12V) safely?</p>
"
"<p><strong>What:</strong> Looking at the schematic that you provided, it seems likely that they serve as C6 &amp; C7. </p>

<p><strong>Why:</strong> These are shown as 100 uF each and act as ""filter"" capacitors for IC4, the 5V regulator.<br>
Within certain limits, such capacitors are not critical in value, and the manufacturer has probably decided that a factor of in the capacitance is probably acceptable.<br>
They are probably correct :-).</p>

<p><strong>How to check:</strong> You can check this yourself with an Ohm-meter set to the lowest Ohm range available - often = 200 Ohms max.</p>

<p>Turn off power to the board and leave it off for say 5 minutes to allow capacitors to discharge.<br>
Locate I4 and find its input and output pins or tracks leading to them. You can often get ohmic connections at vias as the tracks change board layers.<br>
IC4 pin1 will be grounded.<br>
One lead of C6 &amp; C7 are also grounded.<br>
The pad you can see in your photo on the board edge side of the caaps is probably the -ve terminals (about 99%+ likely) (and they match the can markings) 
and the ""stippled"" surface is almost certainly system ground.  </p>

<p>If you can confirm that the two caps are connected to ground as and where described above, then:</p>

<p>Apply Ohm meter probes between the non ground lead of a capacitor and each non-ground pin in turn of IC4. One of them will be a low resistance connection if they are C6 &amp; C7. Check the other capacitor - it should connect to the other side of IC4.<br>
Reversing the meter leads in each case may give somewhat different readings for non-hard-connected points but should be low and consistent for hard-connected by a track points. </p>
"
"<p>I am trying to read from a bluetooth module connected to arduino Uno. My application is a simple counter where the values are displayed on the arduino and the android app. The problem is that my android application get readings for some time (40-50 sec) and then stop at a random reading. When I check on the arduino serial monitor, the counter keeps counting and doesn't stop. Can someone please help? </p>

<p>Note: Ignore the buttons that I created :D</p>

<p>Java code:</p>

<pre><code>package com.example.ibm.bluetooth_3;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.util.UUID;
import com.example.ibm.bluetooth_3.R;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends Activity {
    private static final String TAG = ""bluetooth2"";

    Button btnOn, btnOff;
    TextView txtArduino;
    Handler h;

    final int RECIEVE_MESSAGE = 1;      // Status  for Handler
    private BluetoothAdapter btAdapter = null;
    private BluetoothSocket btSocket = null;
    private StringBuilder sb = new StringBuilder();

    private ConnectedThread mConnectedThread;

    // SPP UUID service
    private static final UUID MY_UUID = UUID.fromString(""00001101-0000-1000-8000-00805F9B34FB"");

    // MAC-address of Bluetooth module (you must edit this line)
    private static String address = ""00:06:66:68:30:D6"";

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        btnOn = (Button) findViewById(R.id.btnOn);                  // button LED ON
        btnOff = (Button) findViewById(R.id.btnOff);                // button LED OFF
        txtArduino = (EditText) findViewById(R.id.txtArduino);      // for display the received data from the Arduino
        h = new Handler() {
            public void handleMessage(android.os.Message msg) {
                switch (msg.what) {
                    case RECIEVE_MESSAGE:                                                   // if receive massage
                        byte[] readBuf = (byte[]) msg.obj;
                        String strIncom = new String(readBuf, 0, msg.arg1);                 // create string from bytes array
                        sb.append(strIncom);                                                // append string
                        int endOfLineIndex = sb.indexOf(""\r\n"");                            // determine the end-of-line
                        if (endOfLineIndex &gt; 0) {                                           // if end-of-line,
                            String sbprint = sb.substring(0, endOfLineIndex);               // extract string
                           sb.delete(0, sb.length());                                       // and clear
                            txtArduino.setText(sbprint);                                    // update TextView
                        }
                        //Log.d(TAG, ""...String:""+ sb.toString() +  ""Byte:"" + msg.arg1 + ""..."");
                        break;
                }
            };
        };

        btAdapter = BluetoothAdapter.getDefaultAdapter();       // get Bluetooth adapter
        checkBTState();

        btnOn.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                btnOn.setEnabled(true);
                mConnectedThread.write(""1"");    // Send ""1"" via Bluetooth
                //Toast.makeText(getBaseContext(), ""Turn on LED"", Toast.LENGTH_SHORT).show();
            }
        });

        btnOff.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                btnOff.setEnabled(true);
                mConnectedThread.write(""0"");    // Send ""0"" via Bluetooth
                //Toast.makeText(getBaseContext(), ""Turn off LED"", Toast.LENGTH_SHORT).show();
            }
        });
    }

    private BluetoothSocket createBluetoothSocket(BluetoothDevice device) throws IOException {
        if(Build.VERSION.SDK_INT &gt;= 10){
            try {
                final Method  m = device.getClass().getMethod(""createInsecureRfcommSocketToServiceRecord"", new Class[] { UUID.class });
                return (BluetoothSocket) m.invoke(device, MY_UUID);
            } catch (Exception e) {
                Log.e(TAG, ""Could not create Insecure RFComm Connection"",e);
            }
        }
        return  device.createRfcommSocketToServiceRecord(MY_UUID);
    }

    @Override
    public void onResume() {
        super.onResume();

        Log.d(TAG, ""...onResume - try connect..."");

        // Set up a pointer to the remote node using it's address.
        BluetoothDevice device = btAdapter.getRemoteDevice(address);

        // Two things are needed to make a connection:
        //   A MAC address, which we got above.
        //   A Service ID or UUID.  In this case we are using the
        //     UUID for SPP.

        try {
            btSocket = createBluetoothSocket(device);
        } catch (IOException e) {
            errorExit(""Fatal Error"", ""In onResume() and socket create failed: "" + e.getMessage() + ""."");
        }

    /*try {
      btSocket = device.createRfcommSocketToServiceRecord(MY_UUID);
    } catch (IOException e) {
      errorExit(""Fatal Error"", ""In onResume() and socket create failed: "" + e.getMessage() + ""."");
    }*/

        // Discovery is resource intensive.  Make sure it isn't going on
        // when you attempt to connect and pass your message.
        btAdapter.cancelDiscovery();

        // Establish the connection.  This will block until it connects.
        Log.d(TAG, ""...Connecting..."");
        try {
            btSocket.connect();
            Log.d(TAG, ""....Connection ok..."");
        } catch (IOException e) {
            try {
                btSocket.close();
            } catch (IOException e2) {
                errorExit(""Fatal Error"", ""In onResume() and unable to close socket during connection failure"" + e2.getMessage() + ""."");
            }
        }

        // Create a data stream so we can talk to server.
        Log.d(TAG, ""...Create Socket..."");

        mConnectedThread = new ConnectedThread(btSocket);
        mConnectedThread.start();
    }

    @Override
    public void onPause() {
        super.onPause();

        Log.d(TAG, ""...In onPause()..."");

        try     {
            btSocket.close();
        } catch (IOException e2) {
            errorExit(""Fatal Error"", ""In onPause() and failed to close socket."" + e2.getMessage() + ""."");
        }
    }

    private void checkBTState() {
        // Check for Bluetooth support and then check to make sure it is turned on
        // Emulator doesn't support Bluetooth and will return null
        if(btAdapter==null) {
            errorExit(""Fatal Error"", ""Bluetooth not support"");
        } else {
            if (btAdapter.isEnabled()) {
                Log.d(TAG, ""...Bluetooth ON..."");
            } else {
                //Prompt user to turn on Bluetooth
                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
                startActivityForResult(enableBtIntent, 1);
            }
        }
    }

    private void errorExit(String title, String message){
        Toast.makeText(getBaseContext(), title + "" - "" + message, Toast.LENGTH_LONG).show();
        finish();
    }

    private class ConnectedThread extends Thread {
        private final InputStream mmInStream;
        private final OutputStream mmOutStream;

        public ConnectedThread(BluetoothSocket socket) {
            InputStream tmpIn = null;
            OutputStream tmpOut = null;

            // Get the input and output streams, using temp objects because
            // member streams are final
            try {
                tmpIn = socket.getInputStream();
                tmpOut = socket.getOutputStream();
            } catch (IOException e) { }

            mmInStream = tmpIn;
            mmOutStream = tmpOut;
        }

        public void run() {
            byte[] buffer = new byte[1024];  // buffer store for the stream
            int bytes; // bytes returned from read()
            // Keep listening to the InputStream until an exception occurs
            while (true) {
                try {
                    // Read from the InputStream
                    bytes = mmInStream.read(buffer);        // Get number of bytes and message in ""buffer""
                    h.obtainMessage(RECIEVE_MESSAGE, bytes, -1, buffer).sendToTarget();     // Send to message queue Handler
                } catch (IOException e) {
                    break;
                }
            }
        }

        /* Call this from the main activity to send data to the remote device */
        public void write(String message) {
            Log.d(TAG, ""...Data to send: "" + message + ""..."");
            byte[] msgBuffer = message.getBytes();
            try {
                mmOutStream.write(msgBuffer);
            } catch (IOException e) {
                Log.d(TAG, ""...Error data send: "" + e.getMessage() + ""..."");
            }
        }
    }
}
</code></pre>

<p>Android XML:</p>

<pre><code>&lt;RelativeLayout xmlns:android=""http://schemas.android.com/apk/res/android""
    xmlns:tools=""http://schemas.android.com/tools"" android:layout_width=""match_parent""
    android:layout_height=""match_parent"" android:paddingLeft=""@dimen/activity_horizontal_margin""
    android:paddingRight=""@dimen/activity_horizontal_margin""
    android:paddingTop=""@dimen/activity_vertical_margin""
    android:paddingBottom=""@dimen/activity_vertical_margin"" tools:context="".MainActivity""
    android:focusable=""true""&gt;

    &lt;Button
        android:layout_width=""wrap_content""
        android:layout_height=""wrap_content""
        android:text=""On""
        android:id=""@+id/btnOn""
        android:layout_alignParentTop=""true""
        android:layout_centerHorizontal=""true""
        android:layout_marginTop=""52dp""
        android:enabled=""true""
        android:focusable=""true""
        android:focusableInTouchMode=""true"" /&gt;

    &lt;Button
        android:layout_width=""wrap_content""
        android:layout_height=""wrap_content""
        android:text=""Off""
        android:id=""@+id/btnOff""
        android:layout_below=""@+id/btnOn""
        android:layout_centerHorizontal=""true""
        android:layout_marginTop=""63dp""
        android:enabled=""true""
        android:focusable=""true""
        android:focusableInTouchMode=""true"" /&gt;

    &lt;EditText
        android:layout_width=""wrap_content""
        android:layout_height=""wrap_content""
        android:inputType=""number""
        android:ems=""10""
        android:id=""@+id/txtArduino""
        android:layout_below=""@+id/btnOff""
        android:layout_centerHorizontal=""true""
        android:layout_marginTop=""65dp"" /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>Android Manifest: </p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;manifest xmlns:android=""http://schemas.android.com/apk/res/android""
    package=""com.example.ibm.bluetooth_3"" &gt;
    &lt;uses-permission android:name=""android.permission.BLUETOOTH"" /&gt;
    &lt;uses-permission android:name=""android.permission.BLUETOOTH_ADMIN"" /&gt;
    &lt;application
        android:allowBackup=""true""
        android:icon=""@drawable/ic_launcher""
        android:label=""@string/app_name""
        android:theme=""@style/AppTheme"" &gt;
        &lt;activity
            android:name="".MainActivity""
            android:label=""@string/app_name"" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=""android.intent.action.MAIN"" /&gt;

                &lt;category android:name=""android.intent.category.LAUNCHER"" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</code></pre>

<p>Arduino code:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
SoftwareSerial mySerial (3, 2);
void setup()
{
  Serial.begin (57600);
  mySerial.begin (115200);
}

void loop()
{
  for (int i=0; i &lt; 1000000; i++)
  {
    mySerial.println (i);
    Serial.println (i);
    delay (100);
  }
} 
</code></pre>
"
"<p>Unless you intend to run both supplies simultaneously, there's no problem. Your ~ 6v input will need to be stepped down and regulated to 5v, and the USB provides a regulated 5v, so the system shouldn't care which one you are using.</p>

<p>If you need to run your system off the 6v during development and need USB communication, I'd suggest using a USB-to-TTL-Serial cable such as this one: <a href=""https://www.sparkfun.com/products/9718"" rel=""nofollow"">https://www.sparkfun.com/products/9718</a>. Connect its Tx &amp; Rx pins to your Arduino's (Uno?) pins 1 and 0, respectively, and it's ground pin to the ground rail served by your battery supply.</p>

<p>Typical regulators will need more headroom above their output voltage to give you a steady, regulated output, and this includes the 5v regulators on Arduino boards which usually specify 7-12v at the Vin (unregulated) input. A 6v battery won't meet this spec so you'd need a buck/boost regulator that could provide a regulated 5v from ""0+"" to 6v input. Or you might move your system to a bare AtMega328p with a lower clock speed (see the data sheet for max clock speed vs. Vcc), and run it at 3v (for example) which would give a simpler regulator more headroom from its 6v input.</p>
"
"<p>On the Arduino side, try increasing the delay or decreasing the baud rate. I have an application that dumps a stored history to a Bluetooth module talking to <a href=""https://play.google.com/store/apps/details?id=com.emrctn.BluetoothGraphics"" rel=""nofollow"">Bluetooth Terminal/Graphics</a>
on a Google Nexus 7. At 57600 baud, I've seen the same thing happen. My solution was to delay for 50ms after every 100 lines of output. While your Arduino code should be sending even slower than mine does, your Android system including your application code, might need an even slower input.</p>
"
"<p>I have written an ISR based timer library for Arduino Uno and  I would like to share it on website and get reviewed.   </p>

<p>But i am stuck on how to post it to playground.</p>
"
"<p>You should try another USB port, install the right drivers for the TTL/uart chip and reboot your PC. That worked for me.</p>

<hr>

<p>Also, you should consider getting an arduino nano usb, these have an built in ttl/uart converter, ICSP header and can be placed on a breadboard easily.</p>
"
"<p>The <a href=""http://playground.arduino.cc/Main/LibraryList"" rel=""nofollow"">Arduino Playground library list</a> is a wiki page (like everything on the playground). That means anyone can log in to edit it and add links to their own libraries. The ""Log In"" and ""Sign Up"" links are at the top right of the Arduino site.</p>

<p>There are a couple of important things to note though. Firstly, the Playground library list isn't there for getting your work reviewed. It's a place to post things which are functional and ready to be used by other people. If you need someone to help with your project then you can maybe post on the Arduino forums. Alternatively, if you have specific questions, you can post here on Arduino SE.</p>

<p>If you're ready to post your library online, you also have to be aware that the Playground itself won't host your code. You can put a link there and maybe some documentation. However, you'll need to host your code somewhere else, such as <a href=""https://github.com"" rel=""nofollow"">Github</a>.</p>
"
"<p>I suspect you problem stems from the use of delay's in your code. for example,</p>

<pre><code>if (data=='1')
 {
  digitalWrite(13,HIGH);
  delay(4000);
  digitalWrite(13,LOW);
  delay(4000);
 } 
</code></pre>

<p>Those delays prevent any computations from happening for 4 seconds each. Your arduino will not read another character after it sees a <code>'1'</code> for 8 seconds. If you send too much data in that 8 seconds to fit in the serial buffer, the extra characters are lost.</p>

<p>The behavior you seem to want will require separating the code that reads serial from the code that runs the output, and making sure neither section ever stops execution with delays. Your blinks will need to be timed with something else, like frequent comparisons against the current time with <code>millis()</code></p>
"
"

<p>I'm trying to configure a Zigbee sensor network. My ""gateway (coordinator)"" and ""End devices"" are made with XBeePro S2B model and configured in API mode ""2"". The ""gateway (coordinator)"" also has a SIM900 module, for uploading data to website (recieved on XBee), and Atmega 328p for codes (for ""gateway (coordinator)"" I'm using a Gboard device <a href=""http://imall.iteadstudio.com/im120411004.html"" rel=""nofollow"">here</a>), and for ""End devices"", I make/print a PCB with a atmega328p, XBee and PIR sensor.</p>

<p>The configuration works fine with several ""End devices"" (sincerilly, I have only tested with two ""End devices"", because it is expensive)...</p>

<p>The problem is when the ""gateway (coordinator)"" recieve data from more than one ""End devices"" <strong>at the same time</strong>. In this situation (""End devices"" sending simultaneously) the ""gateway (coordinator)"" only recieves one packet (and only uploads that data to the website). I'm sure that I have a trouble with my code (sorry for the desestructurated and chaotic code, I'm a newbie).</p>

<p>Can anyone help me with the code? </p>

<p>code ""gateway (coordinator)"":</p>

<pre class=""lang-C++ prettyprint-override""><code>#include &lt;elapsedMillis.h&gt;
#include &lt;SoftwareSerial.h&gt;
#include &lt;Streaming.h&gt; 
#include &lt;XBee.h&gt;      
int xbeeRecibido;
char urlArreglo[100];
uint8_t slCmd[] = {'S','L'};  
uint8_t dbCmd[] = {'D','B'}; 
char adr_part[8];
char rssiValor_part[8];
String adr="""";
String rssiValor="""";
AtCommandRequest atRequest = AtCommandRequest();
AtCommandResponse atResponse = AtCommandResponse();  
elapsedMillis timeElapsed = 0;
unsigned long interval = 1800000 ;////en milisegundos  cada 30 min.
String direccionRed;
int bateria;
String valorRssi;
int actividadPir;
String datosHttp; ///concatenacion de datos para enviar por HTTP
int8_t answer;
char data[512];
int data_size;
char aux_str[100];
char aux;
int x = 0;
XBee xbee = XBee();//XBee object
Rx16Response rx = Rx16Response();
SoftwareSerial mySerial(2, 3); //PARA GPRS SIM900
//int b00;  //este seria el primero, que se pierde al buscar el 0X7E
int b01;
int b02;
int b03;
int b04; //source network adress 64Bit 
int b05; //source network adress 64Bit
int b06; //source network adress 64Bit
int b07; //source network adress 64Bit
int b08; //source network adress 64Bit
int b09; //source network adress 64Bit
int b10; //source network adress 64Bit
int b11; //source network adress 64Bit 
int b12; //source network adress 16Bit
int b13; //source network adress 16Bit
int b14;
int b15; //pir digital
int b16; //bateria 
int b17; //checksum
void setup() {
   pinMode(14, OUTPUT);////led debug en 14 ((A0)DEBUGGGG!!!!
   pinMode(6, OUTPUT);///para encender SIM900 ...en pin6 HIGH de arduino GBOARD
   digitalWrite(6, HIGH);///para encender SIM900 ...en pin6 HIGH de arduino GBOARD
    mySerial.begin(9600); 
    Serial.begin(9600);
///////GPRS////////
    power_on();
    delay(3000);
    sendATcommand(""AT+ipr=9600"", ""OK"", 2000);///////MIO PARA BAUDERATE A 9600 (por defecto 0=auto..¿se apaga?)
    // sets the PIN code
    sendATcommand(""AT+CPIN=****"", ""OK"", 2000);
    delay(3000);
    while (sendATcommand2(""AT+CREG?"", ""+CREG: 0,1"", ""+CREG: 0,5"", 2000) == 0);
    sendATcommand(""AT+SAPBR=3,1,\""Contype\"",\""GPRS\"""", ""OK"", 2000);
    sendATcommand(""AT+SAPBR=3,1,\""APN\"",\""gprsmov.pepephone.com\"""", ""OK"", 2000);
    sendATcommand(""AT+SAPBR=3,1,\""USER\"",\""\"""", ""OK"", 2000);
    sendATcommand(""AT+SAPBR=3,1,\""PWD\"",\""\"""", ""OK"", 2000);
    while (sendATcommand(""AT+SAPBR=1,1"", ""OK"", 20000) == 0)
    {
        delay(5000);
    }
////FIN GPRS////
lanzarHttpAutoControl();
delay(15000);
}

void loop() {  
if (timeElapsed &gt; interval) 
    {               
        lanzarHttpAutoControl();
        delay(15000);
    timeElapsed = 0;
    }
if (Serial.available()==18) {//make sure the frame is all there      
  if (Serial.read()==0x7E) {   
     b01 = Serial.read();     
     b02 = Serial.read();
     b03 = Serial.read();    
     b04 = Serial.read(); //source network adress 64Bit 
     b05 = Serial.read(); //source network adress 64Bit    
     b06 = Serial.read(); //source network adress 64Bit 
     b07 = Serial.read(); //source network adress 64Bit     
     b08 = Serial.read(); //source network adress 64Bit 
     b09 = Serial.read(); //source network adress 64Bit     
     b10 = Serial.read(); //source network adress 64Bit 
     b11 = Serial.read(); //source network adress 64Bit 
     b12 = Serial.read(); //source network adress 16Bit
     b13 = Serial.read(); //source network adress 16Bit
     b14 = Serial.read(); 
     b15 = Serial.read(); //pir digital   
     b16 = Serial.read(); //bateria
     b17 = Serial.read();  //checksum
     direccionRed =  String(b04, HEX); 
     direccionRed +=  String(b05, HEX); 
     direccionRed +=  String(b06, HEX);
     direccionRed +=  String(b07, HEX);
     direccionRed +=  String(b08, HEX);
     direccionRed +=  String(b09, HEX);
     direccionRed +=  String(b10, HEX);
     direccionRed +=  String(b11, HEX);  
     actividadPir = b15;
     bateria = int(b16);
     digitalWrite(14, HIGH);//FOR DEBUG LED
     delay(1000);//FOR DEBUG LED
     digitalWrite(14, LOW);//FOR DEBUG LED
     xbeeRecibido = 1;
        } //fin if 0x7E 
  }///fin recorrer bytes 
   else {
         if (xbeeRecibido == 1) {///si se ha recibido info de xbee sensor
         colectorDatos();
         xbeeRecibido = 0;         
        }
   }
delay (10);
}//fin loop


void rss() {  ///PARA RSSI
   /* returns received signal strength value for the last RF data packet */
   union {byte B; char C;} atCmd[3];
   AtCommandRequest atCmdReq;
   AtCommandResponse atResp;
   byte respLen, *resp, dBm;
   strcpy(&amp;atCmd[0].C, ""DB"");
   atCmdReq = AtCommandRequest(&amp;atCmd[0].B);
   atResp = AtCommandResponse();
   xbee.send(atCmdReq);
   if (xbee.readPacket(5000)) {
       if (xbee.getResponse().getApiId() == AT_COMMAND_RESPONSE) {
           xbee.getResponse().getAtCommandResponse(atResp);
           if (atResp.isOk()) {
               respLen = atResp.getValueLength();
               if (respLen == 1) {
                   resp = atResp.getValue();
                   dBm = resp[0];
                   valorRssi = (String)dBm;  
               }
               else {
               }
           }
           else {
           }
       }
       else {
       }
   }
   else {
   } 
}///fin rss()


void power_on(){
    uint8_t answer=0;
    // checks if the module is started
    answer = sendATcommand(""AT"", ""OK"", 2000);
    if (answer == 0)
    {
        // waits for an answer from the module
        while(answer == 0){  
            // Send AT every two seconds and wait for the answer   
            answer = sendATcommand(""AT"", ""OK"", 2000);    
        }
    }
}


int8_t sendATcommand(char* ATcommand, char* expected_answer1, unsigned int timeout){
    uint8_t x=0,  answer=0;
    char response[100];
    unsigned long previous;
    memset(response, '\0', 100);    // Initialize the string
    delay(100);
    while( mySerial.available() &gt; 0) mySerial.read();    // Clean the input buffer
    mySerial.println(ATcommand);    // Send the AT command 
        x = 0;
    previous = millis();
    // this loop waits for the answer
    do{
        if(mySerial.available() != 0){    
            response[x] = mySerial.read();
            x++;
            // check if the desired answer is in the response of the module
            if (strstr(response, expected_answer1) != NULL)    
            {
                answer = 1;
            }
        }
        // Waits for the asnwer with time out
    }
    while((answer == 0) &amp;&amp; ((millis() - previous) &lt; timeout));    
    return answer;
}


int8_t sendATcommand2(char* ATcommand, char* expected_answer1, 
char* expected_answer2, unsigned int timeout){
    uint8_t x=0,  answer=0;
    char response[100];
    unsigned long previous;
    memset(response, '\0', 100);    // Initialize the string
    delay(100);
    while( mySerial.available() &gt; 0) mySerial.read();    // Clean the input buffer
    mySerial.println(ATcommand);    // Send the AT command 
        x = 0;
    previous = millis();
    // this loop waits for the answer
    do{        
        if(mySerial.available() != 0){    
            response[x] = mySerial.read();
            x++;
            // check if the desired answer 1 is in the response of the module
            if (strstr(response, expected_answer1) != NULL)    
            {
                answer = 1;
            }
            // check if the desired answer 2 is in the response of the module
            if (strstr(response, expected_answer2) != NULL)    
            {
                answer = 2;
            }
        }
     // Waits for the asnwer with time out
    }while((answer == 0) &amp;&amp; ((millis() - previous) &lt; timeout));    
    return answer;
}


void colectorDatos(){ ///funcion para recolectar datos recibidos del xbee y gestionarlos para enviarlos por GPRS
    rss(); ////recupero rssi que se pone en variable valorRssi
    datosHttp = direccionRed +"";""; ///cualquier valor del array, todos deverian tener mismo valor (direccion64bits)
    datosHttp += bateria; 
    datosHttp += "";"";
    datosHttp += valorRssi;
    datosHttp += "";"";
    datosHttp += actividadPir; //pir 
    envio(datosHttp); ///envio por gprs    
}///fin colectorDatos


void lanzarHttpAutoControl() {
  adr="""";
  atRequest.setCommand(slCmd);  // set command to SL to get low part of MAC address 
  while (!sendAtCommand()) {};
  for (int i = 0; i &lt; atResponse.getValueLength(); i++) {
    mySerial.print(atResponse.getValue()[i], HEX);
    sprintf(adr_part, ""%lX"", (unsigned long)(atResponse.getValue()[i]));
    if (atResponse.getValue()[i]&lt;=0xF) 
        adr += 0;      
        adr += adr_part; 
  } 
  envio(adr); ///envio por gprs

}


void envio(String entrada){///envio GPRS...recibe String con datos (o control o sensor)
   memset(urlArreglo, 0, sizeof(urlArreglo));///a cero el array
    answer = sendATcommand(""AT+HTTPINIT"", ""OK"", 10000);
    if (answer == 1)
    {
        // Sets CID parameter
        answer = sendATcommand(""AT+HTTPPARA=\""CID\"",1"", ""OK"", 5000);
        if (answer == 1)
        {
      sprintf(urlArreglo,  ""AT+HTTPPARA=\""URL\"",\""www.pestmonitors.com/dream/prueba_gsm_get.php?datos=%s\"""",entrada.c_str());
      answer = sendATcommand(urlArreglo, ""OK"", 5000);
       delay(5000);       
            if (answer == 1)
            {
                answer = sendATcommand(""AT+HTTPACTION=0"", ""+HTTPACTION:0,200"", 10000);             
            }
    else
    {
    }  
    sendATcommand(""AT+HTTPTERM"", ""OK"", 5000);
    delay(5000);   
      }
    }  
}


int sendAtCommand() { // used here to sens AT command to the Xbee to get information such as the MAC address
  xbee.send(atRequest);
  if (xbee.readPacket(5000)) {
    if (xbee.getResponse().getApiId() == AT_COMMAND_RESPONSE) {
      xbee.getResponse().getAtCommandResponse(atResponse);
      if (atResponse.isOk()) {
        if (atResponse.getValueLength() &gt; 0) {
          mySerial.println(atResponse.getValueLength(), DEC);
          for (int i = 0; i &lt; atResponse.getValueLength(); i++) {
            mySerial.print(atResponse.getValue()[i], HEX);
          }
        }
        return 1;
      } 
      else {
      }
    } else {
      mySerial.print(xbee.getResponse().getApiId(), HEX);
    }   
  } else {
    if (xbee.getResponse().isError()) {
    } 
    else {  
    }
  }
  return 0;
}
</code></pre>

<p>code ""End devices"":</p>

<pre class=""lang-C++ prettyprint-override""><code>#include &lt;Sleep_n0m1.h&gt;
#include &lt;XBee.h&gt;
XBee xbee = XBee();
uint8_t payload[] = { 0, 0 };
XBeeAddress64 addr64 = XBeeAddress64(0x0, 0xFFFF);
ZBTxRequest zbTx = ZBTxRequest(addr64, payload, sizeof(payload));
ZBTxStatusResponse txStatus = ZBTxStatusResponse();
boolean apagar;
int battVolts;
int PinEntradaBat = A0;
int valorBateriaTotal;
int valorBateria;
int mapeoValorBateria;
Sleep sleep;
unsigned long sleepTime; //how long you want the arduino to sleep
int salida = 7; ////pin salida 7 para DTR xbee
int entradaInterrumpirSleep =2; ////pin desde pir para interrumpir/despertar 
boolean abortSleep; //cancel sleep cycle
int modo;
int cicloTiempoSleep;///establecer ciclo alarma
int numeroCiclos; ///para retomar ciclo si falsa alarma
boolean enviado; ///para comprobar si recepción de xbbe, sino, reenviar!
uint8_t atdCmd[]={'D','5'};
uint8_t value[]={4};///pongo DIO5 a output LOW
uint8_t length=1;
AtCommandRequest atRequest = AtCommandRequest(atdCmd, value, length);
AtCommandResponse atResponse = AtCommandResponse(); 
//boolean saltarPrimerPir = true; ////PARA NUEVO PIR, SALTAR LA ALARMA AL ARRANCAR ¿PORQUE?
void setup()
{  
  analogReference(DEFAULT); 
  enviado = true;
  numeroCiclos = 0; 
  apagar = false; 
  pinMode(salida, OUTPUT); //para DTR en xbee
  pinMode(6, OUTPUT); //para MOSFET (en digitalPin6 PWM)!!
  digitalWrite(salida, LOW); //EMITE 5V HACIA DTR, ENVIAR EN XBEE
  delay(120000);//2 minutos para evitar primer interrupt!y dar tiempo a comprobar tecnico la asociación
  abortSleep = false; //can be used to cancel the sleep cycle
  sleep.setCalibrationInterval(1);
  sleepTime = 1000;//set sleep time in ms, max sleep time is 49.7 days (1/2 1 min)
  modo = 0; //para empezar con modo CONTROL 
  numeroCiclos = 0;
  Serial.begin(9600);
  xbee.setSerial(Serial);  
  xbee.send(atRequest);// set command to ATD50 to stop LED Assoc...////DESCOMENTAR PARA APAGAR LED ASSOC!!!!!!
  delay(5000);
}//fin setup


void loop()
{
if (apagar == true) { ///APAGAR SI BATERIA MUY BAJA!!!!
  detachInterrupt(0);  
  while (apagar == true) {
  }
}   
  if (modo == 0) {
    detachInterrupt(0);
    digitalWrite(salida, LOW); //EMITE 0V HACIA DTR, ENVIAR EN XBEE
    digitalWrite(6, HIGH); //EMITE 5V HACIA mosfet/regulador, ENCIENDE XBEE    
    cicloTiempoSleep = 21600; //6 horas
    delay(10);
    enviarXbee(0);    
    digitalWrite(salida, HIGH);//EMITE 5V HACIA DTR, ACTIVAR DTR (XBEE SLEEP)   
    digitalWrite(6, LOW); //EMITE 0V HACIA mosfet/regulador, APAGAR 
    delay(30000);///30seg de inactividad post envio control!
    attachInterrupt(0, interrumpirPir, RISING);    
  } //fin modo0 CONTROL
  if (modo == 1) {
        detachInterrupt(0);
        digitalWrite(salida, LOW); //EMITE 0V HACIA DTR, ENVIAR EN XBEE
        digitalWrite(6, HIGH); //EMITE 5V HACIA mosfet/regulador, ENCIENDE XBEE
        modo = 0; //modo CONTROL
        numeroCiclos = 0; 
        cicloTiempoSleep = 21600; //6 horas para enviar CONTROL despues de ACTIVIDAD
        delay(10);
        enviarXbee(1); 
        digitalWrite(salida, HIGH);//EMITE 5V HACIA DTR, ACTIVAR DTR (XBEE SLEEP)   
        digitalWrite(6, LOW); //EMITE 0V HACIA mosfet/regulador, APAGAR 
        delay(120000);///2 minutos de inactividad post envio alarma! (para no enviar otra enseguida)
        attachInterrupt(0, interrumpirPir, RISING);
  }//fin modo1 ACTIVIDAD
  abortSleep = false;
  for (int i=0; i &lt; cicloTiempoSleep; i++){ /////ARREGLO CON FOR PARA REITERAR 1000ms (1seg) x VECES (hace extraños el int0 con SleepDelay juntos) 
        numeroCiclos = i;
        sleep.pwrDownMode(); //set sleep mode 
        sleep.sleepDelay(sleepTime,abortSleep); //sleep for: sleepTime
        if (abortSleep == true) {
          break;
        }
   }//fin contador tiempo
  if (cicloTiempoSleep &lt;= 1 || numeroCiclos == --cicloTiempoSleep) { ///estos dos -- restan 1 al valor de la variable
    modo = 0;
  }
}//fin loop


void interrumpirPir() // si disparo PIR por interrupt0 (isr)
{  
  if (numeroCiclos != 0) {/////AQUI EVITAR PRIMERA INTERRUPCION AL INICIARSE EL SENSOR/////
  abortSleep = true;
  cicloTiempoSleep = cicloTiempoSleep - numeroCiclos;
  modo = 1; 
  }//fin saltar primer PIR 
}///fin interrumpir! ISR


void enviarXbee(int valorPir) // si disparo PIR por interrupt0 (isr)
{    
battVolts=getBandgap();
valorBateriaTotal = 0;
for (int e=0; e &lt; 20; e++) 
    {
       mapeoValorBateria = map(analogRead(A1), 0, 1023, 0, battVolts);
       valorBateriaTotal = valorBateriaTotal + mapeoValorBateria;
     delay(10);
    } 
valorBateriaTotal = valorBateriaTotal/20;
if (mapeoValorBateria &lt;= 95) {///APAGAR SI BATERIA MUY BAJA!!!!
apagar = true;
}    
    payload[0] = valorPir; ///PIR
    payload[1] = mapeoValorBateria &amp; 0xff;
    delay (10000);
    xbee.send(zbTx);
    //delay (15000);
    if (xbee.readPacket(5000)) {        
      if (xbee.getResponse().getApiId() == ZB_TX_STATUS_RESPONSE) {
        xbee.getResponse().getZBTxStatusResponse(txStatus);
        if (txStatus.getDeliveryStatus() == SUCCESS) {
         // enviado = true;
        } else {
        //  enviado = false;     
        }
      }
    } else if (xbee.getResponse().isError()) {
    } else {
    } 
}//end enviar xbee


long leerBateria()//para ver estado bateria
{
}
int getBandgap(void) // Returns actual value of Vcc (x 100)
   {      
#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
    // For mega boards
    const long InternalReferenceVoltage = 1115L;  // Adjust this value to your boards specific internal BG voltage x1000
       // REFS1 REFS0          --&gt; 0 1, AVcc internal ref. -Selects AVcc reference
       // MUX4 MUX3 MUX2 MUX1 MUX0  --&gt; 11110 1.1V (VBG)         -Selects channel 30, bandgap voltage, to measure
    ADMUX = (0&lt;&lt;REFS1) | (1&lt;&lt;REFS0) | (0&lt;&lt;ADLAR)| (0&lt;&lt;MUX5) | (1&lt;&lt;MUX4) | (1&lt;&lt;MUX3) | (1&lt;&lt;MUX2) | (1&lt;&lt;MUX1) | (0&lt;&lt;MUX0);
#else
    // For 168/328 boards
    const long InternalReferenceVoltage = 1056L;  // Adjust this value to your boards specific internal BG voltage x1000
       // REFS1 REFS0          --&gt; 0 1, AVcc internal ref. -Selects AVcc external reference
       // MUX3 MUX2 MUX1 MUX0  --&gt; 1110 1.1V (VBG)         -Selects channel 14, bandgap voltage, to measure
    ADMUX = (0&lt;&lt;REFS1) | (1&lt;&lt;REFS0) | (0&lt;&lt;ADLAR) | (1&lt;&lt;MUX3) | (1&lt;&lt;MUX2) | (1&lt;&lt;MUX1) | (0&lt;&lt;MUX0);     
#endif
    delay(50);  // Let mux settle a little to get a more stable A/D conversion
       // Start a conversion  
    ADCSRA |= _BV( ADSC );
       // Wait for it to complete
    while( ( (ADCSRA &amp; (1&lt;&lt;ADSC)) != 0 ) );
       // Scale the value
    int results = (((InternalReferenceVoltage * 1023L) / ADC) + 5L) / 10L; // calculates for straight line value 
    return results;
   }
int sendAtCommand() {
  xbee.send(atRequest);
  if (xbee.readPacket(5000)) {// wait up to 5 seconds for the status response
    if (xbee.getResponse().getApiId() == AT_COMMAND_RESPONSE) {// should be an AT command response
      xbee.getResponse().getAtCommandResponse(atResponse);
      if (atResponse.isOk()) {
        if (atResponse.getValueLength() &gt; 0) {
          for (int i = 0; i &lt; atResponse.getValueLength(); i++) {
          }
        }
      } 
      else {
      }
    } else {
    }   
  } else {
    if (xbee.getResponse().isError()) {
    } 
    else {
    }
  }
}
</code></pre>

<p>Thank you very much. I really appreciate your help.</p>
"
"<p>I don't like <code>serialEvent()</code> because <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/main.cpp#L40-L45"" rel=""nofollow"">it only checks to see if it should run that function after the whole loop is executed</a>. With your new example, it's basically the same as the original (except you moved that code to the very bottom of the loop).</p>

<p>I'm not sure exactly how fast the data is sent, but you should first ask yourself if the data is sent fast enough that you don't even notice that it's blocking. Blocking code isn't bad itself (except maybe from a standpoint of the other device freezing up and stalling your program), but blocking code <em>that takes a long time</em> is bad.</p>

<p>Since you need five bytes, the best thing would be to wrap the blocking code in an if statement like this:</p>

<pre><code>if(Serial.available &gt;= 5) {
  //Blocking code here
}
</code></pre>

<p>It's simple and readable, yet effective.</p>
"
"<p>Interestingly enough, <strong>Serial.read()</strong> does not work like most of us think.</p>

<p>Serial.read() is not blocking, it always returns immediately with a byte 0-255 or -1 if there is no character to read. </p>

<p>From Arduino Reference</p>

<blockquote>
  <p><strong>Description</strong></p>
  
  <p>Reads incoming serial data. read() inherits from the Stream utility class.</p>
  
  <p><strong>Syntax</strong></p>
  
  <p>Serial.read()</p>
  
  <p><strong>Parameters</strong></p>
  
  <p>None</p>
  
  <p><strong>Returns</strong></p>
  
  <p>the first byte of incoming serial data available (or -1 if no data is available) - int</p>
</blockquote>
"
"<p>Not sure if you could get the bootloader to support SD, but i have little experience with bootloader code, so it the way i would go about it would be to make the sketch load content from the SD that then effects the sketch process.</p>
"
"<p>Firstly if you only need short runs, go with the usb battery pack answer, but if you need the longest time from least batteries:</p>

<p>As has been pointed out, for best battery consumption an arduino board is not efficient due to power regulators and led lights. For best performance you want a standalone 328 chip with its BOD (brown out detector) reduced to 1.8v and then you can run it and the nrf24 chip off 2x AA batteries.</p>

<p>But all this might be a bit beyond you.</p>

<p>One thing though that will help your battery life is a PNP transistor or Mosfet on the +ve of your nrf24l01+ module triggered by a arduino io pin. as these power amplified versions dont sleep (per say, the chip does but not the PA) so it will always be consuming a large amount of power regardless of state. So just use your io pin to power it on and off for each use. </p>

<p>(that is unless you need it on always for recieving, in which case this wont help)</p>
"
"<p>Another thing to consider is that a nrf24l01+ chip at full power will potentially be pulling more current than your 5v reg can supply, try a lower power setting on the PA.</p>
"
"<p>Comparing your rx against the example, i would suggest not having the while done statement. You could also throw in a few serial.write debug lines in both sketches, to log different parts of the code, to find where its getting stuck.</p>
"
"<p>I've got some working code with a definition that looks like this:</p>

<pre><code>const unsigned char DynTextPositions[10][4][4] = {
    ...
};
</code></pre>

<p>Which is defined / referenced via a header:</p>

<pre><code>#include &lt;avr/pgmspace.h&gt;
#ifndef DYNTEXTPOS_H
#define DYNTEXTPOS_H

extern const unsigned char DynTextPositions[10][4][4];

#endif
</code></pre>

<p>This data is being fed into a rendering function which draws lines based on the given positions. The data is read as follows:</p>

<pre><code>float deltas[4][4];
// ...
deltas[n][k] = float(DynTextPositions[c+1][n][k] - DynTextPositions[c][n][k]) / 32.0;
</code></pre>

<p>As-is, this works just fine, as long as I've got my other scenes commented out. When I uncomment them, the combined data size seems to overflow the data segment. This is expected, because there's a fair bit of data, so I'm trying to move the <code>DynTextPositions</code> data into <code>PROGMEM</code>.</p>

<p>I've got <code>PROGMEM</code> working with some bitmaps, but it doesn't seem to work here. An example definition for a working bitmap is as follows:</p>

<pre><code>PROGMEM const unsigned char ArduinoLogo[] = { ... };
</code></pre>

<p>However, as soon as I apply the <code>PROGMEM</code> attribute to <code>DynTextPositions</code> the rendering code seems to freak out - the positions appear to be all off-screen and completely wrong.</p>

<p>The only thing I can think of is that, for some reason, the data is either being considered signed rather than unsigned, or is getting corrupted along the way. Either that or the nested array is somehow being treated as a set of pointers.</p>

<p>Any idea why this might be?</p>
"
"<p>Including <code>&lt;avr/pgmspace.h&gt;</code> and using the <code>PROGMEM</code> qualifier macro are only two of the steps required in order to get this to work. Since the data will no longer be available via the data bus you will need to use the various <code>pgm_read_*()</code> macros or <code>*_P*()</code> functions defined in <a href=""http://www.nongnu.org/avr-libc/user-manual/group__avr__pgmspace.html"" rel=""nofollow""><code>avr/pgmspace.h</code></a>. These work by using the appropriate assembly code instructions to access data stored in program space, i.e. flash, on the MCU.</p>

<p>Under GCC 4.7 or higher when writing C code, the <code>__flash</code> named address space is available. Variables declared within this namespace do not require any additional steps to access them. Note that the Arduino IDE compiles as C++, and hence does not make this (or any of the <a href=""https://gcc.gnu.org/onlinedocs/gcc/Named-Address-Spaces.html#AVR-Named-Address-Spaces"" rel=""nofollow"">others</a>) available.</p>
"
"<p>also im in the try of that.YOU HAVE TO USE USB TO SERIAL CONVERTOR CIRCUIT TO ACCESS ARDUINO BY UART (mosi....... miso) connections .and the software in the dongle is the problem here.the difference between the gsm shield and the dongle is .........the SOFTWARE  FIREWALL you have to flash the dongle by your own risk.........try this</p>
"
"<p>My idea is Arduino sensor will read and pass the values read on android. Then android will calculate and send the control value (PWM) to the Arduino.
but android can only get the value from the Arduino but can not send them back to the Arduino ... Can someone please help?
This my code:</p>

<p>java code:</p>

<p>+MainActivity</p>

<pre><code>package com.example.tut1;

import java.nio.ByteBuffer;
import java.util.Timer;
import java.util.TimerTask;

import android.app.Activity;
import android.bluetooth.BluetoothSocket;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.graphics.Color;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;

import com.example.tut1.Bluetooth;
import com.jjoe64.graphview.GraphView;
import com.jjoe64.graphview.GraphView.GraphViewData;
import com.jjoe64.graphview.GraphView.LegendAlign;
import com.jjoe64.graphview.GraphViewSeries;
import com.jjoe64.graphview.GraphViewSeries.GraphViewStyle;
import com.jjoe64.graphview.LineGraphView;

public class MainActivity extends Activity implements View.OnClickListener {

    // private StringBuilder recDataString = new StringBuilder();

@Override
public void onBackPressed() {
    // TODO Auto-generated method stub
    if (Bluetooth.connectedThread != null) {
        Bluetooth.connectedThread.write(""Q"");
    }// Stop streaming
    super.onBackPressed();
}


// khai bao bien
String x, x1;
int u,u1,adc,adc1;
public String sensor, sensor1;
static boolean f=false;
// toggle Button
static boolean Lock;// whether lock the x-axis to 0-5
static boolean AutoScrollX;// auto scroll to the last x value
static boolean Stream;// Start or stop streaming
// Button init
Button bXminus;
Button bXplus;
Button bConnect, bDisconnect;
Button bStart,bStop;
TextView tvBluetooth, tvpid;
ToggleButton tbLock;
ToggleButton tbScroll;
ToggleButton tbStream;
// GraphView init
static LinearLayout GraphView, GraphView1;
static GraphView graphView, graphView1;
static GraphViewSeries Series, Series1;
// graph value
private static double graph2LastXValue = 0, graph2LastXValue1 = 0;
private static int Xview = 10, Xview1 = 10;

// khai bao bien timer
final Handler thandler = new Handler();
Timer t = new Timer();
TimerTask mTimerTask;

Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        // TODO Auto-generated method stub
        super.handleMessage(msg);
        switch (msg.what) {
        case Bluetooth.SUCCESS_CONNECT:
            Bluetooth.connectedThread = new Bluetooth.ConnectedThread(
                    (BluetoothSocket) msg.obj);
            Toast.makeText(getApplicationContext(), ""Connected!"", 0).show();
            String s = ""successfully connected"";
            Bluetooth.connectedThread.start();
            break;
        case Bluetooth.MESSAGE_READ:

            byte[] readBuf = (byte[]) msg.obj;
            String strIncom = new String(readBuf); // create string from
                                                    // bytes array

            // if(strIncom.indexOf('s')==0){
            // strIncom = strIncom.replace(""s"", """");
            // }
            int a = strIncom.indexOf(""c"");
            int b = 4;
            int c = 4;
            int d = 8;
            sensor = (String) strIncom.subSequence(1, 5);
            sensor1 = (String) strIncom.subSequence(5, 9);
            tvBluetooth.setText(strIncom);
//              Bluetooth.connectedThread.write(""E"");
//              adc=Integer.parseInt(sensor);
//              adc1=Integer.parseInt(sensor1);
            tvpid.setText(sensor + ""-"" + sensor1+""-""+u+""-""+u1);
            // String readMessage = (String)msg.obj;
            // recDataString.append(readMessage);
            // sensor = recDataString.substring(0, 4);
            Log.d(""strIncom"", sensor);
            // if (strIncom.indexOf('.')==2 &amp;&amp; strIncom.indexOf('s')==0){
            // strIncom = strIncom.replace(""s"", """");
            if((strIncom.indexOf(""X"")==9)&amp;&amp;(strIncom.indexOf(""Y"")==0)){
            if (isFloatNumber(sensor) &amp;&amp; isFloatNumber(sensor1)) {
                Series.appendData(new GraphViewData(graph2LastXValue,
                        Double.parseDouble(sensor)), AutoScrollX);
                Series1.appendData(new GraphViewData(graph2LastXValue1,
                        Double.parseDouble(sensor1)), AutoScrollX);

                // X-axis control
                if (graph2LastXValue &gt;= Xview &amp;&amp; Lock == true) {
                    Series.resetData(new GraphViewData[] {});
                    graph2LastXValue = 0;
                } else
                    graph2LastXValue += 0.1;

                if (Lock == true)
                    graphView.setViewPort(0, Xview);
                else
                    graphView.setViewPort(graph2LastXValue - Xview, Xview);

                // grap1
                if (graph2LastXValue1 &gt;= Xview1 &amp;&amp; Lock == true) {
                    Series1.resetData(new GraphViewData[] {});
                    graph2LastXValue1 = 0;
                } else
                    graph2LastXValue1 += 0.1;

                if (Lock == true)
                    graphView1.setViewPort(0, Xview1);
                else
                    graphView1.setViewPort(graph2LastXValue1 - Xview1,
                            Xview1);

                // refresh
                GraphView.removeView(graphView);
                GraphView1.removeView(graphView1);
                GraphView.addView(graphView);
                GraphView1.addView(graphView1);
                dieukhienPPM();
                dieukhienPH();
            }
             }
//              if(f)
//              t.schedule(mTimerTask, 60, 60);

//              u = (int) adc/4;
//              u1=(int) adc1/4;
//              f=true;
            break;
        }
    }

    public boolean isFloatNumber(String num) {
        // Log.d(""checkfloatNum"", num);
        try {
            Double.parseDouble(num);
        } catch (NumberFormatException nfe) {
            return false;
        }
        return true;
    }

};

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    this.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
    requestWindowFeature(Window.FEATURE_NO_TITLE);// Hide title
    this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
            WindowManager.LayoutParams.FLAG_FULLSCREEN);// Hide Status bar
    setContentView(R.layout.activity_main);
    // set background color
    LinearLayout background = (LinearLayout) findViewById(R.id.bg);
    background.setBackgroundColor(Color.BLACK);
    init();
    ButtonInit();
}

void init() {
    Bluetooth.gethandler(mHandler);

    // init graphview
    GraphView = (LinearLayout) findViewById(R.id.Graph);
    // init example series data-------------------
    Series = new GraphViewSeries(""Signal"", new GraphViewStyle(Color.YELLOW,
            2),// color and thickness of the line
            new GraphViewData[] { new GraphViewData(0, 0) });
    graphView = new LineGraphView(this // context
            , ""Graph"" // heading
    );
    graphView.setViewPort(0, Xview);
    graphView.setScrollable(true);
    graphView.setScalable(true);
    graphView.setShowLegend(true);
    graphView.setLegendAlign(LegendAlign.BOTTOM);
    graphView.setManualYAxis(true);
    graphView.setManualYAxisBounds(1024, 0);
    graphView.addSeries(Series); // data
    GraphView.addView(graphView);

    GraphView1 = (LinearLayout) findViewById(R.id.Graph1);
    // init example series data-------------------
    Series1 = new GraphViewSeries(""Signal"", new GraphViewStyle(
            Color.YELLOW, 2),// color and thickness of the line
            new GraphViewData[] { new GraphViewData(0, 0) });
    graphView1 = new LineGraphView(this // context
            , ""Graph1"" // heading
    );
    graphView1.setViewPort(0, Xview1);
    graphView1.setScrollable(true);
    graphView1.setScalable(true);
    graphView1.setShowLegend(true);
    graphView1.setLegendAlign(LegendAlign.BOTTOM);
    graphView1.setManualYAxis(true);
    graphView1.setManualYAxisBounds(1024, 0);
    graphView1.addSeries(Series1); // data
    GraphView1.addView(graphView1);
}

void ButtonInit() {
    bConnect = (Button) findViewById(R.id.bConnect);
    bConnect.setOnClickListener(this);
    bDisconnect = (Button) findViewById(R.id.bDisconnect);
    bDisconnect.setOnClickListener(this);
    bStart = (Button) findViewById(R.id.bStart);
    bStart.setOnClickListener(this);
    bStop = (Button) findViewById(R.id.bStop);
    bStop.setOnClickListener(this);
    // X-axis control button
    // bXminus = (Button)findViewById(R.id.bXminus);
    // bXminus.setOnClickListener(this);
    // bXplus = (Button)findViewById(R.id.bXplus);
    // bXplus.setOnClickListener(this);
    // //
    // tbLock = (ToggleButton)findViewById(R.id.tbLock);
    // tbLock.setOnClickListener(this);
    // tbScroll = (ToggleButton)findViewById(R.id.tbScroll);
    // tbScroll.setOnClickListener(this);
//      tbStream = (ToggleButton) findViewById(R.id.tbStream);
//      tbStream.setOnClickListener(this);
    tvBluetooth = (TextView) findViewById(R.id.tvBluetooth);
    tvpid = (TextView) findViewById(R.id.tvpid);
    // init toggleButton
    Lock = true;
    AutoScrollX = true;
    Stream = false;
}

@Override
public void onClick(View v) {
    // TODO Auto-generated method stub
    switch (v.getId()) {
    case R.id.bConnect:
        startActivity(new Intent(""android.intent.action.BT1""));
        break;
    case R.id.bDisconnect:
        Bluetooth.disconnect();
        break;
    case R.id.bStart:
        if (Bluetooth.connectedThread != null)
            Bluetooth.connectedThread.write(""E"");
            doTimerTask();
        break;
    case R.id.bStop:
        if (Bluetooth.connectedThread != null)
            Bluetooth.connectedThread.write(""Q"");
        stopTask();
        break;
    // case R.id.bXminus:
    // if (Xview&gt;1) Xview--;
    // break;
    // case R.id.bXplus:
    // if (Xview&lt;30) Xview++;
    // break;
    // case R.id.tbLock:
    // if (tbLock.isChecked()){
    // Lock = true;
    // }else{
    // Lock = false;
    // }
    // break;
    // case R.id.tbScroll:
    // if (tbScroll.isChecked()){
    // AutoScrollX = true;
    // }else{
    // AutoScrollX = false;
    // }
    // break;
//      case R.id.tbStream:
//          if (tbStream.isChecked()) {
//              if (Bluetooth.connectedThread != null)
//                  Bluetooth.connectedThread.write(""E"");
//          } else {
//              if (Bluetooth.connectedThread != null)
//                  Bluetooth.connectedThread.write(""Q"");
//          }
//          break;
    }
}

public void doTimerTask() {
    mTimerTask = new TimerTask() {
        public void run() {
            thandler.post(new Runnable() {
                public void run() {
                    // TODO Auto-generated method stub
 //                     dieukhienPPM();
//                      dieukhienPH();
                    Bluetooth.connectedThread.write(""A"");
                    x = Integer.toString(u);    
                    Bluetooth.connectedThread.write(x);
                    Bluetooth.connectedThread.write(""B"");
                    x1=Integer.toString(u1);
                    Bluetooth.connectedThread.write(x1);
                    Bluetooth.connectedThread.write(""S"");
                }
            });
        }
    };

    // public void schedule (TimerTask task, long delay, long period)
     t.schedule(mTimerTask, 500, 500); // Thoi gian delay va thoi gian lap
    // tinh
    // bang mili giay
}

public void stopTask() {
    if (mTimerTask != null)
        mTimerTask.cancel();
}

public void dieukhienPPM() {
    u= (Integer.parseInt(sensor)/4);
}

public void dieukhienPH() {
    u1 = (Integer.parseInt(sensor1)/4);
}

public static byte[] toByteArray(double value) {
    byte[] bytes = new byte[8];
    ByteBuffer.wrap(bytes).putDouble(value);
    return bytes;
}
}
</code></pre>

<p>+Bluetooth</p>

<pre><code>package com.example.tut1;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Set;
import java.util.UUID;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.Toast;

public class Bluetooth extends Activity implements OnItemClickListener{

public static void disconnect(){
    if (connectedThread != null) {
        connectedThread.cancel(); 
        connectedThread = null;
    }
}

public static void gethandler(Handler handler){//Bluetooth handler
    mHandler = handler;
}
static Handler mHandler = new Handler();

static ConnectedThread connectedThread;
public static final UUID MY_UUID = UUID.fromString(""00001101-0000-1000-8000-           00805F9B34FB"");
protected static final int SUCCESS_CONNECT = 0;
protected static final int MESSAGE_READ = 1;
ArrayAdapter&lt;String&gt; listAdapter;
ListView listView;
static BluetoothAdapter btAdapter;
Set&lt;BluetoothDevice&gt; devicesArray;
ArrayList&lt;String&gt; pairedDevices;
ArrayList&lt;BluetoothDevice&gt; devices;
IntentFilter filter;
BroadcastReceiver receiver;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_bluetooth);
    init();
    if (btAdapter==null){
        Toast.makeText(getApplicationContext(), ""No bluetooth detected"", 0).show();
        finish();
    }else{
        if (!btAdapter.isEnabled()){
            turnOnBT();
        }
        getPairedDevices();
        startDiscovery();
    }

}


private void startDiscovery() {
    // TODO Auto-generated method stub
    btAdapter.cancelDiscovery();
    btAdapter.startDiscovery();
}

private void turnOnBT() {
    Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
    startActivityForResult(intent, 1);
}

private void getPairedDevices() {
    devicesArray = btAdapter.getBondedDevices();
    if (devicesArray.size()&gt;0){
        for(BluetoothDevice device:devicesArray){
            pairedDevices.add(device.getName());
        }
    }
}

private void init(){
    listView = (ListView)findViewById(R.id.listView);
    listView.setOnItemClickListener(this);
    listAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1,0);
    listView.setAdapter(listAdapter);
    btAdapter = BluetoothAdapter.getDefaultAdapter();
    pairedDevices = new ArrayList&lt;String&gt;();
    filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
    devices = new ArrayList&lt;BluetoothDevice&gt;(); 
    receiver = new BroadcastReceiver(){
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (BluetoothDevice.ACTION_FOUND.equals(action)){
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
                devices.add(device);
                String s = """";
                for(int a=0;a&lt;pairedDevices.size();a++){
                    if (device.getName().equals(pairedDevices.get(a))){
                        //append
                        s = ""(Paired)"";
                        break;
                    }
                }
                listAdapter.add(device.getName()+"" ""+s+"" ""+""\n""+device.getAddress());

            }else if (BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)){

            }else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)){

            }else if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)){
                if (btAdapter.getState() == btAdapter.STATE_OFF){
                    turnOnBT();
                }
            }  
        }

    };

    registerReceiver(receiver, filter);
    IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    registerReceiver(receiver, filter);
    filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    registerReceiver(receiver, filter);
    filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
}

@Override
protected void onPause() {
    // TODO Auto-generated method stub
    super.onPause();
    unregisterReceiver(receiver);
}

protected void onActivityResult(int requestCode, int resultCode, Intent data){
    super.onActivityResult(requestCode, resultCode, data);
    if (resultCode == RESULT_CANCELED){
        Toast.makeText(getApplicationContext(), ""Bluetooth must be enabled to continue"", Toast.LENGTH_SHORT).show();
        finish();
    }
}

@Override
public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2, long arg3) {
    // TODO Auto-generated method stub
    if (btAdapter.isDiscovering()){
        btAdapter.cancelDiscovery();
    }
    if (listAdapter.getItem(arg2).contains(""(Paired)"")){

        BluetoothDevice selectedDevice = devices.get(arg2);
        ConnectThread connect = new ConnectThread(selectedDevice);
        connect.start();
    }else {
        Toast.makeText(getApplicationContext(), ""device is not paired"", 0).show();
    }
}

private class ConnectThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final BluetoothDevice mmDevice;

    public ConnectThread(BluetoothDevice device) {
        // Use a temporary object that is later assigned to mmSocket,
        // because mmSocket is final
        BluetoothSocket tmp = null;
        mmDevice = device;

        // Get a BluetoothSocket to connect with the given BluetoothDevice
        try {
            // MY_UUID is the app's UUID string, also used by the server code
            tmp = device.createRfcommSocketToServiceRecord(MY_UUID);
        } catch (IOException e) { }
        mmSocket = tmp;
    }

    public void run() {
        // Cancel discovery because it will slow down the connection
        btAdapter.cancelDiscovery();

        try {
            // Connect the device through the socket. This will block
            // until it succeeds or throws an exception
            mmSocket.connect();
            //connectedThread = new ConnectedThread(mmSocket);
        } catch (IOException connectException) {
            // Unable to connect; close the socket and get out
            try {
                mmSocket.close();
            } catch (IOException closeException) { }
            return;
        }

        // Do work to manage the connection (in a separate thread)
        mHandler.obtainMessage(SUCCESS_CONNECT, mmSocket).sendToTarget();
    }

    /** Will cancel an in-progress connection, and close the socket */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}

static class ConnectedThread extends Thread {
    private final BluetoothSocket mmSocket;
    private final InputStream mmInStream;
    private final OutputStream mmOutStream;

    public ConnectedThread(BluetoothSocket socket) {
        mmSocket = socket;
        InputStream tmpIn = null;
        OutputStream tmpOut = null;

        // Get the input and output streams, using temp objects because
        // member streams are final
        try {
            tmpIn = socket.getInputStream();
            tmpOut = socket.getOutputStream();
        } catch (IOException e) { }

        mmInStream = tmpIn;
        mmOutStream = tmpOut;
    }
    StringBuffer sbb = new StringBuffer();
    public void run() {

        byte[] buffer;  // buffer store for the stream
        int bytes; // bytes returned from read()

        // Keep listening to the InputStream until an exception occurs
        while (true) {
            try {
                try {
                    sleep(30);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

                buffer = new byte[1024];
                // Read from the InputStream
                bytes = mmInStream.read(buffer);
                // Send the obtained bytes to the UI activity
                mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer).sendToTarget();
            } catch (IOException e) {
                break;
            }
        }
    }

    /* Call this from the main activity to send data to the remote device */
    public void write(String income) {

        try {
            mmOutStream.write(income.getBytes());
            for(int i=0;i&lt;income.getBytes().length;i++)
            Log.v(""outStream""+Integer.toString(i),Character.toString((char)(Integer.parseInt(Byte.toString(income.getBytes()[i])))));
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (IOException e) { }
    }

    public void write_1(byte[] bytes) {
        try {
            mmOutStream.write(bytes);
            try{
                Thread.sleep(20);
            }catch(InterruptedException e){
                e.printStackTrace();
            }
        } catch (IOException e) { }
    }



    /* Call this from the main activity to shutdown the connection */
    public void cancel() {
        try {
            mmSocket.close();
        } catch (IOException e) { }
    }
}

}
</code></pre>

<p>code arduino</p>

<pre><code>float nhietdo,doam,nhietdotb,doamtb;
float t,p;
char re;
char p1,p2;
int chanlaynhiet=0;
int pwm,pwm1;
String nhan,nhan1;
boolean batdau = false; 
void setup()
{
 Serial.begin(9600);
 pinMode(10,OUTPUT);
 pinMode(11,OUTPUT);
 pinMode(8,OUTPUT);
 }

void loop()
{
if(Serial.available()&gt;0){
 re = Serial.read();
 switch(re){
 case 'S':
 Send();
 digitalWrite(8,LOW);
 break;

  case 'A':
  nhan=Serial.read();
  //digitalWrite(8,LOW);
  break; 

  case 'B':
  nhan1=Serial.read();
  //digitalWrite(8,LOW);
   break;

  case 'E' :
  batdau = true;
  break;  

  case 'Q':
  batdau = false;
  break; 
 }
  if(batdau){
   start();  
   }  
}



void start()
{
 while(1)
 {//doc ppm
   for(int i=0;i&lt;10;i++)
   {
   nhietdotb=nhietdotb+analogRead(A0);
   delay(1);
   }
   nhietdo=nhietdotb/10;
   nhietdotb=0;
   //doc ph
   for(int j=0;j&lt;10;j++)
   {
  doamtb=doamtb+analogRead(A1);
  delay(1);
   }
  doam=doamtb/10;
  doamtb=0;
 //if (isDigit(pwm1))
 //analogWrite(10,pwm1);
 //if (isDigit(pwm2))
 //analogWrite(11,pwm2);
 analogWrite(11,nhan1.toInt);
 analogWrite(10,nhan.toInt);
 digitalWrite(8,HIGH);

 if(Serial.available()&gt;0)
 return;
}
}

void Send()
 {
  Serial.print('s');
  Serial.print('Y');
   if((nhietdo&lt;1000)&amp;&amp;(nhietdo&gt;=100)){
   Serial.print(""0"");
   }else if((nhietdo&lt;100)&amp;&amp;(nhietdo&gt;=10)){
   Serial.print(""00"");
   }else if(nhietdo&lt;10){
   Serial.print(""000""); 
  }
   Serial.print(nhietdo,0); 

if((doam&lt;1000)&amp;&amp;(doam&gt;=100)){
  Serial.print(""0"");
  }else if((doam&lt;100)&amp;&amp;(doam&gt;=10)){
  Serial.print(""00"");
  }else if(doam&lt;10){
  Serial.print(""000"");
 }
 Serial.print(doam,0);
 Serial.print('X');
 Serial.print(nhan);
 Serial.print(nhan1);
}
</code></pre>
"
"<p>I have a specific arduino code (no .ino files) <a href=""https://github.com/justintconroy/MdbBillValidator"" rel=""nofollow"">https://github.com/justintconroy/MdbBillValidator</a> , which can't be opened by arduino IDE. How can I make &amp; upload this code? I have an arduino 2560 mega.</p>

<p>I've created an empty <code>MdbBillValidator.ino</code> file and added these lines:</p>

<pre><code>#include ""MdbBillValidator.h""

void setup() {

}

void loop() {

}
</code></pre>

<p>Here is the error message</p>

<pre><code>MdbSerial.cpp: In function ‘void __vector_37()’:
MdbSerial.cpp:289:23: error: ‘TXB8’ was not declared in this scope
MdbSerial.cpp:291:24: error: ‘TXB8’ was not declared in this scope
MdbSerial.cpp: In function ‘void __vector_52()’:
MdbSerial.cpp:314:23: error: ‘TXB8’ was not declared in this scope
MdbSerial.cpp:316:24: error: ‘TXB8’ was not declared in this scope
MdbSerial.cpp: In function ‘void __vector_55()’:
MdbSerial.cpp:339:23: error: ‘TXB8’ was not declared in this scope
MdbSerial.cpp:341:24: error: ‘TXB8’ was not declared in this scope
MdbSerial.cpp: At global scope:
MdbSerial.cpp:554:135: error: expected ‘)’ before numeric constant
MdbSerial.cpp:554:189: error: no matching function for call to ‘MdbSerial::MdbSerial(ring_buffer*, ring_buffer*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, int, int, int, int, int, int, int, int, int, int, int)’
MdbSerial.cpp:554:189: note: candidates are:
MdbSerial.cpp:352:1: note: MdbSerial::MdbSerial(ring_buffer*, ring_buffer*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
MdbSerial.cpp:352:1: note:   candidate expects 20 arguments, 19 provided
In file included from MdbSerial.cpp:38:0:
MdbSerial.h:52:7: note: MdbSerial::MdbSerial(const MdbSerial&amp;)
MdbSerial.h:52:7: note:   candidate expects 1 argument, 19 provided
</code></pre>
"
"<p>sr,
Arduino code</p>

<pre><code>float nhietdo,doam,nhietdotb,doamtb;
float t,p;
char re;
char p1,p2;
int chanlaynhiet=0;
int pwm,pwm1;
String nhan,nhan1;
boolean batdau = false; 
void setup()
{
  Serial.begin(9600);
  pinMode(10,OUTPUT);
  pinMode(11,OUTPUT);
  pinMode(8,OUTPUT);
}
void loop()
{
if(Serial.available()&gt;0){
re = Serial.read();
switch(re){
  case 'S':
  Send();
  digitalWrite(8,LOW);
  break;

  case 'A':
  nhan=Serial.read();
//      digitalWrite(8,LOW);
      break; 

      case 'B':
      nhan1=Serial.read();
//      digitalWrite(8,LOW);
       break;

      case 'E' :
      batdau = true;
      break;  

      case 'Q':
      batdau = false;
      break; 
    }
    if(batdau){
     start();  
    }  
  }



void start()
{
  while(1)
  {//doc ppm
    for(int i=0;i&lt;10;i++)
    {
    nhietdotb=nhietdotb+analogRead(A0);
    delay(1);
    }
    nhietdo=nhietdotb/10;
    nhietdotb=0;
    //doc ph
    for(int j=0;j&lt;10;j++)
    {
   doamtb=doamtb+analogRead(A1);
   delay(1);
    }
   doam=doamtb/10;
   doamtb=0;
//    if (isDigit(pwm1))
//   analogWrite(10,pwm1);
//   if (isDigit(pwm2))
//   analogWrite(11,pwm2);
   analogWrite(11,nhan1.toInt);
   analogWrite(10,nhan.toInt);
   digitalWrite(8,HIGH);

   if(Serial.available()&gt;0)
   return;
}
}

void Send()
{
   Serial.print('s');
   Serial.print('Y');
   if((nhietdo&lt;1000)&amp;&amp;(nhietdo&gt;=100)){
   Serial.print(""0"");
   }else if((nhietdo&lt;100)&amp;&amp;(nhietdo&gt;=10)){
   Serial.print(""00"");
   }else if(nhietdo&lt;10){
   Serial.print(""000""); 
  }
   Serial.print(nhietdo,0); 

   if((doam&lt;1000)&amp;&amp;(doam&gt;=100)){
  Serial.print(""0"");
  }else if((doam&lt;100)&amp;&amp;(doam&gt;=10)){
  Serial.print(""00"");
  }else if(doam&lt;10){
  Serial.print(""000"");
 }
 Serial.print(doam,0);
 Serial.print('X');
 Serial.print(nhan);
 Serial.print(nhan1);
}
</code></pre>
"
"<p>Just trying to understand and use the SoftwareSerial</p>

<p>I want to connect a WiFi Module (ESP8266)
If I send an AT command to the module I would like to print a response on my pc screen in the serial monitor</p>

<p>Some example code it tried</p>

<pre><code>   SoftwareSerial dbgSerial(10, 11); // RX, TX
   void setup()
   {
     // Open serial communications and wait for port to open:
     Serial.begin(57600);
     Serial.setTimeout(5000);
     dbgSerial.begin(9600); //can't be faster than 19200 for softserial
     dbgSerial.println(""ESP8266 Demo"");
     //test if the module is ready
     Serial.println(""AT+RST"");
     delay(1000);
     if(Serial.find(""ready""))
     {
       dbgSerial.println(""Module is ready"");
</code></pre>

<p>I would like to receive ready in the serial</p>
"
"<p>I've wrote a code for arduino mega, and want to force it from copying (this is commerce project). How can I obfuscate .hex file before uploading to arduino?</p>
"
"<p>Looks like you are swapping the use of <code>Serial</code> and <code>dbgSerial</code>. I think you mean to use <code>Serial</code> to print to the computer and <code>dbgSerial</code> to communicate with your module. <code>Serial.println</code> should display the message in the terminal on your computer.</p>
"
"<p>I was wondering how can I get 4 Arduinos in total to communicate with each-other through a wired connection. The goal is to have the master Arduino send a number 0-100 to each of the other arduinos.</p>

<p>The master unit will be an Arduino uno and the other 3 arduinos will be Arduino pro-minis.</p>
"
"<p>Recently I bought a <a href=""http://rads.stackoverflow.com/amzn/click/B006RATC2E"" rel=""nofollow"">B006RATC2E</a> wireless shield for my Arduino One, but didn't notice that I had to buy a wifi module as well to let it work (bad surprise as the shield already cost me $30 + travel expenses to CR). Could someone be so kind to suggest me some compatible wifi modules for the shield?</p>

<p>I'm kind of newbie in this and when I search specs for Adafruit and XBee modules, the documentation is not explicit about the compatibility with Arduino shields, so I'm stuck.</p>

<p>I don't want to buy components that would't work together (my budget is limited). Is <a href=""http://rads.stackoverflow.com/amzn/click/B007R9U1QA"" rel=""nofollow"">XBee XB24</a> a good module for the shield? Any other alternative?</p>

<p>Thanks in advance for any help!</p>
"
"<p>You can use the I2C communication protocol through the wire.h library. That will permit you to use the arduino uno as master device and the pro minis as slave.
Briefly, you use a two wire's connected to the SDA and SCL pins of all the arduino board and then the master to interact ( meaning request data and send data) with the slaves uses there address (that is user defined in the slave software). So the normal routine in I2C goes like this:</p>

<ol>
<li>The master sends the address plus the read write instruction on the bus.</li>
<li>All the arduino boards listen and if the address matches with there internal adress they perform the instruction.</li>
<li>If it is write command from the master the slaves prepare to receive. If it is read command from the master, the master waits until the slave send a byte.</li>
</ol>

<p>Fr more information go on:</p>

<p><a href=""http://arduino.cc/en/Reference/Wire"" rel=""nofollow"">Arduino two wire communication</a></p>

<p><a href=""https://www.google.it/urlhttps://www.google.it/url?sa=t&amp;source=web&amp;rct=j&amp;ei=IIsZVZ31G8bsUveEgbgB&amp;url=http://www.nxp.com/documents/user_manual/UM10204.pdf&amp;ved=0CB4QFjAB&amp;usg=AFQjCNG5emVs3tU5RbGVKjblTMFgLLHdqg&amp;sig2=rdzEDOM6eEHT43fGziDtxQ"" rel=""nofollow"">I2C official datasheet</a></p>
"
"<p>I want to power an Arduino Leonardo with an external power supply and simultanously communicate via USB. I have read some other threads on this topic, therefore, I know that if one supplies more than 7V over the power jack, the board will use the external power supply in this case.</p>

<p>My suspicion is rather concerning the ground connection. From the schematic, I can tell that the USB ground is connected via a tiny coil to the board ground, so with DC it is shorted. Wouldn't that cause problems if the computer's USB ground is at a different potential than the external power supply of the board, resulting in a voltage between the two grounds? What if this voltage is up to several Volts?</p>

<p>Thanks a lot!</p>
"
"<p>Why do you suspect a potential difference? Where is th 7V coming from? If the 7V power supply is free floating and used for nothing else, there is no source for potential difference.</p>

<p>A typical wall wart will have a free floating output.</p>
"
"<p>I want to send a generic (not Sony, etc.) remote's signal from my Arduino.  I have already used a IR decoder program to capture the timing of the signal:</p>

<pre><code>int IRsignal[] = {
// ON, OFF (in 10's of microseconds)
    88, 88,
    174, 88,
    86, 86,
    88, 86,
    88, 88,
    86, 86,
    88, 174,
    86, 88,
    86, 88,
    174, 174,
    86, 88,
    86, 2252,
    88, 88,
    174, 88,
    86, 86,
    88, 88,
    86, 88,
    86, 86,
    86, 176,
    86, 88,
    86, 88,
    174, 174,
    86, 88,
    86, 0};
</code></pre>

<p>Now I need to send this through the IR LED.  I have never written a program that can modulate a signal at this microsecond level.  How would I do this?</p>
"
"<p>I have this microphone (<a href=""http://www.digikey.com/product-detail/en/CMA-4544PF-W/102-1721-ND/1869981"" rel=""nofollow"">http://www.digikey.com/product-detail/en/CMA-4544PF-W/102-1721-ND/1869981</a>) and an Arduino Uno board. I'm trying to read audio values off of my microphone (to test the noise of something (in dB)). I'm very new at this kind of stuff so keeping it simple would really help me out! I have a bunch of different capacitors, LM386N op amps, a bread board, and many resistors. Could someone provide a code and schematic that could help me get data off of my mic? I've tried using this schematic: <a href=""http://wiring.org.co/learning/basics/microphone.html"" rel=""nofollow"">http://wiring.org.co/learning/basics/microphone.html</a>
but couldn't get the code to download onto a Wiring S board due to a ""timeout"" error and it not being able to ""connect with the programmer"". </p>

<p>Any and all help would be much appreciated!! </p>
"
"<p>I'm building a project to measure/track <a href=""http://en.wikipedia.org/wiki/Flyball"" rel=""nofollow"">flyball</a> dog races.
The dogs timings are measured by photoelectric sensors at the start/finish line of the racing lane.
I have most of my code working (<a href=""https://github.com/vyruz1986/FlyballSensor"" rel=""nofollow"">available</a> on github) but I'm having some difficulties in handling very short crossings of dogs. Since I cannot realistically run a real race at home next to my development machine :-), I'm trying to build a simulator class which gives the triggers that would normally come from my photoelectric sensors.</p>

<p>I have a RaceHandler class which has the following in its header file:</p>

<pre><code>class RaceHandlerClass
{
 public:
   long* lRaceStartTime = &amp;_lRaceStartTime;

 private:
   long _lRaceStartTime;
}
extern RaceHandlerClass RaceHandler;
</code></pre>

<p>As you can see I made a public pointer lRaceStartTime which points to the private _lRaceStartTime member variable.
This might seem stupid/strange, but it really should a private member variable, I just want to 'temporarily' make it publicly available, so that I can use it in a temporary 'simulator' class to simulate a race towards my code.</p>

<p>Then I want to use this public pointer in the Simulator class like so:</p>

<pre><code>long* lRaceStartTime = RaceHandler.lRaceStartTime;
long lRaceElapsedTime = micros() - lRaceStartTime;
</code></pre>

<p>However I get the following error when trying to compile this:</p>

<blockquote>
  <p>error: invalid operands of types 'long unsigned int' and 'long int*'
  to binary 'operator-'</p>
</blockquote>

<p>I'm afraid my c++ knowledge ends here and I have no clue what I should do different to fix this...
Any help would be greatly appreciated!</p>
"
"<p>Very interesting stuff. As you are new to this kind of stuff i can suggest you, instead of explaining ( because videos are cool), to watch <a href=""https://youtu.be/hpMVG4a9sR4"" rel=""nofollow"">this video</a> that explains very clearly how to use the lm386 with some filters. That video is a project about controlling the arduino through whistling. Hope that helped.</p>
"
"<p>I have two square wave signals with the same frequency. I want to measure the phase shift between these two signals. There will be a small phase difference between two signals. (0-90 degree) and the frequency will vary in the range 100mHz - 50kHz. I am using an Arduino DUE (ATMEL ATSAM3X8E AU ,ARM)</p>

<p>I tried to use ""micros()"" for timer functionality to get 2 different times and then calculate the phase shift using the following code:</p>

<pre><code>int led=47,count1=0,count2=0,temp=0;
int i=0,j=0;
float time1[3]={0,0};
float time2[3]={0,0};
float freq1=0,freq2=0;
float period1=0,period2=0;
float ps=0;


void setup()
{
      Serial.begin(9600);
      Serial.println();
       Serial.println();
      pinMode(31,INPUT);
      pinMode(33,INPUT);
      pinMode(led,OUTPUT);
      digitalWrite(led,HIGH);
      noInterrupts();  
      attachInterrupt(31,in1,RISING);
      attachInterrupt(33,in2,RISING);
      interrupts();
}

void in1()
{      noInterrupts();
       switch(i){
           case 0 : time1[i]=micros(); i++;  break;
           case 1 : if(j==1){time1[i]=micros(); i++; break;}
       }
       interrupts();
}
void in2()
{      noInterrupts();
       switch(j){
            case 0 : if(i==1){time2[j]=micros(); j++; break;}
            case 1 : if(i==2){time2[j]=micros(); j++; break;}
       }
           if(j==2){
             period1 = (time1[1]-time1[0]);
             period2 = (time2[1]-time2[0]);          
             freq1 = 1000.0/period1;         
             freq2 = 1000.0/period2;         
             ps = (((time2[1]-time1[1])*360.0)s/period1);
          if(freq1==freq2){
          Serial.println("""");
          Serial.print(""TIME1[0] = "");
          Serial.print(time1[0],6);
          Serial.print(""\t TIME1[1] = "");
          Serial.print(time1[1],6);
          Serial.print(""\t DEL1 = "");
          Serial.println(time1[1]-time1[0],6);
          Serial.print(""TIME2[0] = "");
          Serial.print(time2[0],6);
          Serial.print(""\t TIME2[1] = "");
          Serial.print(time2[1],6);
          Serial.print(""\t DEL2 = "");
          Serial.println(time2[1]-time2[0],6);
          Serial.print(""\t x = "");
          Serial.print(time2[0]-time1[0],6);
          Serial.print(""period1(ms) = "");
          Serial.print(period1,6);
          Serial.print(""\t period2(ms) = "");
          Serial.println(period2,6);
          Serial.print(""freq1 = "");
          Serial.print(freq1,6);
          Serial.print(""\t freq2 = "");
          Serial.print(freq2,6);
          Serial.print(""\t Phase Shift = "");
          Serial.println(ps,6);
          } 
          else { 
          i=0;j=0;
          interrupts();
          }        
       }
       interrupts();
}
void loop()
{
       ;
}
</code></pre>

<p>When I run this code I am not getting any errors, but in high frequency (above 400 Hz) Ihave a problem. When I tested at 0 degrees, this code produced this output:</p>

<pre><code>400 Hz 1.152 degree
500 Hz 1.440 degree
600 Hz 1.727 degree
700 Hz 2.015 degree
800 Hz 2.304 degree
900 Hz 2.592 degree
1 kHz  2.880 degree
2 kHz  5.760 degree
3 kHz  8.649 degree
.
.
.
10 kHz 28.8 degree
</code></pre>

<p>Each frequency has lowest degree that this code can calculate.</p>

<p>How can I fix this code? Is it possible to calculate the phase shift between two square wave signals this way?</p>
"
"<p>With 0° you have two inputs triggering interrupts at the same time.  That can't happen.  You can't run two interrupts at the same time, so the second one gets queued up until the first has finished.</p>

<p>With all that serial printing in there there's going to be quite a delay between one interrupt triggering and the next one being allowed to trigger - giving you skewed results.</p>

<p>I would suggest passing your signal through an XOR gate so that you end up with a single small pulse that represents the phase shift between the two signals.</p>
"
"<p>Even if your code worked perfectly, with zero processing latency, you still are working with a timer resolution of only 1 microsecond.  If I did my math correctly, that means at 50 kHz, the smallest phase difference you can detect is around 18 degrees.  At 100 MHz, 1 microsecond is 100 complete cycles.  You probably want to look into hardware specifically designed for <a href=""http://en.wikipedia.org/wiki/Phase_detector"" rel=""nofollow"">phase detection</a>.</p>
"
"<p>Connect the two signals to the TIOA pins of two different timer/counter channels on the same timer/counter block (either TIOA0 and TIOA1, which are Arduino pins 2 and A7, or any two of TIOA6, TIOA7, and TIOA8, which are Arduino pins 5, 3, and 11, respectively).</p>

<p>Set the two timer channels to capture mode, ""up"" counting, and internal clocking at the fastest rate that seems appropriate (I don't see any reason not to use <code>TIMER_CLOCK1</code> = 42MHz on the Due). Set them both to load RA on rising edge of TIOA, and RB on falling edge. Assuming TIOA0 and 1:</p>

<pre><code>pmc_enable_periph_clk(ID_TC0);
TC_Configure(TC0, 0,
    TC_CMR_TCCLKS_TIMER1 |
    TC_CMR_WAVSEL_UP |
    TC_CMR_LDRA_RISING |
    TC_CMR_LDRB_FALLING
);

pmc_enable_periph_clk(ID_TC1);
TC_Configure(TC0, 1,
    TC_CMR_TCCLKS_TIMER1 |
    TC_CMR_WAVSEL_UP |
    TC_CMR_LDRA_RISING |
    TC_CMR_LDRB_FALLING
);
</code></pre>

<p>Set them both to generate interrupts on RA load:</p>

<pre><code>TC0-&gt;TC_CHANNEL[0].TC_IER = TC_IER_LDRAS;
NVIC_EnableIRQ(TC0_IRQn);
TC0-&gt;TC_CHANNEL[1].TC_IER = TC_IER_LDRAS;
NVIC_EnableIRQ(TC1_IRQn);
</code></pre>

<p>Enable both clocks, and synchronize them so that they're both 0 at the same moment:</p>

<pre><code>TC0-&gt;TC_CHANNEL[0].TC_CCR = TC_CCR_CLKEN;
TC0-&gt;TC_CHANNEL[1].TC_CCR = TC_CCR_CLKEN;
TC0-&gt;TC_BCR = TC_BCR_SYNC;
</code></pre>

<p>And handle the interrupts:</p>

<pre><code>void TC0_Handler() {
    uint32_t status = TC0-&gt;TC_CHANNEL[0].TC_SR;
    if (status &amp; TC_SR_LDRAS) {
        uint32_t tm = TC0-&gt;TC_CHANNEL[0].TC_RA;
        // rising edge of TIOA0 happened at ""tm"",
        // do something here to deal with it...
    }
}

void TC1_Handler() {
    uint32_t status = TC0-&gt;TC_CHANNEL[1].TC_SR;
    if (status &amp; TC_SR_LDRAS) {
        uint32_t tm = TC0-&gt;TC_CHANNEL[1].TC_RA;
        // rising edge of TIOA1 happened at ""tm"",
        // do something here to deal with it...
    }
}
</code></pre>

<p>(Just defining functions with those names registers them as interrupt handlers, using weak-symbol magic).</p>

<p>If you choose to use TIOA6/7/8, the clock will be <code>ID_TC6</code>/<code>ID_TC7</code>/<code>ID_TC8</code>, and the <code>EnableIRQ</code> will be <code>TC6_IRQn</code>/<code>TC7_IRQn</code>/<code>TC8_IRQn</code>, but the <code>TC_Configure</code> calls will be <code>TC2, 0</code> / <code>TC2, 1</code> / <code>TC2, 2</code>, the <code>SYNC</code> will be issued to <code>TC2</code>, and the register accesses will be to <code>TC2-&gt;TC_CHANNEL[0]</code> / <code>TC2-&gt;TC_CHANNEL[1]</code> / <code>TC2-&gt;TC_CHANNEL[2]</code>. This is due to the way that the channels are grouped into blocks of three in the hardware. This is also why you have to use 0 and 1, or two of 6, 7, and 8; in order to sync the timers they have to be on the same block (and TIOA2 through TIOA5 aren't routed on the Due).</p>

<p>Because the clocks run at MClk/2 = 42MHz, the times you get will be in units of 1/42 microsecond, 42 times better than you get from <code>micros()</code>. Because the timer values are latched into the timer hardware <em>before</em> the interrupt is set, there isn't a problem if the two events come close to each other in time; you'll get the second interrupt after you finish handling the first, and the value in the register will still be valid (as long as you don't take so long that you miss more than one edge).</p>

<p>If you're interested in the falling edges, you can get those as well by setting the <code>TC_IER_LDRBS</code> bits and checking for <code>status &amp; TC_SR_LDRBS</code> in your interrupt handlers.</p>

<p>Final advice: set your serial baud rate higher than 9600 if you can, you'll greatly decrease the amount of time you spend in <code>Serial.print</code>!</p>
"
"<p>I am using an Arduino in an automation project which will be using a state machine to conduct a one-hour scenario.  Currently, the Arduino reads each input pin, runs its state update script, then sets each update pin.  99.99% of the time, each output pin will be set to the same state that it had in the last step.  Although it is better (in my opinion) to only set the pin when a setting changes, I was wondering if constantly checking and setting pins would have a big negative impact on the hardware?</p>

<p>Would checking a pin's current state (digitalRead or other method) before setting the pin improve anything?</p>
"
"<p>It does not hurt the Arduino to set an output pin to high if it was already set to high.  If you are concerned about performance, it is more efficient to just set the output pin compared to reading the pin and then setting it only if it's different</p>
"
"<p>Try this:</p>

<pre><code>long* lRaceStartTime = RaceHandler.lRaceStartTime;
long lRaceElapsedTime = micros() - *lRaceStartTime;
</code></pre>

<p>You assigned the pointer to lRaceStartTime on the first line, but on the second line you are subtracting the pointer from <code>micros()</code> which returns an <code>unsigned long</code>.  You need to dereference the pointer before subtracting. Also you might consider making all your longs <code>unsigned</code> to match the return type of <code>micros()</code> <a href=""http://arduino.cc/en/reference/micros"" rel=""nofollow"">http://arduino.cc/en/reference/micros</a></p>
"
"<p>If powering the Arduino (Mega) through the USB port, is a voltage of 5.19VDC acceptable?</p>
"
"<p>That's the approximate expected voltage. The Arduino devices are typically powered at 5V, but the chips themselves are rated to work at values lower and higher than 5V.</p>
"
"<p>I had this exact same problem.  It turned out that my atmega328p had the wrong fuses.  I am not sure how to solve the problem using the default ardiuino ide, however I was able to plug my ArduinoISP into a linux machine (just plug in the usb) and correctly profram the fuses on a slave atmega328p to solve the problem:</p>

<p>The guide here gets you started, however it missing some of the fuses:
<a href=""http://heliosoph.mit-links.info/arduinoisp-reading-writing-fuses-atmega328p/"" rel=""nofollow"">http://heliosoph.mit-links.info/arduinoisp-reading-writing-fuses-atmega328p/</a></p>

<p>The full command to set the default fuses is something like this:</p>

<pre><code>avrdude -P /dev/ttyACM0 -b 19200 -c arduino -p m328p -U lfuse:w:0xFF:m -U hfuse:w:0xDE:m -U efuse:w:0x05:m
</code></pre>
"
"<p>In case anyone comes looking for an answer to this question, here is my solution:</p>

<p>I started with the excellent library by jeelabs (link: <a href=""https://github.com/jcw/rtclib"" rel=""nofollow"">https://github.com/jcw/rtclib</a>)</p>

<p>To create my new library, I changed a few of the register addresses, and added the few functions that I wanted it to do (set alarm, create an ordinal date, manually adjust the time with user input)</p>

<p>I posted my code to a Git project: <a href=""https://github.com/crako1t/MCP7940-library-for-logger.git"" rel=""nofollow"">https://github.com/crako1t/MCP7940-library-for-logger.git</a></p>
"
"<p>I have just spotted this question because I had a similar issue: the while condition reading Serial data is blocking.</p>

<p>I've rewritten the parsing part a little bit, which you can see <a href=""http://arduino.stackexchange.com/questions/9666/how-to-avoid-blocking-while-loop-reading-serial"">here</a>.</p>

<p>This makes it smoother to run things in parallel, but it takes about the same time to accumulate a big packet of brainwave data.</p>
"
"<p>I want to make a circuit that control speed of DC fan Using Arduino PID Library to get thing at specific temperature.
<img src=""http://i.stack.imgur.com/ZoVbA.jpg"" alt=""enter image description here""></p>

<p>The circuit looks like this but can be changed, The dc fan motor connected to PWM 3 and thermistor connected with pin A0.</p>

<p>The thermistor check the temperature of a device that heated by nearby heater so fan cools the device to get the specific temperature.</p>

<p>Case 1</p>

<p>When Heater not running, the thermistor value in Serial monitor 0-1023, When fan not running it gives 1023 and when fan runs at full speed it gives about 0.</p>

<p>Case 2</p>

<p>But when heater is running the values of thermistor has been changed and when fan not running it gives 1023 and when fan runs at full speed it gives about 500.</p>

<p>I want to set a point 650 from thermistor value(INPUT Value), and fan speed have to adjust using pid so temperature adjusted and the thermistor gives 650 value. </p>

<p>Sample PID code</p>

<pre><code> #include &lt;PID_v1.h&gt;
//Define Variables we'll be connecting to double Setpoint, Input, Output;
//Define the aggressive and conservative Tuning Parameters
double aggKp=4, aggKi=0.2, aggKd=1;
double consKp=1, consKi=0.05, consKd=0.25;
//Specify the links and initial tuning parameters
PID myPID(&amp;Input, &amp;Output, &amp;Setpoint, consKp, consKi, consKd, DIRECT);
void setup()
{
  Serial.begin(115200);
  //initialize the variables we're linked to
  Input = map(analogRead(0), 0, 1023, 255, 0);
  Setpoint = 650;
  myPID.SetOutputLimits(0, 255);
  //turn the PID on
  myPID.SetMode(AUTOMATIC);
}
void loop()
{
  int sensorValue = analogRead(0);
  Input = map(analogRead(0), 0, 1023, 255, 0);
    double gap = abs(Setpoint-Input); //distance away from setpoint
  if(gap&lt;10)
  {  //we're close to setpoint, use conservative tuning parameters
    myPID.SetTunings(consKp, consKi, consKd);
  }
  else
  {
     //we're far from setpoint, use aggressive tuning parameters
     myPID.SetTunings(aggKp, aggKi, aggKd);
  }
  myPID.Compute();
  analogWrite(3,Output);
  Serial.println(sensorValue);
}
</code></pre>

<p>What changes have to done in code so we can set point from input values?
And
Please help me so this code works for me.</p>
"
"<p>Yes, the ATMEGA328 processor will work without any problem, in fact if you go in the power informations section on the datasheet, you will find that the processor can run from a little less of 3V to a maximum of 5.5V.</p>

<p>Just be careful, because <em>the processor</em> works at that power, but <em>the board</em> will need from 5 to 5.5V.</p>
"
"<p>clc
clear all
global value
global value1
global val5
global val6
global val7
global val8
global val9
a=arduino('COM4');
   value = zeros();
   value1 = zeros();
   val5 = zeros();
   val6 = zeros();
   val7 = zeros();
  val8 = zeros();
  val9 = zeros();
for i=1:1000</p>

<p>val1(i)=analogRead(a,0)/2; %incomming</p>

<p>val2(i)=analogRead(a,1)/2; %heater</p>

<p>val3(i)=analogRead(a,2)/2;   %heat sink</p>

<p>val4(i)=analogRead(a,5)/2; %atmsphr</p>

<p>val8(i)=analogRead(a,6)/2; %pressure</p>

<p>val9(i)=analogRead(a,7)/2; %pressure</p>

<p>val(i)=analogRead(a,0)/2;</p>

<p>value(i)= (val1(i)+val4(i)+val3(i))/3;</p>

<p>value1(i) =(val8(i)-val9(i)); %pressure</p>

<p>val5(i)=analogRead(a,0)/2 %incoming</p>

<p>val6(i)=analogRead(a,4)/2 %outgoing</p>

<p>val7(i) = value(i)-val6(i)
    plot(value, 'r');
    title('heat sink temprature');</p>

<pre><code>hold on

plot(val5, 'k');

title('incoming air temprature');
plot(val6, 'g');

title('outgoing air temprature');

 plot(val4, 'k');
 title('atmospheric temperature');

plot(val7,  'c');
title('change in temprature');

pause(6)

figure
plot(value1,  'r');
title('change in pressure'); 

pause(6)
</code></pre>

<p>end</p>
"
"<p>Please, take a look at Ken Shirrif's  <a href=""https://github.com/shirriff/Arduino-IRremote"" rel=""nofollow"">IRRemote</a> library, as it is what you need. I used it in some project and worked better than other solutions that I coded.</p>
"
"<p>The 5.19V you see, I guess you expect 5.00V, is a combination of power supply tolerance and the tolerance of your voltmeter. </p>

<p>Your voltmeter also has some error, we tend to forget that sometimes.</p>
"
"<p>I have a code with a connection to serial port:</p>

<pre><code>// Set baud rate
UBRR0H = UBRRH_VALUE;
UBRR0L = UBRRL_VALUE;
// Disable USART rate doubler (arduino bootloader leaves it enabled...)
UCSR0A &amp;= ~(1 &lt;&lt; U2X0);
// Set async, no parity, 1 stop, 9bit
UCSR0C = (0&lt;&lt;UMSEL01)|(0&lt;&lt;UMSEL00)|(0&lt;&lt;UPM01)|(0&lt;&lt;UPM00)|(0&lt;&lt;USBS0)|(1&lt;&lt;UCSZ01)|(1&lt;&lt;UCSZ00);
UCSR0B |= (1&lt;&lt;UCSZ02); // 9bit
// Enable rx/tx
UCSR0B |= (1&lt;&lt;RXEN0)|(1&lt;&lt;TXEN0);
</code></pre>

<p>I see the comments but I want to know exactly what does these chunks means. Is there any complete documentation about these symbols?</p>
"
"<p>Take a look in the datasheet under the ""20. USART0"" section: </p>

<p><a href=""http://www.atmel.com/images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet_Complete.pdf"" rel=""nofollow"">http://www.atmel.com/images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet_Complete.pdf</a></p>

<p>I will list the names of the registers, what they are called, and then what your code is doing specifically:</p>

<ul>
<li>UBRR0H and UBRR0L together form the baud rate divider.  Your program probably uses F_CPU and <code>&lt;util/setbaud.h&gt;</code> to calculate a divider and set the baud rate.  For more information see Table 20-12.</li>
<li>UCSR0A  ""USART Control and Status Register n A""  --  This line is enabling the U2X0 which doubles the transmission speed</li>
<li>UCSR0C  ""USART Control and Status Register n C"" --  This line is enabling the UCSZ01 and UCSZ00 bits to set parity check to ""Enabled, Odd Parity"".  See Table 20-9.  This line has extra information, all the statements with 0&lt;&lt; actually do nothing.</li>
<li>USCR0B "" USART Control and Status Register n B"" -- This line is setting the UCSZ02 bit which is described here: ""The UCSZn2 bits combined with the UCSZn1:0 bit in UCSRnC sets the number of data bits (Character SiZe) in
a frame the Receiver and Transmitter use. ""  This basically allows you to select 9 bit wide serial if you would like (8 bit is more common)</li>
<li>The final USCR0B line enables tx and rx</li>
</ul>
"
"<p>Wireless doesn't necessarily mean it's WiFi.
You should get an XBee module that explicitly states that it's a WiFi module.</p>

<p>For a cheaper alternative you can check ESP8266 WiFi modules, which you can get for $5.</p>
"
"<p>My question is similar to this one: <a href=""http://arduino.stackexchange.com/questions/3892/motor-shield-and-wireless-transceiver-compete-for-same-pins"">Motor shield and wireless transceiver compete for same pins</a>
But not exactly the same!</p>

<p>I would like to know if the solution is as practical, though.</p>

<p>I have an Arduino Mega 2560 R3, with an Arduino Motor shield plugged into it. Now I want to use the Adafruit CC3000 WiFi shield. It plugs in fine, but when reading the specifications, it wants to use pins 13, 12, 11 which are also used by the Motor shield. I also want to use pin 10 as a servo is plugged into it. This is all on a robot so I don't have space to wire the shield separately through a breadboard or similar. </p>

<p>It should perhaps also be noted that I have the motor shield on top of the wifi shield so that the wifi shield can use the ICSP ports which the motor shield doesn't have, therefore any redirecting of pins on the CC3000 will mean that the motor shield pins will also be affected unless I redirect them too, and at that point I feel like it would be all a bit of a mess.</p>

<p>The solution to the other question was indeed to redirect the relevant pins to other free pins on the micro-controller board. However, I noticed that the Adafruit shield has a second row of connector holes next to the main pin holes. In the <a href=""https://learn.adafruit.com/downloads/pdf/adafruit-cc3000-wifi.pdf"" rel=""nofollow"">shield documentation</a> I found, I didn't find any specific reference to these parts and in what situations they could be used, but maybe this is one of them. </p>

<p>My concern with using these is that (as you can see in the second image below, ignoring the coin!), the ports are wired together in the board. Does this mean that it won't make any difference which I use; if I connect a second row of pins/connectors to these points will it simply transmit the same data down both sides? I don't know enough about how electronics work at that level to understand the consequences.</p>

<p>So really my question is: can I use the outside row of ports for my motor shield and the inside row for the wifi shield? </p>

<p><img src=""http://i.stack.imgur.com/YSc44.jpg"" alt=""Adafruit WiFi Shield""></p>

<p><img src=""http://i.stack.imgur.com/TpAAY.jpg"" alt=""Underside of shield""></p>

<p><strong>EDIT:</strong> </p>

<p>So I've spent until now on the Adafruit forums trying to get some help with this and I still am not all the way there... maybe at this point someone here can cast fresh eyes over my problem.</p>

<p>The Adafruit CC3000 uses both the dedicated ICSP pins and pins 3, 11-13 to transmit the same data. The reason for this is to do with compatibility between different Arduino boards and their versions. E.g. apparently the Uno uses those pins whilst the mega uses some of the pins in the 50s range. I'm not sure what to make of this as the Uno and most of the boards seem to have the ICSP pins, so if they're not used for this purpose then what's the point of connecting to them? Anyway. </p>

<p>As it was explained to me, even if the board can use the ICSP pins to communicate with the microcontroller, it is still sending data via the other pins. So the main pins are essentially useless at this point. To make them useful again, the idea is that you sever the wires that are sending the data through them (often referred to as trace wires). This means that only the ISCP ones will be active for what they are needed, and the main pins will be free for other uses. This is what I ended up doing to my board for pins 11-13, and then for pin 3 I cut the trace wire and wired up the connection to pin 2 as these can both be used for an IRQ (interrupt request) on the Mega and I need pin 3 for the motor shield. The lighting on these pictures isn't the best, but you can see what I've done (the lower part of the second image shows where I made the cuts and the top image shows the wire connection):
<img src=""http://i.stack.imgur.com/p88FG.jpg"" alt=""Top view"">
<img src=""http://i.stack.imgur.com/HdtVH.jpg"" alt=""Underside view""></p>

<p>After doing that I have been testing the shield connected to both my Mega and my Uno and they both produce the same results. This is using the Adafruit-created library called <code>Adafruit_CC3000_Library</code>. It starts the initialisation, then whilst it's trying to run the code it gets stuck. I traced the problem to a while(1) loop of which you can only exit by meeting a condition which is never met in my case: <code>if (*pucReceivedData == HCI_TYPE_EVNT)</code>. This may be because <code>pucReceivedData</code> is not initialised properly, but I don't know why and whether it has to do with my modifications. This happens in the <code>hci_event_handler</code> method of <code>evnt_handler.cpp</code>. This is  through the main file and <code>wlan.cpp</code> so I won't write it here as it is simple enough to follow. </p>

<p>It should also be noted that this shield doesn't work properly with the later versions of the arduino IDE (1.5+) so I had to reinstall 1.0.6. To be honest, I got the same problem on both versions so who knows.</p>

<p>I realise that this is a very specific problem, but I figure that this may leave someone with a lot fewer issues in the future. If anyone has any bright ideas, even if just for testing then I would be grateful.</p>
"
"<p>When you connect the USB, you also connect the ground of the computer to he arduino board. And then when the external power supply is connected to the arduino board the negative pin or the ground pin coming from the external power supply is connected to the ground pin of the USB. Thus the external power supply and the PC share the same ground.</p>
"
"<p>I would like to control 2 motors with the Arduino Uno board, which provides only two interrupt pins on digital 2 and 3.</p>

<p>I've set one encoder using these pins, and it works. What do you think about the following approaches:</p>

<ul>
<li>Timer Interrupt:</li>
</ul>

<p>Create a Timer Interrupt.
Connect the seconder encoder to an analog pin.
Set an analog read function in the interrupt service routine.
Change the prescaler of the ADC and increase the acquisition time. </p>

<ul>
<li>PinChangeInt</li>
</ul>

<p>Use PinChangeInt to capture the pin change interrupt rather than an external interrupt. </p>

<blockquote>
  <p>This should allow you to use almost any I/O pins on the Uno for the
  encoder.</p>
  
  <p>as Ignacio Vazquez-Abrams suggested <a href=""http://arduino.stackexchange.com/questions/4801/rotary-encoder-on-uno-and-interrupts-issue"">here</a></p>
</blockquote>
"
"<p>It is very possible. use a separate interrupt pin for Phase A of both motors, then read phase B from a non interrupt pin in the interrupt handler.
<a href=""http://www.spiked3.com/?p=5501"" rel=""nofollow"">http://www.spiked3.com/?p=5501</a></p>
"
"<p>My Arduino Uno is running out of memory to support my script (yes, I've tried several ways of optimize it already: PROGMEM, EEPROM, no Strings, and so on), so I would like to upload my script to my <a href=""http://wiring.org.co/hardware/"" rel=""nofollow"">Wiring S</a> board. </p>

<p>However, instead of ""porting"" all libraries to Wiring, I would like to compile my script in Arduino IDE and upload it to my Wiring S. It used to be ""easy"" in Arduino v.1.0.x. because somwhere I got a Wiring folder (containing, among other things, a boards.txt file) and copied it to Arduino's <code>hardware</code> folder getting the Wiring S board listed in Arduino IDE. </p>

<p>Since Arduino 1.5 the <a href=""https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5---3rd-party-Hardware-specification"" rel=""nofollow"">specification for adding other boards changed</a>. I'd say it's more complex now. I simply cannot understand most of the new specification (yes, I'm new into electronics), so I haven't been able to add my Wiring S board.</p>

<p>Running my script in Arduino 1.0.x doesn't seem to be an option, since it throws lots of errors (although the script compiles in Arduino 1.6.2).</p>

<p>Do you have any experience adding other boards (like Wiring S) to Arduino IDE? Could you please give me some hint?</p>
"
"<p>did you see this video ? : <a href=""https://www.youtube.com/watch?v=I6fo3jSIFbc"" rel=""nofollow"">https://www.youtube.com/watch?v=I6fo3jSIFbc</a></p>

<p>You can control a servo motor with an androi phone.</p>
"
"<p>You can connect Android and Arduino with usb and use the easy tool App inventor 2 for android </p>

<p>Did you try this new application : <a href=""https://play.google.com/store/apps/details?id=bp.usbbridge.appinvDemo"" rel=""nofollow"">https://play.google.com/store/apps/details?id=bp.usbbridge.appinvDemo</a> and full version : <a href=""https://play.google.com/store/apps/details?id=bp.usbbridge.appinv"" rel=""nofollow"">https://play.google.com/store/apps/details?id=bp.usbbridge.appinv</a></p>

<p>Find Videos about Explications : USB OTG Bridge Serial UART for APP Inventor 2 and ARDUBLOCK on youtube</p>
"
"<p>You can connect Android and Arduino with usb and use the easy tool App inventor 2 for android </p>

<p>Did you try this new application : <a href=""https://play.google.com/store/apps/details?id=bp.usbbridge.appinvDemo"" rel=""nofollow"">https://play.google.com/store/apps/details?id=bp.usbbridge.appinvDemo</a> and full version : <a href=""https://play.google.com/store/apps/details?id=bp.usbbridge.appinv"" rel=""nofollow"">https://play.google.com/store/apps/details?id=bp.usbbridge.appinv</a></p>

<p>Find Videos about Explications : USB OTG Bridge Serial UART for APP Inventor 2 and ARDUBLOCK on youtube</p>
"
"<p>I have an Arduino project that has 15 different output pins set.  Some are currently attached to devices and others are not.  Will testing my program cause a problem / damage if it sets pints to HIGH that do not have anything connected to them?</p>
"
"<p>You could use: u(s)art, i²c or spi
You should check this post for information on these protocols <a href=""http://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th"">http://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th</a></p>

<p>Soms quick googling gave me this:
SPI : mainly for high data rates ,approx 25MHz clock
but only bus has to be on same voltage level, single master(can be done thru S/W), data arbitration not possible
I2C: mainly for control and low data transfer..(limited by bus capacitance etc..)
but can be interfaced to diff voltage levels and multimaster bus enviornment,inbuilt arbitration etc...
UART: single P2P comm, 115kbps max</p>

<p><a href=""http://www.edaboard.com/thread53139.html"" rel=""nofollow"">http://www.edaboard.com/thread53139.html</a></p>

<p>I don't fully agree with it. You can send via uart to multiple devices, but then you have to handel the adressing in software. But other than that, uart is very easy to debug as arduinos often have an USB connection.</p>

<p>""I²C is somewhat complicated at the physical level, but all that complication is handled by the hardware (the TWI interface of the AVR chips). At the user level, it may be the simplest to use"". I don't yet have a lot of experience with this protocol, but if you want to use it check out the other answer</p>

<p>SPI would be a fair shot as it does enable master with multiple slaves in it's standard. </p>

<p>Summary:
All protocols have different pro's and con's. It's not really up to us to choose one for you. And you should look them up and learn about them by yourself.
Then try to choose which one applies most to your needs, and get started with that protocol. They are well documented and if you really can't get out of it, you can post another question ;D</p>
"
"<p>Nope, you should be just fine.</p>

<p>Having a pin set to any state while unplugged will not cause any problems with your microcontroller.</p>
"
"<p>This would differ per device/reader.
Currently, I'm in a project with a TRF7970a RFID reader. I've seen it it's datasheet that it does have options to send RAW values as it does not support every protocol (NXP has patent on one?) thus the chip doesn,t parse it, but can send it to the mcu completely.
In short, yes this is possible.
But using a reader that is compliant with your protocol might supress your development cost/time</p>
"
"<p>I am trying to use the millis() function to turn on a pin for a specified interval then turn off and turn on a second pin. It is intended to power a relay and offer a visual cue to when the cycle is over. Several of these need to eventually be running, most likely (3) so using delay won't work. I plan to add additional ""button pins"" for each input. The LED lights up but gets stuck in the loop and doesn't cycle out. It seemed like a simple program but I can't crack it for some reason. Is there a much better method to do this? There will be two optical sensors and one pushbutton switch attached to an air driven crushing machine. The two optical sensors will be used only as time indicators with LEDs and the pushbutton will power the relay. Forgive my shortcomings as a programmer, I am learning the programming language still. </p>

<pre><code>const int ledPin =  2;      // the number of the LED pin
const int buttonPin = 3;    // Button pin number
// Variables will change:
long previousMillis = 0;        // will store last time LED was updated
int buttonState = 0;            // Checks if button is pushed
int buttonPush = 0;             // Toggles between 0 to hold state
long interval = 1000;           // interval at which to blink (milliseconds)

void setup() {
// set the digital pin as output:
   pinMode(ledPin, OUTPUT);      
   pinMode(buttonPin, INPUT);
}
void loop()
{
   unsigned long currentMillis = millis();
   buttonState = digitalRead(buttonPin);
   if (buttonState == HIGH) {
      buttonPush = 1;
      if (buttonPush == 1){
         if(currentMillis - previousMillis &gt; interval) {
            previousMillis = millis();   
            digitalWrite(ledPin, HIGH);
         }
         else {
            buttonPush = 0;     
         }  
      }
      else {
         digitalWrite(ledPin, LOW); 
      }
   } 
}
</code></pre>

<p>Edit: Thank you for looking over the code, you guys are awesome. There were a couple questions regarding clarity of the final application so I will elaborate. I am going to attempt to clean it up. I had a feeling something was wrong with:</p>

<pre><code>if (buttonState == HIGH) {
buttonPush = 1;
</code></pre>

<p>but I couldn't put my finger on it. </p>

<p>Eventually the system will function with two heating elements to soften plastic, which I will either add an optical sensor to since it will probably get triggered a few hundred times a day, or just a pushbutton to start a timer so the plastic isn't left in too long. A green LED will be illuminated to indicate the system is on. When the plastic object is placed in the heating element it triggers the optical sensor (or the operator pushes a pushbutton to start the timer) that will then illuminate a red LED to indicate heating. When the specified time interval has expired, the LED will revert back to green to show the cycle is complete. The plastic object is then removed and placed in a pneumatic crushing device with a green system on LED. The operator then pushes a pushbutton which turns on a red indicator LED and a relay to power the solenoid on the pneumatic press for a specified amount of time to allow the plastic to cool and crystalize. When that interval has expired, the system will revert back to illuminating the greed LED and will end power to the relay allowing the press to release.</p>

<p>The pneumatic press and the heating system works awesome, I just need better control of the time intervals used. The end result needs to be consistent.</p>

<p>I am going to try all suggestions and will post what ended up working if I reach that point or find an answer that functions. Thank you again.</p>
"
"<p>I was having the same problem. installed the latest drivers, I'm using yosemite, installed the Arduino IDE, and tried the board in windows 7 and it worked in windows, so board and cable are working.</p>

<p>In mac OS 10.10 in system report now they show as USB 2.0 Serial in arduino IDE it appears the port now (only after I used the SUDO command that sjunnesson posted) /dev/cu.wchusbserialalpha1310 </p>

<p>so, use the sudo command if you are in yosemite</p>
"
"<p>Summary:</p>

<p>A fatal problem is caused by the two lines of code below.<br>
A variable is set and then the same variable is immediately tested to see if it is set.  This means that the IF test always passes and the ELSE never happens. 
As the LED is cleared only when the else occurs, the LED stays lit.</p>

<p>Code: </p>

<blockquote>
<pre><code>  buttonPush = 1;  
  if (buttonPush == 1){ ...
</code></pre>
</blockquote>

<p>When the button is pressed you set buttonPush and then immediately test to see if it is set.   </p>

<p>As it always is set, the LED never gets turned off as the ""else"" condition is never met.  </p>

<p>Even when that is fixed you have other issues.<br>
I suggest that ""expanding"" the code along the lines I have shown in (3) below will help you immensely with visualising what your code does.  </p>

<p>There are a large number of editors which handle this task in various ways, but just plain tabbing and white space with a basic editor helps muchly. </p>

<hr>

<p>It seems almost certain that your code will NOT do what you intend when it does work ""properly"", but there are several issues below that need addressing (one fatal, others less so) - see ""ISSUES"" below. </p>

<p>Apart from those issues, it's not 100% clear how this is intended to be used.<br>
Options include:  </p>

<ul>
<li><p>Switch is pressed and released quickly (say 100 mS) - LED lights for one second and then goes out.</p></li>
<li><p>Switch is pressed and held - LED lights for one second then turns off even when switch is held on. </p></li>
<li><p>Other variants are possible. </p></li>
</ul>

<p>At present it will not do any of these.   </p>

<hr>

<h2>ISSUES:</h2>

<p>(1) You have assigned  </p>

<blockquote>
  <p>long previousMillis = 0;</p>
</blockquote>

<p>This should be </p>

<blockquote>
  <p>unsigned long previousMillis = 0;</p>
</blockquote>

<p>Mixing the two types gives an uncertain result. At best, an error will occur when the value returned by millis() exceeds the length of a ""long"" data type and when types are mixed there is no guarantee that the result will be valid. </p>

<hr>

<p>(2) I have not checked it, but I'd be wary of the line</p>

<blockquote>
  <p>if(currentMillis - previousMillis > interval)</p>
</blockquote>

<p>as it depend on operator precedence of the ""-"" being implemented prior to the "">"" comparison.<br>
ie this could potentially evaluate as either  </p>

<p>"" (A-B) > C "" .... which is what you intend,<br>
or<br>
"" A - (B > C) "" .... which, while it is not what is intended, does have a valid if not useful result.  </p>

<p>You can rely on operator precedence if you have confidence in yourself and the system or make it explicit as in eg  </p>

<blockquote>
  <p>if( (currentMillis - previousMillis) > interval)</p>
</blockquote>

<hr>

<p><strong>Making things easier for yourself:</strong></p>

<p>This has been edited to match my main conclusion which was already covered above (the problem was not nesting but a test that can never fail - as covered above) but the formatting  comments are relevant.</p>

<p>Your code is written in a standard (or usual) manner. Some are able to handle such without problem, but I (and many others) find such layout hard to read and, importantly, easy to bury errors in. The following is overdone - I used existing tabs and expanded it in Word :-) - but to me the following makes it immensely more readable. Layout and style are a matter of personal preference, and there are many opinions re what is ""best"", but something which allows ease of visualisation of program structure is liable to be useful.</p>

<p>The two adjacent lines</p>

<blockquote>
<pre><code>  buttonPush = 1;  
  if (buttonPush == 1){ ...
</code></pre>
</blockquote>

<p>are logically grouped together when indented like this at make it clearer that the ""set then test""   arrangement can never fail so the subsequent ""else"" where the LED is turned off is never implemented. So the LED must stay on. </p>

<p><img src=""http://i.stack.imgur.com/vPdVX.jpg"" alt=""enter image description here""></p>

<p>buttonPush = 0; is bolded for unrelated reasons.   </p>
"
"<p>my friend, i have some problems with version 2.0 trying to read some cards. i think that the problem when  u cant read the card is this version . i have both version 1.0 and 2.0, version 1.0 detect all card type, and 2.0 some not. 
for me is a big problem because, here in argentina i only found version 2.0. maybe change on library some.</p>
"
"<p>The reason why your slide/microarray microdispenser continually oscillates about a point rather than dispense the fluid containing your cells/DNA sample specifically at a particular specified/designated point on your slide/microarray is due to your code below:</p>

<pre><code>if(digitalRead(encoderI) == digitalRead(encoderQ)){
     //dispenser is moving to the left
     ActualHeadPosition++;
   }

   else {
     //dispenser is moving to the right
     ActualHeadPosition--;
}
</code></pre>

<p>which tells the Arduino to actuate the motor regardless of the values stored in the vars encoderI &amp; encoderQ.</p>
"
"<p>Some code is shown below to illustrate a method for treating three events independently.</p>

<p>This code might not be completely applicable as-is, because the problem description isn't clear about what should happen when a button is pressed and about whether other events to be added to the code are like the one shown there now.  However, if you understand how it works you probably can adjust it to meet any special requirements of your application.</p>

<p>During each pass through the <code>loop()</code> routine, the code does the following for each type of event:</p>

<blockquote>
  <p>If the event is not currently active (as denoted by <code>states[i] &lt; debounced</code>), the code checks whether the event's button has been pressed (or, if its sensor has turned on).  If so, the code increments a debounce counter.  If the event's counter gets up to <code>debounced</code>, then the output for the event is turned on, and the event's end-time is stored in an array entry.</p>
  
  <p>If the event <em>is</em> currently active (as denoted by <code>states[i] &gt;= debounced</code>), the code tests if the event's end-time has arrived; if so, it turns off the event's output bit and resets its state to 0.</p>
</blockquote>

<p>The last statement in <code>loop()</code> busy-waits until <code>milliseconds()</code> returns a different value than before.  This is done so that switch-debouncing samples are taken at least a millisecond apart.  If your inputs don't need debouncing, you can remove debounce code .</p>

<pre><code>/* Process three asynchronous activities: Upon a given input going
true, activate its associated output(s) for specified lengths of time.
*/

enum { nkinds=3, debounced=5 }; // # of activity kinds;  debounce-criterion
const byte outPins[nkinds] = {2, 4, 6}; // Output pin numbers
const byte inPins[nkinds]  = {3, 5, 7}; // Input pin numbers
const unsigned int actLens[nkinds] = {345, 678, 323}; // Activity lengths, ms
byte states[nkinds] = {0, 0, 0};
unsigned long actEnds[nkinds] = {0, 0, 0};

void setup() {
// Set input/output modes of pins
  for (byte i=0; i&lt;nkinds; ++i) {
    pinMode(outPins[i], OUTPUT);
    pinMode(inPins[i], INPUT);
  }
}

// Once per millisecond, for each kind of activity
// check for new beginning or deal with ongoing action
void loop() {
  unsigned long now = millis();
  for (byte i=0; i&lt;nkinds; ++i) {
    if (states[i] &lt; debounced) {  // Is activity off?
      // It's off, look for a turnon
      if (digitalRead(inPins[i])) {
        ++states[i];        // Button is closed at the moment
        // See if button has been debounced
        if (states[i] &gt;= debounced) { // If so, start its action
          digitalWrite(outPins[i], HIGH);
          actEnds[i] = now + actLens[i];
        }
      }
      else {
        states[i] = 0;      // Button is not closed at moment
      }
    }
    else { // It's on, see if end-time has arrived
      if (now &gt;= actEnds[i]) {
        digitalWrite(outPins[i], LOW); // Clear output when done
        states[i] = 0;        // Return to button-seeking state
      }
    }
  }
  while (now == millis()) {};       // Finish current millisecond
}
</code></pre>

<p>The code above compiles ok in the Arduino IDE but I haven't tested it on an Arduino device.</p>

<p>Note, larger systems with numerous events will use priority queues to implement lower-overhead versions of the same ideas.</p>
"
"<p>I'm connect arduino to my PC through serial monitor. Very common situation:</p>

<pre><code>Serial.begin(9600);
delay(100);
Serial.print(""Hello, World!"");
</code></pre>

<p>But I always get an <code>¤ello, World!</code>. How can I get the first symbol straight? I've tried on both unix &amp; windows, mega &amp; uno. I've also tried <code>println</code>, but with no happiness</p>
"
"<p>I am using two XBee Pro S2B modules. One (Router) connected to the laptop via a UART cable. The other (Coordinator) connected to an Arduino Mega with the sketch below.  All I need it to do is turn a LED on and off and display the status in the IDE serial monitor.  I am using Arduino IDE (v1.6.0).</p>

<p>Arduino sketch:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

SoftwareSerial xbee (2,3);

int myData = 0;
int ledPin = 13;

void setup()
{
    Serial.begin(9600);
    xbee.begin(Serial);

    pinMode(ledPin, OUTPUT);
}

void loop()
{
    if (Serial.available())
    {
         int myData = Serial.read();

         if(myData == '1')
         {
             digitalWrite(ledPin,HIGH);
             Serial.write(myData, DEC);
         }
         if(myData == '2')
         {
             digitalWrite(ledPin,LOW);
             Serial.write(myData, DEC);
         }
     }
 }
</code></pre>

<p>Where did I go wrong?</p>
"
"<blockquote>
  <p>Would checking a pin's current state (digitalRead or other method)
  before setting the pin improve anything?</p>
</blockquote>

<p>So instead of:</p>

<pre><code>SetPin(OUTPUTPIN,true);
</code></pre>

<p>You want to do:</p>

<pre><code>if(!PinIsSet(OUTPUTPIN)){
 SetPin(OUTPUTPIN,true):
}
</code></pre>

<p>To avoid writing to a pin (making it high) when it's already high/enabled?</p>

<p>Well doing so will waste a little amount of your programs' speed (it'll need to check each pin before setting it). But when you set a pin, when it's already high, it simply doesn't even change. And even then it's not required to check it first, Microcontrollers are basically made for this.</p>
"
"<p>Had some start up difficulties. But updated the YUN and IDE to the latest version. </p>

<p>Using  <code>* ""/arduino/digital/13/1""</code> works as supposed (turns on the LED) - it's just a bit slow. But I can't see why the analogs shouldn't work. I tried to connect it to 5V or GND, so it wasn't floating. But it still returns no reading.</p>

<p>Don't know if this is the cause. But when I connect to my router I can't the the YUN in the list of DHCP Clients...</p>
"
"<p>I'll have to chime in with the others and say ""It depends."" The Uno, or more precisely its Atmega328p microcontroller, is rather memory limited, especially the RAM memory needed for data buffers, stack-frames, and tables such as the character-generator for the LCD. That last one can usually be kept in program memory, but note that if you're having to plan memory assignment before you even start the project, it's a pretty good sign that you should consider something more capable.</p>

<p>An Arduino Mega 2560 is about twice the price of the Uno (in the US, US$50 vs. US$25) but gives you 4 times the RAM memory, 8 times the flash (program) memory, and a bunch more (sorry to get all technical :) I/O pins. Of these, the RAM is likely to be your most stringent limit with the UNO.</p>

<p>I keep one Arduino Mega around for prototyping or when don't want to build another board for an experiment, and a handful of AtMega328p chips to build into ""Arduin-ettes"" for my more permanent gadgets. Most of my toys will fit on the '328 chip but it's awfully nice to be able to shove a ton of code, libraries, debugging statements, logging buffers and what have you, into the larger processor without having to think about what will fit. Or, what's worse, if I cause a stack crash by stuffing all of that into too-little memory, I could waste a lot of time debugging a presumed coding error when it was really an out-of-memory problem.</p>
"
"<p>The direct answer to your first question (LED gets stuck) after formatting and summarizing a section of your code:</p>

<pre><code>  buttonPush = 1;
  if (buttonPush == 1){
     ...
  }
  else {
     digitalWrite(ledPin, LOW); 
  }
</code></pre>

<p>is that there's a logic error. You can see that the else clause, turning off the LED, will never be executed because buttonPush is always 1 before you enter this section. I think this is the point @RussellMcMahon was trying to make.</p>

<p>The answer to your second question, needing several of these running at once, is: Get the first one to work first. Then simplify it as much as you can. Then you can choose between using polling loop (repeatedly reading the clock and deciding whether it's time to do something) or setting interrupts (making the clock interrupt your main program to run the routine that does the ""something"").</p>
"
"

<p>I would like to control 2 motors using Timer2 @ 200Hz. The frequency of the timer is printed in the main loop every second. I'm using an Arduino Uno with two interrupt used for the encoders connected to pin 2 and 3.</p>

<p><strong>The problem</strong></p>

<p>The timer runs at 200Hz as expected but the motors are shaking even if I ask them not to spin. The Timer2 is not required by the servo library. </p>

<p>How can I solve this problem? How do you handle Timer interrupts and servo routines?</p>

<p><strong>CODE</strong></p>

<pre class=""lang-C++ prettyprint-override""><code>#include &lt;Servo.h&gt;
Servo motorDx, motorSx;
[...]

void setup()
{
  // Setup Timer2 @ 200Hz
  cli(); // Stops interrupts

  TCCR2A = 0;// set entire TCCR1A register to 0
  TCCR2B = 0;// same for TCCR1B

  // set compare match register for 200 Hz increments
  OCR2A = 77;// = (16*10^6) / (200*1024) - 1 -&gt; 200 Hz

  // turn on CTC mode
  TCCR2A |= (1 &lt;&lt; WGM21);
  // Set CS10 and CS12 bits for 1024 prescaler
  TCCR2B |= (1 &lt;&lt; CS20) | (1 &lt;&lt; CS21) | (1 &lt;&lt; CS22);  
  // enable timer compare interrupt
  TIMSK2 |= (1 &lt;&lt; OCIE2A);

  sei(); //enable global interrupts

  attachInterrupt(0, MSencVel, RISING);
  attachInterrupt(1, MDencoder, RISING);
  motorDx.attach(10, 1000, 2000); 
  motorSx.attach(11, 1000, 2000); 
}

void loop()
{
  if(micros()-tOld &gt;= 50000)
  {
    tOld = micros();
    count += 1;
    if(count &gt;= 20) // Runs @ 1 Hz
    {
      count = 0;
      serialRoutine();
      // prints number of ISR/sec
      Serial.println(contIsr)     
      contIsr=0;
    }
  }
}

ISR(TIMER2_COMPA_vect)
{
  //sendValuesToMotors();
  motorDX.write(90);
  contIsr++;
}
</code></pre>
"
"<p>I'd have to be pretty quick to connect my serial monitor to see immediate terminal output from my program, if that output uses the same USB I used to load the program. You can test this by resetting the Arduino so it will repeat the output and see if you get a clear message this time. So I leave a couple of seconds' delay in the code to let the slow human catch up. Most of my devices announce their name and code-version on the serial I/O and flash a quick ""I'm here"" on the LED (if I chose to attach one) when they first wake up:</p>

<pre><code>const char IdString[] = ""Hello.cpp: $Revision: 1.3 $"";

void setup(void)
{
   Serial.begin(57600);            // open serial port

   // Identify to the terminal
   delay(2000);
   Serial.println(IdString);       // hello (terminal)

   // Init LED pin
   pinMode(LED_PIN, OUTPUT);
   digitalWrite(LED_PIN, LOW);

   nblink(4);                      // hello (LED)
   ...
</code></pre>
"
"<p>You have two serial connections. One for the main USB of the board and one for the XBee. </p>

<p>So you need to read from the XBee and write to the serial USB?</p>

<p>I don't know what speed you have configured for your XBee so I have set it to 9600.</p>

<p>This example reads from the XBee and writes to the Serial/USB port</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

SoftwareSerial xbee (2,3);

int myData = 0;
int ledPin = 13;

void setup()
{
    Serial.begin(9600);
    xbee.begin(9600);

    pinMode(ledPin, OUTPUT);
}

void loop()
{
    if (xbee.available())
    {

         int myData = xbee.read();

         Serial.print(""Data has arrived on the Arduino"");
         Serial.write(myData);
         Serial.println();

         if(myData == '1')
         {
             digitalWrite(ledPin,HIGH);
             Serial.write(myData);
         }
         if(myData == '2')
         {
             digitalWrite(ledPin,LOW);
             Serial.write(myData);
         }
     }
 }
</code></pre>

<p>Note: Your example also used <code>Serial.write()</code> with the wrong argument <code>DEC</code> which applies to <code>Serial.print()</code>. X-CTU and Arduino both send ascii which is also what the <code>Serial.print()</code> does. However the <code>Serial.read()</code> just reads the byte so we need to use <code>Serial.write()</code> to send the same bytes back to the other end.</p>

<p>You can also make life a bit easier by replacing <code>xbee.available()</code> with <code>Serial.available()</code>. Then use the Arduino IDE serial monitor to both send and receive. This means that you just use the one USB connection to prove the code.</p>
"
"<p>The simplest way I can think of is something like this:</p>

<pre><code>unsigned long lastPress = 0;
unsigned long stateOneTime = 2000; //runs until two seconds elapse
unsigned long stateTwoTime = 4000; //runs after state one until 4 seconds from first press
...
if(/*input is active*/) lastPress = millis();
...
if(millis() - lastPress &lt; stateOneTime){
    //set output for first state
    //active for 2 seconds
} else if (millis() - lastPress &lt; stateTwoTime){
    //set output for second state
    //active an additional 2 seconds
} else {
    //set output to the ""off"" state
}
</code></pre>

<p>Many improvments could be made, like going more of a state machine route (separating the time checks from the branches) or paramaterizing the state lengths better (durations would make more sense than total time from start, but be slightly more complicated to code).</p>

<p>I think the key to making your life easier while working on this code will be separating the input segment from the output segment. It will help keep the code easy to read and modular.</p>
"
"<p>The problem is that I need to import this code just a simple usual library.</p>
"
"<p>This question is a little related to this one: <a href=""http://arduino.stackexchange.com/questions/9702/how-to-compile-and-upload-the-specific-cpp-h-code"">How to compile and upload the specific (.cpp + .h) code?</a></p>

<p>I've installed <a href=""https://github.com/justintconroy/MdbBillValidator"" rel=""nofollow"">MdbBillValidator</a> to my arduino libraries collection. I tried both on ubuntu &amp; windows.</p>

<p>How can I include it? Default inclusion, by arduino ide, was:</p>

<pre><code>#include &lt;MdbSerial.h&gt;
#include &lt;wiring_private.h&gt;
#include &lt;MdbBillValidator.h&gt;
#include &lt;MdbMaster.h&gt;
#include &lt;Arduino.h&gt;

void loop() {

}

void setup() {

}
</code></pre>

<p>And here is error comes in:</p>

<pre><code>/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp: In function ‘void __vector_37()’:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:289:23: error: ‘TXB8’ was not declared in this scope
       UCSR1B |= (1 &lt;&lt; TXB8);
                       ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:291:24: error: ‘TXB8’ was not declared in this scope
       UCSR1B &amp;= ~(1 &lt;&lt; TXB8);
                        ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp: In function ‘void __vector_52()’:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:314:23: error: ‘TXB8’ was not declared in this scope
       UCSR2B |= (1 &lt;&lt; TXB8);
                       ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:316:24: error: ‘TXB8’ was not declared in this scope
       UCSR2B &amp;= ~(1 &lt;&lt; TXB8);
                        ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp: In function ‘void __vector_55()’:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:339:23: error: ‘TXB8’ was not declared in this scope
       UCSR3B |= (1 &lt;&lt; TXB8);
                       ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:341:24: error: ‘TXB8’ was not declared in this scope
       UCSR3B &amp;= ~(1 &lt;&lt; TXB8);
                        ^
In file included from /usr/lib/avr/include/avr/iom2560.h:38:0,
                 from /usr/lib/avr/include/avr/io.h:160,
                 from /usr/lib/avr/include/avr/pgmspace.h:88,
                 from /home/asiniy/sketchbook/libraries/MdbBillValidator/Arduino.h:8,
                 from /home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:31:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp: At global scope:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:554:135: error: expected ‘)’ before numeric constant
   MdbSerial MdbPort1(&amp;rx_buffer1, &amp;tx_buffer1, &amp;UBRR1H, &amp;UBRR1L, &amp;UCSR1A, &amp;UCSR1B, &amp;UCSR1C, &amp;UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1 UCSZ12, UCSZ11, UCSZ10, UPM11, UPM10, UMSEL11, UMSEL10);
                                                                                                                                       ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:554:189: error: no matching function for call to ‘MdbSerial::MdbSerial(ring_buffer*, ring_buffer*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, int, int, int, int, int, int, int, int, int, int, int)’
   MdbSerial MdbPort1(&amp;rx_buffer1, &amp;tx_buffer1, &amp;UBRR1H, &amp;UBRR1L, &amp;UCSR1A, &amp;UCSR1B, &amp;UCSR1C, &amp;UDR1, RXEN1, TXEN1, RXCIE1, UDRIE1, U2X1 UCSZ12, UCSZ11, UCSZ10, UPM11, UPM10, UMSEL11, UMSEL10);
                                                                                                                                                                                             ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:554:189: note: candidates are:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:352:1: note: MdbSerial::MdbSerial(ring_buffer*, ring_buffer*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, volatile uint8_t*, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t)
 MdbSerial::MdbSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
 ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:352:1: note:   candidate expects 20 arguments, 19 provided
In file included from /home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.cpp:38:0:
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.h:52:7: note: MdbSerial::MdbSerial(const MdbSerial&amp;)
 class MdbSerial
       ^
/home/asiniy/sketchbook/libraries/MdbBillValidator/MdbSerial.h:52:7: note:   candidate expects 1 argument, 19 provided
</code></pre>

<p>What I need to do to avoid this error and get the code worked?</p>
"
"<p>Could you try adding this to your program?</p>

<pre><code>#define RXB8 1
#define TXB8 0
#define UPE 2
#define OVR 3
#define FE 4
#define UDRE 5
#define RXC 7

#define FRAMING_ERROR (1&lt;&lt;FE)
#define PARITY_ERROR (1&lt;&lt;UPE)
#define DATA_OVERRUN (1&lt;&lt;OVR)
#define DATA_REGISTER_EMPTY (1&lt;&lt;UDRE)
#define RX_COMPLETE (1&lt;&lt;RXC)
</code></pre>

<p>I found someone with similar code, who had these defines and as your code seems to miss/cannot find something, this might fix it.
Though I'm not sure if these defines apply in your specific implementation. For that I should have to see the code where the error is pointing at.</p>
"
"<p>So recently I have been looking into prototyping my arduino project and there are a lot of tutorials online on how to take your Arduino and using a software such as Eagle to make a PCB layout but I was wondering how you would get the Arduino program onto that PCB. Surely in large scale circuit manufacturing they wouldn't have a usb attached so that they upload a program into each and every one of their circuits?</p>
"
"<p>why not? </p>

<p>Well ok ... they might not connect a USB to each one as there are faster ways - flyingProbe/PogoPins on a ""bed of nails""</p>

<p><a href=""http://en.wikipedia.org/wiki/In-circuit_test"">http://en.wikipedia.org/wiki/In-circuit_test</a></p>

<p><img src=""http://i.stack.imgur.com/QV9BI.jpg"" alt=""enter image description here""></p>

<p>This type of temporary connection speeds up testing &amp; pre-programming considerably. </p>

<p>Each card that is made has to go through some form of test process at the end (flying probe or manual). </p>

<p><a href=""https://learn.sparkfun.com/tutorials/electronics-assembly"">https://learn.sparkfun.com/tutorials/electronics-assembly</a></p>

<blockquote>
  <p>On boards that require programming or calibration, additional steps
  are taken to load code and verify the output.</p>
</blockquote>
"
"<p>For commercial products where very large quantities are produced, a microcontroller will be ""mask programmed"" - the (well-debugged) program will be built into the microcontroller as part of the IC production process.</p>

<p>For smaller quantities, the microcontroller may be programmed in a special fixture before being installed on the PC board.  Also, most current microcontrollers have ""In System Programming (ISP)"" capability, which typically requires a 6 - 10 pin connector on the board, and a special programmer to plug into that board.</p>

<p>I think it is highly unlikely that an Arduino-based program would be used in any commercial product.</p>
"
"<p>Actually, they generally do load a program into each and every one of their devices individually.  They can do a lot more than that as well.  Ever heard of something called JTAG?  For large circuit boards, most of the large ICs are connected to a JTAG scan chain.  Once the board is assembled, they connect a JTAG cable to the scan chain.  Special test software controls the scan chain through the JTAG cable, possibly connected to the control computer via USB.  The software can take control over the I/O pins on the ICs on the scan chain and set test patterns to check for opens or shorts.  It can also perform more complex testing in concert with external test equipment, even including temporarily loading special diagnostic firmware.  Once the test passes, the computer can then initialize ROMs, load firmware, set serial numbers, etc.  </p>

<p>This is done one board at a time.  Often, special test and/or programming jigs are built that allow boards to be connected and disconnected quickly, and usually multiple jigs are used in parallel for higher throughput.  </p>

<p>For some chips, they can be programmed before installation either with mask ROM or with a standalone programmer.  This is done when volumes are large and testing is not required, or if the devices must be programmed for the automated testing to work correctly.  </p>
"
"<p>Your issue is probably this code (and similar) in the Android MainActivity:</p>

<pre><code>x = Integer.toString(u);
Bluetooth.connectedThread.write(x);
</code></pre>

<p>Remember that you are sending <em>bytes</em>, not <a href=""http://www.asciitable.com/"" rel=""nofollow"">ascii representations</a> of them.  For example, if the variable 'u' is 9, you would be sending the value 57.  The larger problem is that if 'u' is 10 or higher, you are sending more than one byte, and the code below...</p>

<pre><code>case 'A':
    nhan=Serial.read();
    //digitalWrite(8,LOW);
    break; 
</code></pre>

<p>...only reads one byte of the number.  A better way to approach this is to always send your data in a packet - start each packet with a control or attention byte (255 is a good one), a command for your select, and as many bytes as you need for the data.  Then <em>always</em> send and read a complete packet.</p>

<h2>Arduino code:</h2>

<pre><code>//Defines make your code more readable.
#define PACKET_SIZE 3
#define CONTROL_BYTE 255
#define WHATEVER_A_MEANS 65
#define WHATEVER_B_MEANS 66

//...

void loop()
{
    byte buffer[PACKET_SIZE];

    if (Serial.available() &gt;= PACKET_SIZE)
    {
        // Read the first byte
        buffer[0] = Serial.read();
        // If it's really the start byte (255) ...
        if (buffer[0] == CONTROL_BYTE)
        {
            // ... then get the next two bytes
            for (i = 1; i &lt; PACKET_SIZE; i++) buffer[i] = Serial.read();
        }
        else
        {
            //Otherwise it isn't a good packet.
            return;
        }

        switch (buffer[1])
        {
            case WHATEVER_A_MEANS:
                nhan = buffer[2];
                break;
            case WHATEVER_B_MEANS:
                nhan1 = buffer[2];
                    break;
            //etc.
        }

        //...
</code></pre>

<h2>Android code:</h2>

<pre><code>//Class level scope. Note that these don't have to be 'letters' unless you  
//need them to be for some other reason.
public static final byte CONTROL_BYTE = (byte)255;
public static final byte WHATEVER_A_MEANS = (byte)65;
public static final byte WHATEVER_B_MEANS = (byte)66;

//...
public void doTimerTask() {
    mTimerTask = new TimerTask() {
        public void run() {
            thandler.post(new Runnable() {
                public void run() {
                    Bluetooth.connectedThread.write(CONTROL_BYTE);
                    Bluetooth.connectedThread.write(WHATEVER_A_MEANS);
                    //Note that this is a narrowing cast of u.
                    Bluetooth.connectedThread.write((byte)u);
</code></pre>

<p>If 'u' needs to hold values bigger than 8 bits (you have it declared as an int), you'll need to split it into bytes and then recombine them in the Arduino code.</p>
"
"<p>I have to use a camera to take picture in my major project. I want to use <a href=""http://i.stack.imgur.com/42CDx.jpg"" rel=""nofollow"">this</a> camera, which has AV output. Please tell me how to interface this camera with my Arduino Uno and use the data from camera and send it to my PC using a Wi-fi Module?</p>

<p>P.S. Please do not suggest me to use wireless camera because firstly they are expensive and secondly I require a board in my project anyway.</p>
"
"<p>I have this simple program:</p>

<pre><code>void loop() {
  sendInputs();
  delay(10);
}
</code></pre>

<p>the sendInput() method reads some digital inputs connected to an external switch and sends a command via serial port.</p>

<p>My question is: what is the <strong>maximum delay time</strong> to correctly read an external switch? Consider that this switch is pressed by a human like a mouse click.</p>
"
"<p>As Cominterm said, you are doing a lot of mistakes. I would use start and end bytes like: </p>

<pre><code>HEX       ASCII

31 3B  |  ""1;"" -start of the message 

3F 30  |  ""?0"" - end of message
</code></pre>

<p>And in arduino check for them.</p>

<p>Also a tip, if you read bytes i would get rid of those 'A', 'S' and so on. These are ascii codes. You can easily do a mistake and this will be pain in the ass. Send byte <code>10</code> from Android and read as byte <code>138</code> in Arduino, because in Java byte is <code>-127 : 128</code> and Arduino <code>0 : 255</code></p>

<p>I would do in hex representation, this helps in troubleshooting. For ex.: byte <code>1C</code> hex in Android is <code>1C</code> hex in Arduino.</p>

<p>Also get rid of those byte to string, int to string conversations. They add more points to mistake :) Also check if string is terminated with <code>\0</code> and it will be 2 bytes instead of 1.</p>
"
"<p>cheers Brandan :)</p>

<p>I would suggest for you to make your own programmer. Then you will know a lot about programming and so on. If you want to program a chip on pcb, you have to have output pins of ISP. Throw these pins you will pump your code to Atmega chip.</p>

<p>Software <a href=""http://khazama.com/project/programmer/"" rel=""nofollow"">Khazama</a> is ""old"" and tested one. It really works :) <a href=""http://www.atmel.com/microsite/atmel_studio6/"" rel=""nofollow"">AVR studio</a> is also good one</p>

<p>Hardware <a href=""http://www.fischl.de/usbasp/"" rel=""nofollow"">USBasp</a> There are ready pcb layouts in eagle. Building your own HW will be a bit more expensive than buying one, but if we count in experience it will be priceless :)  </p>

<p>Also you can use bootloader. Check in google there are plenty of tutorials.</p>
"
"<blockquote>
  <p>I should be able to set and use the HID profile (from the default SPP)</p>
</blockquote>

<p>Unfortunately, your assumption is incorrect. From the same documentation you quoted, the previous sentence says:</p>

<blockquote>
  <p>To use Roving Networks’ Bluetooth HID profile, you must use a special
  build of firmware, version 6.03 or later.</p>
</blockquote>

<p>Poorly phrased, this does mean that you need to have two things:</p>

<ol>
<li>A <strong>special HID</strong> firmware </li>
<li>Version 6.03 or later</li>
</ol>

<p>Your BlueSmirf Silver only complies with the second condition; it does not have the special HID firmware (also note that the Rovnix command reference does not address a specific variant of the BlueSmirf, but speaks generally about all of the variants).</p>

<p>The <strong>SPP protocol</strong> (Serial Port Profile) is used for emulating a serial cable, and functions as a substitute for the physical RS-232 connection, <strong>but cannot stack pure HID profile on top of it</strong>. In order for you do talk HID, you will need the HID firmware. </p>

<p>As a side note, the HID version comes with SPP and you can switch between the two modes interchangeably, I have been using the HID version for a while now and it works fine (including the pairing with iOS). </p>

<p>Another misfortune is that it does not appear that <em>Roving Networks</em> officially support any re-flashing of the BlueSmirf firmware, so unless you are willing to reverse the hardware, this is off the table as well.</p>
"
"<p><sup>I am a hobbyist &amp; know little about electronics.</sup></p>

<p>I am making a robot arm, like <a href=""http://www.lynxmotion.com/c-124-al5a.aspx"" rel=""nofollow"">this one</a>. For which I will need 2 stepper motors (for elbow &amp; shoulder joint) &amp; 4 simple DC motors.</p>

<p>Which means I will need to allocate a lot of pins on my board (Uno).</p>

<p>So I was just reading about I2C &amp; then eventually SPI. My question is:</p>

<ol>
<li>Is it possible to control 6 motors (or atleast 2 steppers) with I2C or SPI (assuming the motors are powered by seperate source), if so can you point me to someone's example code.</li>
<li>If not possible, how do I overcome the shortage of pins, because I have already dedicated them to many sensors.</li>
</ol>
"
"<p>Unfortunately, I have to tell you that a UNO isn't enough powerful to work with any type of camera: it hasn't got enough ram and processing power to elaborate your camera's data. (<a href=""http://www.atmel.com/devices/atmega328.aspx"" rel=""nofollow"">see atmega328P's specs</a>)</p>

<p>I'm not sure you can work with that camera, unless it is digital and has integrated RAM to keep the frames.</p>

<p>A good project which I suggest you to see is <a href=""http://www.arducam.com/"" rel=""nofollow"">arducam</a>.</p>
"
"<p>For the stepper motors, the easiest way to work with them is by using a very common <a href=""https://www.pololu.com/product/1182"" rel=""nofollow"">A4988 board</a> which is widely used with 3D printers. The controls are very easy and for them I send you <a href=""http://arduino.stackexchange.com/questions/8965/stepper-motor-controller-using-leonardo-pro-micro/8977#8977"">this question</a> which I answered some time ago.</p>

<p>Then, you say that you haven't got a lot of connections left on your UNO board, so I think that SPI would't be very useful, as it takes 3 pins for the data transmission (SCLK, MOSI, MISO) plus one pin for every device you connect.</p>

<p>The best way (even if it is a little slower that SPI) is to use I2C, which needs that you leave unused analog input pins A4 and A5, as they are the I2C BUS. Unfortunately I haven't any knowledge about I2C DC motor drivers.</p>

<p>For the steppers, I suggest to take a look at <a href=""http://www.ebay.co.uk/itm/Serial-I2C-Microstepping-Motor-Driver-DC-PWM-CNC-Raspberry-Pi-Aduino-1-2A-/111177026930"" rel=""nofollow"">this</a>, but it depends by your budget for what you can buy.</p>

<p>You could fix the pin shortage problem by adding some <a href=""http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf"" rel=""nofollow"">74HC595</a> shift registers. They aren't very expensive (less than a dollar, or if you live in europe, .5€) and they can be daisy-chained. To control them, see the <a href=""http://arduino.cc/en/tutorial/ShiftOut"" rel=""nofollow"">Arduino website tutorial</a>.</p>

<p>Finally, if the pins that you use are inputs, use a <a href=""http://www.nxp.com/documents/data_sheet/74HC_HCT165.pdf"" rel=""nofollow"">74HC165</a>, which is the opposite of a 595. As always, see the <a href=""http://arduino.cc/en/tutorial/ShiftIn"" rel=""nofollow"">Arduino website tutorial</a>.</p>
"
"<p>It works!</p>

<p>First I'll say thanks to the moderators/support staff from Adafruit. One dude in particular has tried to help me constantly for the past couple of days or so. </p>

<p>So, following on from my edit, Adafruit told me that the ICSP pins are connected to the control part of the board via the main pins. I should have seen it actually, but I obviously didn't examine and understand it properly. This means that although I severed the connection between the main pins and the centre, the ICSP and 11,12,13 were still connected together. What I actually needed was for the ICSP pins to be connected to the controls to receive the data, and the main pins to be detached from them. So I de-soldered the solder jumpers that I had originally put on the connector plates on the underside of the board (which connect the ISCPs to the main pins), then soldered wire from the ICSP side to the associated breakout holes which are the ones on the inside of the cuts that I made on the board. Here is a picture:</p>

<p><img src=""http://i.stack.imgur.com/HQFUw.jpg"" alt=""New wiring on board""></p>

<p>If anyone tries to do this, beware of where you are wiring to! I was very careful to make sure I matched the connecting wires to the correct pins. I have tested it several times (using the example test file that comes with the library) and it works as it should. It works on my Uno R3 and my Mega 2560 R3, which is great, as now pins 11-13 are free to use for my motor shield, or potentially any other shield which may need those pins. </p>

<p>I hope this helps someone else in the future. There doesn't seem to be any information on this particular combination of shields, but as these projects are becoming more popular this may prove to be useful.</p>
"
"<p>I want to control a servo with the least amount of components. But generally, what is the simplest way to do this without actually using a fullblown arduino board?</p>
"
"<p>If you what you're looking for is the cheapest option with the fewer components possible, then you can use a regular ATMega328p chip, with a few passive components attached to it.</p>

<p>You just need to program it with an Arduino Bootloader once, in order to be able to program it easily, but you can use any existing Arduino to do that. After doing this once, you can program it with any FTDI-type USB to Serial converter.</p>

<p>Here's an Instructable that <a href=""http://www.instructables.com/id/Program-an-ATmega168328-with-codebender/"" rel=""nofollow"">explains the whole process</a>.</p>
"
"<p>Please, take a look at <a href=""http://www.gammon.com.au/breadboard"" rel=""nofollow"">this guide</a> by Nick Gammon, which explains in detail how to build a breadboard Arduino.</p>

<p>You'll need also an Arduino board without the chip (a good UNO will do the job) because you need to program it some way. It is needed absolutely in the case that you buy an ATMEGA328 that hasn't the bootloader, as you'll have to write it on the blank chip.</p>

<p>To speak directly via serial with the standalone Arduino (and to program it), I suggest you to buy a FT232RL board (just be careful to buy a real one, as there are fakes that FTDI blocked and bricked with drivers)</p>

<p>Then, for the servo you just have to plug it correctly: two cables for power, one for the control.</p>
"
"<p>This is useful if you don't need all the I/O of the Atmega.</p>

<p>If you want a simple board just to run a servo or two and still have some I/O you could use a ATTiny85 chip and use this <a href=""http://projectsfromtech.blogspot.com/2013/03/attiny85-servo-softwareservo-library.html"" rel=""nofollow"">software servo library</a> that works with the attiny. It also works best with the High-Low tech cores.</p>

<p>I used this with a project and it works flawlessly without stalling.</p>

<p>This would give you small setup as you can use the internal clock 8MHz and minimal external components, i.e. regulator and Capacitors. </p>
"
"<p>I want to make a device with a sensor I can attach to the places my dog likes to mark. When sensor becomes wet I want a buzzer to make a loud noise to scare the animal and notify me I need to encourage the dog to go outside. Any suggestions on what sensor to use.</p>
"
"<p>I'm using a dual h bridge to control two dc motors on an inverted pendulum (cart-pole system).  At the moment, I have to send two different pulse width modulated signals to the two enable pins to control the two motor speeds and four digital write commands to control the directions.  </p>

<p>Ideally, I want to switch the two motors simultaneously in the same direction and with the same speed.  So, I'd like to be able to control both motors' speeds with only one pulse width modulation signal and control both motor directions with only two digital write commands.  </p>

<p>Is there a way I can do with with Arduino?  Can one PWM signal from a single arduino pin be sent to two enable pins at the same time? Can the same be done for a single digital output pin?  If so, how can I accomplish this?</p>
"
"<p>You can connect a single output to as many input loads as you like, provided the current is sufficient to hold the output voltage within the input thresholds. See the datasheet for the H bridge to find out what the input load and thresholds are, and compare them with the output from the Arduino.</p>
"
"<p>I'm making a project and I'm using multiple 1 digit 7 segment displays. I haven't plugged them all on my arduino because currently I'm just testing. The problem is on the I/O ports. Obviously I need to use shift registers and since it's my first time ever using them I need to know more about them. After googling, I found that the specific model I bought outputs 8 pins and you can stack up to 8 in series. So lets do the math. <code>8 shift register</code> x <code>8 pins each SR</code> = <code>64 new pins</code> It seems cool but assuming I'm using 28 displays let's do the math again.
28 displays, each display has 8 pins (8 for segments and 2 as common cathode)
<code>28</code> x <code>8</code> = <code>224</code> required pins.
Is is possible to expand the I/O pins by 224 pins? How many shift registers can I stack together? Also which is better, the single digit display or the 4 digit display?</p>
"
"<p>I've currently got a setup where I am using a 2 thermocouple setup using MAX31850 and the circuit looks exactly as mentioned here using the external power option. (<a href=""https://learn.adafruit.com/adafruit-1-wire-thermocouple-amplifier-max31850k/wiring-and-test"" rel=""nofollow"">https://learn.adafruit.com/adafruit-1-wire-thermocouple-amplifier-max31850k/wiring-and-test</a>)</p>

<p>I take the data that is returned from this over serial and pass it over to a simple inverter circuit, which inverts the signal and fluctuates the voltage of a small CREE LED.
The problem that I am encountering is that the data being received from the thermocouples is incorrect when the LED is attached to the setup. And it becomes correct as soon as the LED is detached.</p>

<ul>
<li>I have tried running my thermocouple set up over an external 5V
supply and using common ground with the Arduino, but it still does
not help.</li>
<li>I have tried using decoupling capacitors on the power rails
to remove any noise due to the LED, but again to no help. What else
can I try to ensure that I can read the data and modulate the LED
simultaneously?</li>
</ul>
"
"<p>You can chain as many shift registers as you want.</p>

<p>Most commonly, these displays are multiplexed. Only one digit is lit at a time, cycling though all the digits fast enough, so the eye can't tell. This is however not very good practice for 28 digits, as the brightness will become 1/28th (though you could create groups of digits, and multiplex those groups separately).</p>

<p>There are specialized chips that do this multiplexing for you. E.g. the Max7219. This chip can multiplex 8 digits, with 8 segments. So you'd need 4 of these to light up 28 digits.</p>
"
"<p>I recently purchased a pcDuino 3B and I am very pleased with the Board so far. I can use the preinstalled arduino IDE to program the board from the board and run programs.</p>

<p>However, when I came to use I2C, it generated a load of errors with the built-in libraries when I tried to compile. I don't know why it did this, it does it when trying to compile any program using I2C. Here is the error list (Yes, I am using an Adafruit display library that works fine with exactly the same sketch on my laptop):</p>

<pre><code>In file included from /usr/share/arduino/hardware/arduino/pcduino/cores/arduino/Stream.h:26:0,
                 from /usr/share/arduino/hardware/arduino/pcduino/libraries/Wire/Wire.h:9,
                 from Stopwatch_new.ino:1:
/usr/share/arduino/hardware/arduino/pcduino/cores/arduino/Print.h:47:23: error: ‘byte’ has not been declared
In file included from Stopwatch_new.ino:1:0:
/usr/share/arduino/hardware/arduino/pcduino/libraries/Wire/Wire.h:41:23: error: ‘byte’ has not been declared
Stopwatch_new.ino:5:51: error: cannot allocate an object of abstract type ‘Adafruit_RGBLCDShield’
/home/ubuntu/Arduino/libraries/AdafruitLCD/Adafruit_RGBLCDShield.h:68:7: note:   because the following virtual functions are pure within ‘Adafruit_RGBLCDShield’:
/usr/share/arduino/hardware/arduino/pcduino/cores/arduino/Print.h:47:17: note:  virtual int Print::write(int)
Stopwatch_new.ino:5:23: error: cannot declare variable ‘lcd’ to be of abstract type ‘Adafruit_RGBLCDShield’
/home/ubuntu/Arduino/libraries/AdafruitLCD/Adafruit_RGBLCDShield.h:68:7: note:   since type ‘Adafruit_RGBLCDShield’ has pure virtual functions
Stopwatch_new.ino: In function ‘void updateScreen()’:
Stopwatch_new.ino:125:27: error: call of overloaded ‘String(float&amp;, int)’ is ambiguous
Stopwatch_new.ino:125:27: note: candidates are:
/usr/share/arduino/hardware/arduino/pcduino/cores/arduino/WString.h:44:14: note: String::String(unsigned int, unsigned char)
/usr/share/arduino/hardware/arduino/pcduino/cores/arduino/WString.h:43:14: note: String::String(int, unsigned char)
/usr/share/arduino/hardware/arduino/pcduino/cores/arduino/WString.h:42:14: note: String::String(unsigned char, unsigned char)
</code></pre>

<p>It seems that no one else is having this issue.</p>

<p>Just to clarify, the issue is not with my code or the library, it compiles fine on my other computer running WINDOWS but same Arduino version (1.5.3), same sketch code and same library code.</p>

<p>Help much appreciated, thanks!</p>
"
"<p>You probably will want a moisture sensor like <a href=""http://www.ebay.co.uk/itm/like/370999421770?limghlpsr=true&amp;hlpv=2&amp;ops=true&amp;viphx=1&amp;hlpht=true&amp;lpid=108&amp;chn=ps&amp;device=c&amp;adtype=pla&amp;crdt=0&amp;ff3=1&amp;ff11=ICEP3.0.0-L&amp;ff12=67&amp;ff13=80&amp;ff14=108"" rel=""nofollow"">this one</a> (there are many variations of this).</p>

<p>This will return one signal when dry, and another when wet.</p>

<p>You will need a Buzzer to make a sound as well (Or a piezo speaker if you feel like getting more advanced) in order to make a sound.</p>

<p>Your sketch should have, in its <code>loop</code>, an <code>if</code> statement checking if the moisture sensor has returned the wet signal (The signal will depend on the sensor you get) and, in the block that executes if there is a signal, a statement driving the buzzer and a delay before turning it off.</p>

<p>Bear in mind that you want to keep the Arduino itself away from the moisture sensor, as your Arduino probably won't survive the dog's doings.</p>
"
"<p>i am doing a Ultimate GPS module like this:<img src=""http://i.stack.imgur.com/r87dZ.png"" alt=""enter image description here""></p>

<p>it works when i use arduino UNO board, but when I use arduino micro board it doesn't work, so could anyone tell me how to fix it?.By the way I use the example code in GPS library.</p>

<p>UNO: the data looks like messy code
<img src=""http://i.stack.imgur.com/lXlrk.png"" alt=""enter image description here""></p>

<p>Micro: didn't give me any time, date or fix
<img src=""http://i.stack.imgur.com/U2Xw6.png"" alt=""enter image description here""></p>
"
"<p>The Arduino Uno and Micro, in practice, work almost exactly the same. Just make sure that your wiring is correct (In this photo, the wires go from TX to TX and RX to RX, they should go between TX on one board and RX on the other, and vice versa.</p>

<p>Your code should work on a micro exactly as it does on an Uno. That is one of the best features of Arduino; the ability to port code to another board without much (if any) modification.</p>
"
"<p>As arduino.org states, the bootloader is pre-burnt by Atmel at the factory. I'd like to know if it will be possible for us to buy ""raw"" ICs and burn them at home for our own boards, as we do with the Atmega328 for example.</p>
"
"<p>It turns out that the libraries for compiling were incomplete. Having copied the libraries for the official IDE, it worked fine.</p>
"
"<p>Virtualbreadboard has a new VBB4Arduino 'Two Arduino's' edition which includes BOTH a JVM Arduino emulator AND a AVR Instruction set simulator with examples that cover almost all of the Arduino distribution examples and a bunch of peripheral hardware - LCD's, WS2812 Neo LEDS, Motors, Servo's, Logic Analyser and more.</p>

<p><a href=""http://www.virtualbreadboard.com"" rel=""nofollow"">http://www.virtualbreadboard.com</a></p>

<p>Disclaimer: I am the author of Virtual Breadboard</p>
"
"<p>So this might be a total noob question (which admittedly I am) I have a Motor, if I connect it to GND and the 5V output it runs. Ok so far. But if I connect it to GND and a pin set to OUTPUT and HIGH nothing happens. My multimeter reads 5V for both setups, so if 5V come to the motor one way or the other why does one work and one not? </p>
"
"<p>I have a LED Matrix just like this one</p>

<p><img src=""http://i.stack.imgur.com/S4JeL.jpg"" alt=""""></p>

<p>but couldn't find the data sheet for it (1855AS)
I asked around in my country and one guy told me to try attaching one side to 5v and the other to GND. Some LEDs worked fine and others didn't light up at all. In the end one if not more got burned.</p>

<p>So I'm here asking if anyone can tell me a way to figure out how it works.
I would appreciate the help!</p>
"
"<p>Your photo shows the GPS connected to pins 0 and 1 (RX and TX) on the UNO.  But you don't show the sketch you are running.  Do you have it set that way in the sketch?</p>

<p>It turns out the micro and UNO are different in the way those pins work.  From <a href=""http://arduino.cc/en/Main/arduinoBoardMicro"" rel=""nofollow"">http://arduino.cc/en/Main/arduinoBoardMicro</a></p>

<blockquote>
  <p>Serial: 0 (RX) and 1 (TX).  Used to receive (RX) and transmit (TX) TTL
  serial data using the ATmega32U4 hardware serial capability. Note that
  on the Micro, the Serial class refers to USB (CDC) communication; for
  TTL serial on pins 0 and 1, use the Serial1 class.</p>
</blockquote>

<p>This suggests to me that you'd need to change the code to read pins 0 and 1.  </p>

<p>Easier is probably to wire it up to pins 2 and 3 and use the defaults in the sketch</p>

<pre><code>// If using software serial, keep this line enabled
// (you can change the pin numbers to match your wiring):
SoftwareSerial mySerial(3, 2);
</code></pre>
"
"<p>I have a bluetooth adapter connected to uno, and using a serial monitor on phone. </p>

<p>In the arduino code im debugging there is this line waiting for new line signal in the serial stream:</p>

<pre><code>char c = SerialBT.read();

if (c == '\r' || c == '\n'){
</code></pre>

<p>no matter what i try sending to via my phone i cant get this to evaluate as true...</p>

<p>if i send \n , i believe it is sending it as 2 chars \ and n , not as a single char.</p>

<p>is this a problem with the phone app or what ?</p>
"
"<p>It turns out it was a problem with the android terminal program i was using, by switching to another that specifically has support and options for \n \r things it works now.</p>
"
"<p>I got a Sparkfun Redbot Kit a while back. I ended up building it vanilla and it was a good introduction to the board (the board is basically Uno and a motor shield in one) and the toys that came with it. I figured if could scavenge an RC car, I'd get a more robust redbot. I found an old RC Rock Crawler, it has a basic suspension, two motors, and a steering servo.<br>
Unfortunately, I encountered a problem. The steering servo only has two wires. I loaded the <em>Servo</em> -> <em>Sweep</em> example that is default in the Arduino IDE to see if I could make it work regardless. I tried all the different all the different wire/header combinations on the servo headers:</p>

<ol>
<li>When I attach the wires to gnd and # I get a buzzing noise.</li>
<li>When I attach the wires to gnd and pow the servo turns left or, if I swap the wires, it turns right.</li>
<li>When I attach the wires to pow and # nothing happens.</li>
</ol>

<p>I currently can't take advantage of the servo headers on the board (or at least I don't know how to). I was hoping that I could that there might be a work around, I just don't know what it is.<br>
The obvious answer is that I could run both motors off of only one of the headers and use the other to control the steering (thats how the original board from the car was wired), but I can get a faster car if each motor has its own header, and I'm all about the vroom vroom...</p>

<p>I'm running the whole thing off the default 6v (4 AA) battery pack. I might be able to wire in the extra 2 AA's for the extra 3v but I don't want mess with the wiring on the pack unless I know it's going to work.</p>

<p>I have an accelerometer connected to the A4 A5 header block and the motors connected too (I checked w/o them connected but there was no difference). </p>

<p><img src=""https://dlnmh9ip6v2uc.cloudfront.net/assets/7/6/b/4/6/520026ca757b7f2344958fd5.jpg"" alt=""A basic image of all the headers on the RedBot board"">
<em>Image courtesy of <a href=""https://learn.sparkfun.com/tutorials/getting-started-with-the-redbot"" rel=""nofollow"">https://learn.sparkfun.com/tutorials/getting-started-with-the-redbot</a></em><br>
More info on the redbot board <a href=""https://www.sparkfun.com/products/12097"" rel=""nofollow"">https://www.sparkfun.com/products/12097</a></p>
"
"<p>You could check from where you have bought it. Maybe they have datasheet.
I found one similar, but before you must check if everything is the same and then do testing with power. <a href=""http://www.adafruit.com/datasheets/454datasheet.pdf"" rel=""nofollow"">LuckyLight</a></p>
"
"<p>If the motor you are using has only two wires, and as you described it's response to the direct connection to the power, it can't be a servo. The motor is a normal dc motor.
If you want to control the amount of the turns on your rc car you should try to play with the pwm signal, I don't know if it will work or not but at least you will have tried. And remember not to connect the motor directly on the micro's pin if there no motor pins on your red board.</p>
"
"<p>As you are testing the correct functionality of LEDs on matrix board, which means the LEDs are multiplexed together. The fastest way to check the pinout is to use a multimeter in continuity test mode and then connect the positive or signal wire ( the red one ) to an fixed pin  (usually start with one ) and the with negative or gnd wire ( the black one ) connect it one by one to the all the remaining pins. When you have finished move the signal wire to the next pin and rescan all the pins, repeat all the steps for every pins on the matrix board.
I don't recommend you to use directly 5v because it can be dangerous and you can damage the LEDs of the matrix display as there isn't a current limiting resistor.</p>
"
"<p>I am new to Arduino and IoT. Got my hands on Yun and loaded a simple Sketch to subscribe to a topic. I am receiving messages (have setup a PHP script and broker on server which takes care of the messages) and can turn ON and OFF LED, L13. But when I disconnect the Yun from my PC and connect it again (to power it up), it stops receiving messages. I have to load the Sketch again to make it work. Here is my code,</p>

<hr>

<pre><code>#include &lt;spi.h&gt;
#include &lt;pubsubclient.h&gt;
#include &lt;yunclient.h&gt;

byte server[] = { 192, 168, 1, 196 };
int port = 1883;
char* pubTopic = ""fromYun"";
char* subTopic = ""sensor/light"";

void callback(char* topic, byte* payload, unsigned int length)
{
//convert byte to char
payload[length] = '\0';
String strPayload = String((char*)payload);
// Serial.println(topic); Serial.println(strPayload);

// handle message arrived
if(strPayload == ""ON"")
{
digitalWrite(13, HIGH);
}
else if(strPayload == ""OFF"")
{
digitalWrite(13, LOW);
}
else{}
}

YunClient yun;
PubSubClient mqtt(server, port, callback, yun);

void setup()
{
Serial.begin(9600);
pinMode(13, OUTPUT);
digitalWrite(13, LOW);

Bridge.begin();
if (mqtt.connect(""arduinoClient""))
{
mqtt.publish(pubTopic,""hello world!"");
mqtt.subscribe(subTopic);
}
}

void loop()
{
mqtt.loop();
}
</code></pre>

<hr>

<p>Am I missing something?</p>

<p>I referred <a href=""http://jpmens.net/2013/10/15/mqtt-on-the-arduino-yun/"" rel=""nofollow"">this</a> post and PubSubClient -> mqtt_basic.ino for making this Sketch.
I don't understand why is mqtt.connect(""arduinoClient""). I mean, why is this string ""arduinoClient""? In one INO on GitHub I saw it as ""yun""..</p>

<p>Any help will be appreciated. Thanks in advance!</p>

<p>EDIT : I am using Mosquitto MQTT</p>
"
"<p>Type must be BYTE, not INT. The write value is 1 BYTE 0 - 255. Use typecasting if necessary.</p>

<pre><code>int x;
byte y;
y = byte(x);
EEPROM.write(100, y);
</code></pre>
"
"<p>That's probably caused by the motor's current consumption. The 5V pin can deliver much more current than the output pin in high state. If you want to switch the motor on/off by software, you need a ""hardware driver"" for the motor, in the simplest case a power transistor. </p>
"
"<p>I want to use Arduino Uno (Rev. 3) resp. Arduino Nano for time critical ignition control of a combustion engine. Software is developed under arduino rev. 1.6.2.</p>

<p>The only Arduino system functions i use are micros()  and delayMicroseconds(). I suppose they are implemented by a timer interrupt, which may fire within time critical port polling regions of the program.  </p>

<p>What's the maximum runtime for the ISR i have to expect? As long it stays within the range of a few microseconds, say 10 or like, it would be tolerable.</p>

<p>Are there other time ressources used in the background by the arduino system i have to cope with? </p>
"
"<p>Here is the <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/wiring.c#L47-L65"" rel=""nofollow"">The ISR code</a>.</p>

<p>Here is the obj-dump:</p>

<pre><code>000008f6 &lt;__vector_16&gt;:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 8f6:   1f 92           push    r1
 8f8:   0f 92           push    r0
 8fa:   0f b6           in  r0, 0x3f    ; 63
 8fc:   0f 92           push    r0
 8fe:   11 24           eor r1, r1
 900:   2f 93           push    r18
 902:   3f 93           push    r19
 904:   8f 93           push    r24
 906:   9f 93           push    r25
 908:   af 93           push    r26
 90a:   bf 93           push    r27
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = timer0_millis;
 90c:   80 91 a0 01     lds r24, 0x01A0
 910:   90 91 a1 01     lds r25, 0x01A1
 914:   a0 91 a2 01     lds r26, 0x01A2
 918:   b0 91 a3 01     lds r27, 0x01A3
    unsigned char f = timer0_fract;
 91c:   30 91 9f 01     lds r19, 0x019F

    m += MILLIS_INC;
    f += FRACT_INC;
 920:   20 e3           ldi r18, 0x30   ; 48
 922:   23 0f           add r18, r19
    if (f &gt;= FRACT_MAX) {
 924:   2d 37           cpi r18, 0x7D   ; 125
 926:   20 f4           brcc    .+8         ; 0x930 &lt;__stack+0x31&gt;
    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    unsigned long m = timer0_millis;
    unsigned char f = timer0_fract;

    m += MILLIS_INC;
 928:   40 96           adiw    r24, 0x10   ; 16
 92a:   a1 1d           adc r26, r1
 92c:   b1 1d           adc r27, r1
 92e:   05 c0           rjmp    .+10        ; 0x93a &lt;__stack+0x3b&gt;
    f += FRACT_INC;
    if (f &gt;= FRACT_MAX) {
        f -= FRACT_MAX;
 930:   23 eb           ldi r18, 0xB3   ; 179
 932:   23 0f           add r18, r19
        m += 1;
 934:   41 96           adiw    r24, 0x11   ; 17
 936:   a1 1d           adc r26, r1
 938:   b1 1d           adc r27, r1
    }

    timer0_fract = f;
 93a:   20 93 9f 01     sts 0x019F, r18
    timer0_millis = m;
 93e:   80 93 a0 01     sts 0x01A0, r24
 942:   90 93 a1 01     sts 0x01A1, r25
 946:   a0 93 a2 01     sts 0x01A2, r26
 94a:   b0 93 a3 01     sts 0x01A3, r27
    timer0_overflow_count++;
 94e:   80 91 a4 01     lds r24, 0x01A4
 952:   90 91 a5 01     lds r25, 0x01A5
 956:   a0 91 a6 01     lds r26, 0x01A6
 95a:   b0 91 a7 01     lds r27, 0x01A7
 95e:   01 96           adiw    r24, 0x01   ; 1
 960:   a1 1d           adc r26, r1
 962:   b1 1d           adc r27, r1
 964:   80 93 a4 01     sts 0x01A4, r24
 968:   90 93 a5 01     sts 0x01A5, r25
 96c:   a0 93 a6 01     sts 0x01A6, r26
 970:   b0 93 a7 01     sts 0x01A7, r27
}
 974:   bf 91           pop r27
 976:   af 91           pop r26
 978:   9f 91           pop r25
 97a:   8f 91           pop r24
 97c:   3f 91           pop r19
 97e:   2f 91           pop r18
 980:   0f 90           pop r0
 982:   0f be           out 0x3f, r0    ; 63
 984:   0f 90           pop r0
 986:   1f 90           pop r1
 988:   18 95           reti
</code></pre>

<p>I'll let you calculate how many clock cycles that is. My guess is that it's less that 160 clock cycles (i.e. 10S).</p>

<p>But I'm unsure if the accuracy of <code>micros</code> is good enough in your application.</p>
"
"<p>I'm having a soft pot meter here and I would like to register the duration of the touch event. I'm having a different variable, which keeps going from 1024 to 0 , which regularly takes 60 seconds, but for every second you touch the soft pot meter the count adds 50 up to 1024. Like returning the clock backward. </p>

<p>How would I register/code this?</p>

<p><img src=""http://i.stack.imgur.com/NtBgH.jpg"" alt=""Softpot meter""></p>
"
"<p>I am trying to execute the sweep program but all the servo does is go back and forth in one step. When I tried changing the delay, It behaves erratically.</p>

<p>Servo Specs:</p>

<pre><code>Required Pulse: 3-5 Volt Peak to Peak Square Wave
Operating Voltage: 4.8-7.2 Volts
Operating Temperature Range: -10 to +60 Degree C
Operating Speed (4.8V): 0.18sec/60 degrees at no load
Operating Speed (6V): 0.16sec/60 degrees at no load
Operating Speed (7.2V): 0.14sec/60 degrees at no load
Stall Torque (4.8V): 11kg/cm
Stall Torque (6V): 13.5kg/cm
Stall Torque (7.2V): 16kg/cm
360 Modifiable: Yes
Potentiometer Drive: Indirect Drive
Bearing Type: Double Ball Bearing
Gear Type: All Metal Gears
Connector Wire Length: 12""
Dimensions: 1.6"" x 0.8""x 1.4"" (41 x 20 x 36mm)
Weight: 56gm
</code></pre>

<p>Sweep Code:</p>

<pre><code>#include &lt;Servo.h&gt; 

Servo myservo;  // create servo object to control a servo 
                // twelve servo objects can be created on most boards

int pos = 0;    // variable to store the servo position 

void setup() 
{ 
  myservo.attach(9);  // attaches the servo on pin 9 to the servo object 
} 

void loop() 
{ 
  for(pos = 0; pos &lt;= 180; pos += 1) // goes from 0 degrees to 180 degrees 
  {                                  // in steps of 1 degree 
    myservo.write(pos);              // tell servo to go to position in variable 'pos' 
    delay(15);                       // waits 15ms for the servo to reach the position 
  } 
  for(pos = 180; pos&gt;=0; pos-=1)     // goes from 180 degrees to 0 degrees 
  {                                
    myservo.write(pos);              // tell servo to go to position in variable 'pos' 
    delay(15);                       // waits 15ms for the servo to reach the position 
  } 
} 
</code></pre>

<p>I tried both powering up internally and externally. Internally it responds but externally, arduino's L LED is high all the time and servo does not respond. May I know what is actually going wrong here.</p>
"
"<p>I am attempting to send a RAW IR code using the IRremote.h library.  The process for capturing IR pulses is easy to find on the web, but the process for sending them again is not.  After a few days, i pieced the following code together:</p>

<pre><code>#include &lt;IRremote.h&gt;
 IRsend irsend;

void setup() {

}

void loop() {

  int IRsignal[] = {

// ON, OFF (in 10's of microseconds)

    90, 86,

    174, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 174,

    88, 86,

    174, 88,

    86, 2340,

    88, 86,

    174, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 88,

    86, 174,

    88, 86,

    174, 88,

    86, 0};


      irsend.sendRaw(IRsignal, 10, 38);

      delay(1000);

}
</code></pre>

<p>When I run it, i get the following error:</p>

<blockquote>
  <p>ir_test.ino: In function 'void loop()': ir_test.ino:65:38: error:
  invalid conversion from 'int*' to 'unsigned int*' [-fpermissive] In
  file included from ir_test.ino:3:0:
  /Applications/Arduino.app/Contents/Resources/Java/libraries/RobotIRremote/src/IRremote.h:143:8:
  error:   initializing argument 1 of 'void IRsend::sendRaw(unsigned
  int*, int, int)' [-fpermissive]    void sendRaw(unsigned int buf[],
  int len, int hz);
          ^ Error compiling.</p>
</blockquote>

<p>I am not sure what I did wrong, or how to convert the data types.  Any tips or ideas?</p>
"
"<p>Use <code>unsigned int IRsignal[]</code> instead.</p>

<p>Also, your array is 48 items long, not 10. So <code>irsend.sendRaw(IRsignal, 48, 38);</code></p>
"
"<p>Is there anything like the link below that I can read/set with an arduino/raspberry pi?</p>

<p>I'd like to be able to control this completely from a computer in my kegerator setup.</p>

<p>Any search terms that might help me find something would be useful too.</p>

<p>Thanks</p>

<p><a href=""http://rads.stackoverflow.com/amzn/click/B0060NOX40"" rel=""nofollow"">http://www.amazon.com/Taprite-Product-Pressure-Kegerator-Regulator/dp/B0060NOX40/ref=lh_ni_t?ie=UTF8&amp;psc=1&amp;smid=AEUC6GAA8XY7Y</a></p>
"
"<p>I have included the STL library in Arduino and i can run a program with 1D vector.
But i am getting error while declaring a 2D vector.  </p>

<pre><code>#include &lt;StandardCplusplus.h&gt;
#include &lt;serstream&gt;
#include&lt;vector&gt;
#include&lt;iterator&gt;

using namespace std;

vector &lt;vector&lt;int&gt; &gt; grid;
vector&lt;int&gt; col(5,3);
grid.push_back(col);

void setup()
{
    Serial.begin(9600);
}

void loop()
{
  for(int i = 0; i &lt; 5; i++)
  {
    Serial.println(grid[[0][i]);
  }
}
</code></pre>

<p>And the error is </p>

<pre><code>'grid' does not name a type.   
</code></pre>

<p>Do i need to add another header file?</p>
"
"<p>The error is coming from </p>

<pre><code> grid.push_back(col);
</code></pre>

<p>You cannot have this line at the top-most level outside a function / main. Move it inside <code>setup</code> or <code>loop</code>.</p>
"
"<p>It's easy enough to attach a display for displaying sensor data, but I'm wondering what the proper way is to have the user change variables using an user interface on the attached 2x16 display. 
The only library I found for this purpose:
<a href=""https://liudr.wordpress.com/libraries/phi_prompt/"" rel=""nofollow"">https://liudr.wordpress.com/libraries/phi_prompt/</a></p>

<p>Takes a lot of code just to set up. I'm wondering if there's perhaps an easier option. All thoughts appreciated!</p>
"
"<p>I have following code:</p>

<p><strong>MyApp.ino</strong>:</p>

<pre><code>#include ""DfRobotLcdShield.h""

void setup() {
}

void loop() {
}
</code></pre>

<p><strong>DfRobotLcdShield.h</strong>:</p>

<pre><code>#include &lt;LiquidCrystal.h&gt;
</code></pre>

<p>When I try to compile, I'm getting the error:</p>

<pre><code>In file included from MyApp.ino:1:0:
c:\temp\build5856181074637812172.tmp\DfRobotLcdShield.h:4:27: fatal error: LiquidCrystal.h: No such file or directory
 #include &lt;LiquidCrystal.h&gt;
                           ^
compilation terminated.
Error compiling.
</code></pre>

<p>When I add</p>

<pre><code>#include &lt;LiquidCrystal.h&gt;
</code></pre>

<p>directly to the .ino file, it works. I'm using the latest Arduino-IDE 1.6.3.</p>
"
"<p>as it is in the question, i need to know what is the size of the biggest string that i can send using the serial port to the arduino.<br>
Thank you</p>
"
"<p>The likely causes of failure are</p>

<ul>
<li>Wrong baud rate: you're already using 57600, the most common one.</li>
<li>Rx and Tx cross connected: try connecting them the other way round.</li>
<li>Wrong clock clock frequency in the chip: The tools usually assume an AtMega328 runs at 16MHz.</li>
<li>Chip is not in bootloader/programming state, in the very first seconds after releasing the reset button or powering the arduino, the bootloader is listening for instructions to start reprogramming the chip via serial communication, if there is none it will continue running the program on it. Hold reset -> Hold upload -> Release upload -> Release reset.</li>
</ul>

<p>The above assumes, of course, that you have a working board. If that isn't certain, follow @Nathan's advice to plug in a chip pre-programmed with a Blinky sketch to confirm it. I use a combined Blinky and HelloWorld sketch to prove both the basic functioning and the serial I/O in one test.</p>

<p>A couple of these are handy to keep around, too, for proving there is power or a logic HIGH where you expect it:</p>

<p><img src=""http://i.stack.imgur.com/Ztoil.jpg"" alt=""LED with resistor""></p>

<pre><code>       LED with current-limiting resistor on the cathode
</code></pre>
"
"<p>I am trying to calculate time between two serial events. Using Arduino UNO R3 with 16MHz default clock source.
I am using timer 1 with pre-scale of 64 to get time per one count = 4000ns. This i am choosing at random without any specific reason. 
Sending character 'o' to start the timer and character 'k' to stop it and hence calculate the time in between. The ISR routine calculates how much times the timer overflows.
The code is:</p>

<pre><code>    unsigned int t;
unsigned int c;
char r;
void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  pinMode(13, OUTPUT);
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;

  TIMSK1 = (1&lt;&lt;TOIE1);//enable timer overflow interrupt
  sei();
  //SREG = (1&lt;&lt;8);//enable global inteerupt
}

void loop() {
  // put your main code here, to run repeatedly:
  if(Serial.available()&gt;0)
  {
    r=Serial.read();
  if(r=='o')
  {
    TCNT1=0;
    TCCR1B |= (1&lt;&lt;CS11)|(1&lt;&lt;CS10);//64 pre-scale &amp; start
    Serial.println(TCNT1);
  }
  else if(r=='k')
  {
    Serial.println(TCNT1);
    TCCR1B = 0;//stop timer
    t=TCNT1+(c*65536);
    t=t*(4*10^(-9));
    Serial.print(""overflows = "");
    Serial.println(c);
    Serial.print(""time = "");
    Serial.println(t);
    c=0;
    t=0;
  }
  }
}//loop

ISR(TIMER1_OVF_vect)
{
  c++;
}//isr
</code></pre>

<p>But, on serial monitor only the block of if(Serial.read()=='o').... is executing. The flow does not enter the second else if block. </p>

<p>What is wrong with this code? How long does the Serial buffer hold its vale ?</p>

<p><strong>EDIT:</strong> I got the code working for checking for 'k'. But the timer value it calculates is very less than compared to what it should be. Is anything wrong with the timer settings. Setting CS10=CS11=1 gets the pre-scaler value to 64.</p>

<p>Hence, the time for 1 count should be = 1/(16MHz/64) . </p>

<p>Is anything wrong with this?</p>
"
"<p>I'd read the result of <code>Serial.read()</code> to a variable and check this variable, because otherwise the first <code>Serial.read()</code> will have already read the 'k'. I reckon you can remove the <code>Serial.available()</code> check.</p>

<pre><code>void loop() {
    int chr = Serial.read();
    if(chr=='o')
    {
        TCNT1=0;
        TCCR1B |= (1&lt;&lt;CS11)|(1&lt;&lt;CS10);//64 pre-scale &amp; start
    }
    else if(chr=='k')
    {
        t=TCNT1;
        TCCR1B = 0;//stop timer
        t=t+(c*65536);
        c=0;
        Serial.println(t);
        t=0;
    }
}//loop
</code></pre>
"
"<p>I am trying to play a tone with a buzzer connected on an arduino nano pin. I have also connected a reed switch with INPUT_PULLUP on INT0 and a led. The program loops continuously (it's an environmental monitor and alarm personal project) until the reed switch is set on HIGH where a function is called and the buzzer should play an one-second high pitch tone. </p>

<pre><code>void doorStateChange() {
  static unsigned long last_interrupt_time = 0;
  unsigned long interrupt_time = millis();
  if (interrupt_time - last_interrupt_time &gt; 1000)
  {
    led_B_state   = !led_B_state;
    digitalWrite(buzzPin, HIGH);
    digitalWrite(led_A_Pin, HIGH);

    if (millis() - interrupt_time &lt;= 1000 ){
        digitalWrite(buzzPin, LOW);
        digitalWrite(led_A_Pin, LOW);
    }

  }
  last_interrupt_time = interrupt_time;
}
</code></pre>

<p>The interrupt is called, the Led lights up but I can't make the buzzer sound right. I 've tried with <code>tone(buzzPin, 5000, 1000);</code> but seems that the delay does not work - The sound is heard but after the 1000ms it continuous to work in a different tone (strange?).</p>

<p>The only way I could make it work is with <code>buzzPin_state = ! buzzPin_state;</code> where the buzzer beeps as long as the reed switch is HIGH. </p>

<p>I also need to say that <code>attachInterrupt(0, doorStateChange, CHANGE);</code>. </p>

<p>The information I get from googling this issue is gibberish: some say that delays don't run in interrupts, others call external functions etc. </p>

<p>What is the proper way to achieve this ?</p>
"
"<p>I am doing a project where I need to send some numbers between arduinos. But it has to be wirelessly because they will be moving. How to Communicate between arduinos wirelessly? I need to send data between them. Wifi would be preferred.</p>

<p>Thank You.</p>
"
"<p>That would be 64 bytes, providing the buffer is fully empty. See <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/HardwareSerial.h#L42-L43"" rel=""nofollow"">https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/cores/arduino/HardwareSerial.h#L42-L43</a></p>
"
"<p>Try <code>#include ""LiquidCrystal.h""</code></p>

<p>Or where is the library located?
Be sure the include specifies the location.</p>

<p>You might have to add the library location to your environment variables.</p>
"
"<p>I have an interesting situation.  I wonder if anyone can help?</p>

<p>I have:</p>

<ul>
<li>4x Arduino Micros loaded with the basic Blink sketch</li>
<li>5x <a href=""http://uk.rs-online.com/web/p/magnetic-buzzer-components/7243184/"" rel=""nofollow"">12 volt buzzers</a></li>
<li>A desk full of completely fresh Duracell AA and 9v batteries</li>
</ul>

<p>If I connect (using VIN and GND) any of the Arduino Micros to either a 9v battery, or a 12v network of 8 AA batteries, then they run the blink sketch, and the appropriate LED flashes on the Arduino as expected.</p>

<p>If I connect any of the buzzers to either a 9v battery, or a 12v network of 8 AA batteries, then they buzz as expected.</p>

<p>If I connect both a buzzer and an Arduino in parallel to either a 9v battery, or a 12v network of 8 AA batteries, then the Arduino works fine, <strong>but the buzzer makes barely an inaudible whimper</strong>.</p>

<p>If I connect only a buzzer to the Arduino and battery, it works fine.  If whilst the buzzer is buzzing I connect the Arduino, then on every ON or OFF of the blink sketch LED, the buzzer gets quieter and quieter until it can barely be heard.</p>

<p>These buzzers are rated to work at 25mA, so it really astounds me that they can't be run off a battery together with an Arduino.</p>

<p>Any help would be appreciated!</p>

<p>Thanks</p>

<p>Dave</p>
"
"<p>I am using the following code to send an IR signal:</p>

<pre><code>#include &lt;IRremote.h&gt;
 IRsend irsend;

void setup() {

}

void loop() {

    unsigned int IRsignal[] = {86,88,86,88,174,86,88,88,86,88,86,86,88,86,88,86,88,174,86,88,174,86,88,2336,90,86,88,86,174,88,86,88,86,88,86,88,86,88,86,88,86,174,88,86,174,88,86,0};

    irsend.sendRaw(IRsignal, 48, 40);

    delay(3000);

}
</code></pre>

<p>However, when I attach an IR receiver to another Arduino and take a look at the signal that is produced by the code above, I see this:</p>

<p>Received: </p>

<pre><code>OFF     ON
332 usec, 460 usec
1040 usec, 280 usec
2680 usec, 260 usec
820 usec, 80 usec
400 usec, 260 usec
int IRsignal[] = {
// ON, OFF (in 10's of microseconds)
    46, 104,
    28, 268,
    26, 82,
    8, 40,
    26, 0};


Received: 

OFF     ON
39228 usec, 280 usec
1160 usec, 340 usec
2460 usec, 480 usec
440 usec, 500 usec
340 usec, 260 usec
int IRsignal[] = {
// ON, OFF (in 10's of microseconds)
    28, 116,
    34, 246,
    48, 44,
    50, 34,
    26, 0};
</code></pre>

<p>These numbers are not even close to the ones that are going in.  There are far few pulses recorded, the duration is very inconsistent (the original code is almost entirely made up of 880-860um pulses) and even close to the original values.  I must have made a serious mistake here.  What happened?</p>

<p>UPDATE ========================== </p>

<p>I multiplied all of the values in the array by 10 and attempted to play/read the values using another Adruino with an IR sensor.  I started to see better results.  each pulse time was close to 88, 86, or 174 but they are still off by up to 10%.  The related IR device is still unresponsive.  Is there any other way to improve this?</p>

<pre><code>Received: 

OFF     ON
29828 usec, 860 usec
900 usec, 820 usec
880 usec, 1700 usec
880 usec, 860 usec
880 usec, 840 usec
940 usec, 760 usec
840 usec, 880 usec
860 usec, 880 usec
860 usec, 860 usec
1740 usec, 840 usec
880 usec, 1700 usec
880 usec, 840 usec
6920 usec, 880 usec
860 usec, 860 usec
880 usec, 1680 usec
880 usec, 860 usec
900 usec, 820 usec
900 usec, 820 usec
880 usec, 840 usec
860 usec, 840 usec
960 usec, 740 usec
1760 usec, 880 usec
920 usec, 1620 usec
900 usec, 10680 usec
13580 usec, 8580 usec
8820 usec, 8680 usec
int IRsignal[] = {
// ON, OFF (in 10's of microseconds)
    86, 90,
    82, 88,
    170, 88,
    86, 88,
    84, 94,
    76, 84,
    88, 86,
    88, 86,
    86, 174,
    84, 88,
    170, 88,
    84, 692,
    88, 86,
    86, 88,
    168, 88,
    86, 90,
    82, 90,
    82, 88,
    84, 86,
    84, 96,
    74, 176,
    88, 92,
    162, 90,
    1068, 1358,
    858, 882,
    868, 0};
</code></pre>
"
"<p>i am working on this arduino project using processing. There are some sensor values which should be logged, but unfortunately my processing code rewrites the file after each cycle so that i get the last sensor value only. How do i prevent this from happening? I am using the ordinary method by the way. PrintWriter command followed by createWriter</p>
"
"<p>Attach your voltmeter across the battery, and measure the available voltage when different things are attached; or attach it in series, and measure current draws.  You probably will find that a 9V battery's voltage is under 8 volts when a mix of multiple Arduinos and buzzers is attached.  That voltage may be too low to activate the buzzer.</p>

<p>A powerstream.com web page called <em><a href=""http://www.powerstream.com/9V-Alkaline-tests.htm"" rel=""nofollow"">9V Alkaline tests</a></em> shows how rapidly a 9V battery's voltage drops when heavy currents (more than a few dozen milliamps) are drawn from it, and a batteriesinaflash.com <a href=""http://www.batteriesinaflash.com/lithium/9v/12x-ultralife-9v-lithium-battery-1200mah-for-alarm-home-safety"" rel=""nofollow"">web page</a> includes the following diagram that shows battery voltage quickly falling below 8.5 V in its first minutes of life when 27 mA is drawn from it. <img src=""http://i.stack.imgur.com/egLKW.gif"" alt=""9v-lithium-comparison.gif""></p>

<p>For some models of Arduino, eg the <a href=""http://arduino.cc/en/main/arduinoBoardUno"" rel=""nofollow"">Uno R3</a>, various <a href=""http://forum.arduino.cc/index.php?topic=5536.0"" rel=""nofollow"">posts on the web</a> list currents from 25 mA up to 45 mA, depending on LED and sleep settings.  Currents for the <a href=""http://arduino.cc/en/Main/arduinoBoardDuemilanove"" rel=""nofollow"">Duemilanove</a> from 10 mA up are reported.  The <a href=""http://arduino.cc/en/Main/arduinoBoardMicro"" rel=""nofollow"">Arduino Micros</a> in your tests probably use a little more current than <a href=""http://arduino.cc/en/Main/arduinoBoardProMini"" rel=""nofollow"">Pro Mini</a> boards (which have no USB), and although it's unlikely they will use as much or more current than the buzzers, they still may drag the voltage down to a level where the buzzers won't work.</p>

<p>If your system needs to be battery powered, consider using separate batteries for different devices, to avoid problems like you saw.  Alternatively, use heavier-duty batteries, eg <a href=""https://en.wikipedia.org/wiki/List_of_battery_sizes#Cylindrical_lithium-ion_rechargeable"" rel=""nofollow"">good-sized lithium-polymer units</a>.  Also review posts about decreasing Arduino power usage via sleep, disconnecting the power LED, and using large capacitors to buffer power surges.</p>

<p><em>Edit:</em> Given that voltage measurements show enough voltage being available, the suggested use of capacitors or inductors to isolate circuits may be a good idea.  </p>

<p>When adding a capacitor, locate it physically close to the power-using board or component.  For electrolytic  capacitors, attach the capacitor's + terminal to the high side, eg to the +5, +9, or +12 side, and attach its - terminal to ground.</p>

<p>When adding ferrite beads, wrap the supply wire through the bead several times, if there's room.  The picture below illustrates the idea.  </p>

<p>An electrolytic capacitor across a circuit acts as a voltage reservoir.  It also gives high-frequency signals an easy path to ground, reducing interference.  A ferrite bead or other inductor impedes high frequency signals, again reducing interference.</p>

<p><img src=""http://i.stack.imgur.com/T9qkj.jpg"" alt=""enter image description here""></p>
"
"<p><code>PrintWriter pw = new PrintWriter(new FileOutputStream(
    new File(""persons.txt""), 
    true /* append = true */));</code></p>

<p>The <code>true</code> is the append mode flag.
Also check if you're using </p>

<p><code>pw.append(p.toString());
        pw.append(""sdf"");</code></p>

<p><a href=""http://stackoverflow.com/questions/8210616/printwriter-append-method-not-appending"">http://stackoverflow.com/questions/8210616/printwriter-append-method-not-appending</a></p>
"
"<p>This seems to be a general problem of the Arduino IDE: It only recognizes libraries that are included in the (primary) <code>.ino</code> file. </p>

<p>If you look at the invocation of the compiler, the path to any given library is only added if this library's header file is included in the <code>.ino</code> file. </p>

<p>I tested this with the EEPROM library. If this library is included in the <code>.ino</code> file, the compiler is called with</p>

<pre><code>avr-g++ -c -g -Os -Wall -fno-exceptions -ffunction-sections -fdata-sections -mmcu=atmega328p -DF_CPU=16000000L -DARDUINO=100 -I/usr/share/arduino/hardware/arduino/cores/arduino -I/usr/share/arduino/hardware/arduino/variants/eightanaloginputs -I/usr/share/arduino/libraries/EEPROM /tmp/build2678545434708654378.tmp/test.cpp -o/tmp/build2678545434708654378.tmp/test.cpp.o 
</code></pre>

<p>where the important part is the <code>-I/usr/share/arduino/libraries/EEPROM</code>. </p>

<p>If I now remove <code>#include &lt;EEPROM.h&gt;</code> (but still have it in another header file which in turn is included in the <code>.ino</code> as in your case), the compiler call changes to</p>

<pre><code>avr-g++ -c -g -Os -Wall -fno-exceptions -ffunction-sections -fdata-sections -mmcu=atmega328p -DF_CPU=16000000L -DARDUINO=100 -I/usr/share/arduino/hardware/arduino/cores/arduino -I/usr/share/arduino/hardware/arduino/variants/eightanaloginputs /tmp/build2678545434708654378.tmp/test.cpp -o/tmp/build2678545434708654378.tmp/test.cpp.o
</code></pre>

<p>where now the include path to the library is missing.</p>

<h2>TL;DR</h2>

<p>If you need to use a library, just (also) add an include to the <code>.ino</code> file. It doesn't cost you anything and will solve your problem ;)</p>

<hr>

<h3><code>#include &lt;file&gt;</code> vs. <code>#include ""file""</code></h3>

<p>From the <a href=""https://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html"" rel=""nofollow"">gcc documentation</a>:</p>

<ul>
<li><em>#include &lt;file></em> is used for system header files. It searches for a file named file in a standard list of system directories. [...]</li>
<li><em>#include ""file""</em> is used for header files of your own program. It searches for a file named file first in the directory containing the current file, then in the quote directories and then the same directories used for &lt;file>. [...]</li>
</ul>
"
"<p>I am running small project. I wanted to use Arduino Mega 2560 v3, PIR sensor, microSD card module and RTC1307 module, some leds, buttons and buzzer. To enable and disable motion detection and when detection is found the time is saving to sd card. I wired everything together coded and started to testing. During test Arduino on bootup was restarting over and over. Firtstly I was thinking that the problem is in the breadboard and connection. I check it few times and I didn't notice anything wrong. So I check code over and over. Still nothing. So I started to testing modules. And I found a problem. When I don't use in sketch RTC or SD card (physical they are still connected, because I am lazy) everything works fine. Arduino don't restart. I didnt use SD to write data, instead I use serial port to show data. Everything works fine I can saw at what time is motion detected and arduino print it on terminal. Second scenario I didn’t use RTC only SD module. This time again everything works fine. On SD card I could read how many times motion was detected. This is weird because when I mix all together it doesn't work.  </p>

<p>Here is my code:</p>

<pre><code>// *********************************************
// INCLUDE
// *********************************************
#include &lt;Wire.h&gt;                    
#include &lt;SD.h&gt;
#include &lt;SPI.h&gt;
#include ""RTClib.h""
// *********************************************
// DEFINE
// *********************************************
#define GREENLED 39
#define BTNON 11 
#define REDLED 41
#define BTNOFF 9 
#define BUZZ 3 
#define PIR_PIN 10 
//SD (na mega)
#define SD_CLK_SD 52
#define SD_MI 50
#define SD_MO 51
#define SD_CS 4

//RTC 
#define RTC_SDA 20
#define RTC_SCL 21
#define RTC_DS 2

// *********************************************
// VARIABLES
// *********************************************
RTC_DS1307 rtc;
File myFile;
char godz[8];
char data[5];

int btnON;
int btnOFF;
int pirD;
bool stan_alarmu;


void wlAlarmu(){
  digitalWrite(REDLED,LOW);
  digitalWrite(GREENLED, HIGH);
  stan_alarmu=true;
  gettime();
  myFile = SD.open(""dane.txt"", FILE_WRITE);
  if (myFile) {
    myFile.print(""### Wlaczenie alarmu ### "");
    myFile.print("" "");
    myFile.print(godz);
    myFile.print(data);
    myFile.println("""");
    myFile.close();
  }
}

void wylAlarmu(){
  digitalWrite(GREENLED, LOW);
  digitalWrite(REDLED,HIGH);
  stan_alarmu=false;
  gettime();
  myFile = SD.open(""dane.txt"", FILE_WRITE);
  if (myFile) {
    myFile.print(""### Wylaczenie alarmu ### "");
    myFile.print("" "");
    myFile.print(godz);
    myFile.print(data);
    myFile.println("""");
    myFile.close();
  }
}

void alarm(){
  digitalWrite(GREENLED,LOW);
  digitalWrite(REDLED,HIGH);
  digitalWrite(BUZZ,HIGH);
  delay(500);
  digitalWrite(BUZZ,LOW);

  gettime();
  myFile = SD.open(""dane.txt"", FILE_WRITE);
  if (myFile) {
    myFile.print(""Alarm: "");
    myFile.print("" "");
    myFile.print(godz);
    myFile.print(data);
    myFile.println("""");
    myFile.close();
  }
  delay(5000);
  digitalWrite(REDLED,LOW);
  digitalWrite(GREENLED,HIGH);
}
void blad(){
  while(1){
    digitalWrite(REDLED,HIGH);
    delay(500);
    digitalWrite(REDLED,LOW);
    delay(500);
  }
}
void gettime(){
  DateTime now = rtc.now();
  sprintf(godz,""%02d:%02d:%02d "",now.hour(),now.minute(),now.second());
  sprintf(data,""%d.%d"",now.day(),now.month());
}

// *********************************************
// SETUP
// *********************************************
void setup() {
  //RTC
  Wire.begin(); // Shield I2C pins connect to alt I2C bus on Arduino Due
  rtc.begin();

  if (! rtc.isrunning()) {
    blad();
    // following line sets the RTC to the date &amp; time this sketch was compiled
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    // This line sets the RTC with an explicit date &amp; time, for example to set
    // January 21, 2014 at 3am you would call:
    // rtc.adjust(DateTime(2014, 1, 21, 3, 0, 0));
  }
  pinMode(BTNON,INPUT);
  pinMode(GREENLED, OUTPUT);
  pinMode(BTNOFF,INPUT);
  pinMode(REDLED, OUTPUT);
  pinMode(PIR_PIN,INPUT);
  pinMode(BUZZ,OUTPUT);

  //test seq
  digitalWrite(GREENLED,HIGH);
  digitalWrite(REDLED,HIGH);
  digitalWrite(BUZZ,HIGH);
  delay(100);
  digitalWrite(BUZZ,LOW);
  digitalWrite(GREENLED,LOW);
  digitalWrite(REDLED,LOW);

  delay(500);  
  pinMode(SD_CS, OUTPUT);

  if (!SD.begin(SD_CS)) {
    blad();
  }
  digitalWrite(GREENLED,HIGH);
  delay(1000);
  digitalWrite(GREENLED,LOW);

  gettime();
  Serial.begin(9600);

  myFile = SD.open(""dane.txt"", FILE_WRITE);
  if (myFile) {
    myFile.print(""####START SYSTEMU: "");
    myFile.print(godz);
    myFile.print(data);
    myFile.print("" ####"");
    myFile.println("""");
    myFile.close();
  }
  wylAlarmu();
}

void loop() {  
  btnON = digitalRead(BTNON);
  btnOFF = digitalRead(BTNOFF); 
  pirD = digitalRead(PIR_PIN);

  if(btnON == HIGH){
    wlAlarmu();
    delay(2000);
  }
  if(btnOFF == HIGH){
    wylAlarmu();
    delay(2000);
  }

  if(pirD==HIGH &amp;&amp; stan_alarmu==true){
    alarm();
  }

  delay(1000);
}
</code></pre>
"
"<p>I like having serial communication for debugging and testing purposes but after a while it takes away too much speed from the sketch. </p>

<p>Is it possible to have the Arduino ignore serial.print and serial.println throughout my code, without turning it into a comment or placing every serial printing inside for example ""if(debug == true)"" statements?</p>

<p>Thanks in advance.</p>
"
"<p>If you insist on top performance, the best thing would be to use a macro for that:</p>

<pre><code>#define Sprintln(a) (Serial.println(a))
</code></pre>

<p>Then instead of </p>

<pre><code>Serial.println(F(""Hello world!""));
</code></pre>

<p>write </p>

<pre><code>Sprintln(F(""Hello world!""));
</code></pre>

<p>etc. To deactivate the <code>Serial</code> printing, define the macro empty:</p>

<pre><code>#define Sprintln(a) 
</code></pre>

<p>This will have the preprocessor remove all debugging code defined with <code>Sprintln</code> from your code.</p>

<p>(Of course, there's a huge number of variations on this theme.)</p>
"
"<p>You could, for example, use the preprocessor to change all <code>Serial</code> in your code.</p>

<pre><code>#ifndef ENABLE_PRINT
// disable Serial output
#define Serial SomeOtherwiseUnusedName
static class {
public:
    void begin(...) {}
    void print(...) {}
    void println(...) {}
} Serial;
#endif
</code></pre>
"
"<p>I have a specific problem :</p>

<ol>
<li><p>I'm working on a testing platform. It has to be absolutely isolated, so I cannot wire it back to my PC. I again reiterate it. There is no way to wire it to my PC. IT HAS TO BE ABSOLUTELY ISOLATED</p></li>
<li><p>It has about 10 different sensors on it and I need to read sensor's data simultaneously at 100Hz.  It is currently working fine with 16Hz, but I need to improve it further, so I think maybe in future sampling rates higher than 100 is beneficial. 7 Hz is the lowest possible value that doesn't botch the whole things up.</p></li>
<li><p>I have a laptop on the platform which reads the sensor data via RS232, then it processes them in a fraction of a second and produce a control signal and send it to the actuators. It has to happen at real-time. Control algorithm is not heavy, it is several PIDs.</p></li>
<li><p>It has 6 actuators with the fastest possible reaction time of 0.005 second.</p></li>
<li><p>The main sensor currently is <a href=""http://www.microstrain.com/inertial/3DM-GX1"" rel=""nofollow"">Microstrain 3DM-GX1</a>. It is a very good sensors.</p></li>
<li><p>I want to add a <a href=""http://www.forkrobotics.com/2013/06/using-the-gy80-10dof-module-with-arduino/"" rel=""nofollow"">GY-80</a> sensor in parallel to 3DM-GX1. I want to test various filtering algorithms on the GY-80's output and compare them to 3DM-GX1.</p></li>
<li><p>Platform has 6 degrees of freedom so I think laser transmission is not practical.</p></li>
<li><p>Distance between the computer and the platform is at most 3 meters.</p></li>
</ol>

<p>For some reasons I am not able to use the laptop anymore. I want to read the sensor's data with an Arduino, preferably Arduino Mega 2560. My problem is that I don't want to load the control algorithm to the Arduino.</p>

<p>IMHO the perfect solution is going to be a Wireless link between the Sensors via Arduino to my PC. This way my PC logs data and also the Control Algorithm can promptly calculate the feedback signal and send it to Arduino which will send them to the actuators. This immensely makes things easier for me. </p>

<p>I think I need a RS232 shield for the 3DM-GX1 &amp; Arduino, + some wireless solution for sending data from both sensors to my computer. Then I need to send back the control signal back to the actuators wirelessly. </p>

<p>Now what is the fast and easy way to transmit the data between PC and Arduino in real-time?</p>

<p>Thank you in advance!</p>
"
"<p>Looking further here</p>

<p><a href=""http://forum.arduino.cc/index.php/topic,188236.0.h"" rel=""nofollow"">http://forum.arduino.cc/index.php/topic,188236.0.h</a>...</p>

<p>I found the following</p>

<p>""Removing 
the files - libraries\RobotIRremote\IRremoteTools.cpp and 
libraries\RobotIRremote\IRremoteTools.h solved the problem. They are
example files which somehow are getting included. You can move those two 
files to some other location as backup.""</p>

<p>I went to my libraries 
file and did this and can confirm that the example given above then 
compiles fine without downloading a new library. Its an Arduino 
libraries problem .</p>

<p>Either way will work</p>

<p><a href=""http://www.instructables.com/id/Remote-Control-Light-switch-ARDUINO/"" rel=""nofollow"">answer from here and worked for me</a></p>

<p>i use this code:</p>

<pre><code>#include &lt;IRremote.h&gt;
int input_pin = 10; //set D10 as input signal pin
IRrecv irrecv(input_pin);
decode_results signals;
void setup()
{
    Serial.begin(9600);
    irrecv.enableIRIn(); // enable input from IR receiver
}
void loop() {
if (irrecv.decode(&amp;signals)) {
        Serial.println(signals.value, HEX);
        irrecv.resume(); // get the next signal
    }
}
</code></pre>
"
"<p>I need to put my arduino into the sleep mode in order to consume less power. My arduino receives IR data and do some work with it, but I need to make it sleep until there is no data. If the data has appeared it should wake up and do something with data and go back to sleep mode.<br>
Is there any way to do this.<br>
I would be grateful for any help.</p>
"
"<p>Connect the IR receiver to INT0 or INT1 (pins 2 or 3 respectively). You can use the <a href=""http://arduino.cc/en/Reference/attachInterrupt"" rel=""nofollow"">attachInterrupt</a> function. E.g. attachInterrupt(0, yourfunctionname, LOW). The function being called can be empty, if you only use it to wake up the MCU.</p>

<p>To wake from sleep you need to use the LOW trigger mode. Once waken up you probably want to remove the interrupt handler (<code>detachInterrupt</code>), or it will swamp the cpu with interrupts.</p>

<p>(Note that most IR receiver will still use something like 3mA.)</p>
"
"<p>I have this array of bytes, that I need to convert to an array of unsigned ints. Also the function (<code>btea</code>) that needs it, seems to need a pointer. </p>

<p>I'm currently using <code>reinterpret_cast</code> which seems to work, but I'd like to know how/why. I'm pretty new to <code>C</code>. It also seems kind of dirty. I could use a for loop, and bitshift everything into a separate int array variable, but that seems wasteful.</p>

<pre><code>uint8_t data[] = {1,2,3,4,5,6,7,8};//can be any multiple of 4 bytes

btea(reinterpret_cast&lt;uint32_t*&gt;(data), sizeof(data)/4, encryption_key);

radio.write(data, sizeof(data));

...

void btea(uint32_t *v, int n)
{
  ...
}
</code></pre>

<p>Any pointers (pun intended) are much appreciated.</p>
"
"<p>I prefer to use unions. example:</p>

<pre><code>union fourbyte {
  uint32_t dword;
  uint16_t word[2];
  uint8_t  byte[4];
};

union fourbyte val;

val.dword = 0x03020100;

Serial.println(val.byte[0], HEX);
Serial.println(val.byte[1], HEX);
Serial.println(val.byte[2], HEX);
Serial.println(val.byte[3], HEX);

Serial.println(val.word[0], HEX);
Serial.println(val.word[1], HEX);

Serial.println(val.dword, HEX);
</code></pre>
"
"<p>The answer is :</p>

<p>I combined all my </p>

<pre><code>client.println(""&lt;b&gt;&lt;font size=+1 color='#CC33FF'&gt;Some text here&lt;/font&gt;&lt;/b&gt;&lt;br/&gt;"");
</code></pre>

<p>html statements into much longer statements eg</p>

<pre><code>client.println(""&lt;b&gt;&lt;font size=+1 color='#CC33FF'&gt;Some text here&lt;/font&gt;&lt;/b&gt;&lt;br/&gt;&lt;a href=\'?s4-all-on' target='x2'&gt;All On&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href='/?s4-all-off' target='x2'&gt;All Off&lt;/a&gt;&lt;br/&gt;&lt;a href='/?s4-1on' target='x2'&gt;Socket 1 On&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href='/?s4-1off' target='x2'&gt;Socket 1 Off&lt;/a&gt;&lt;br/&gt;""); 
</code></pre>

<p>This reduced the number of client.println(""  "");  statements by about one third, which resolved the issue.</p>
"
"<p>What should I do to have an Arduino Pro Mini 5V (clone) powered by a 5V solar panel during the day and by battery during night which will be charged during the day by the solar panels.</p>

<ul>
<li>is there any guide out there?</li>
<li>is it possible with the 5V version of Arduino Pro Mini or will I have to buy the 3.3V</li>
<li>I prefer to make the circuits by myself rather than buying them (for example: the charging circuit.)</li>
</ul>
"
"<p>I have an Arduino Uno R3 and when I pluged into any computer the computer doesn't recognized the arduino, I checked up and the LEDs are working fine and when I open the device manager It doesn't show any <code>Unkown Device</code>, what it could be? Could the ATmega be dead? I tried on two windows 7 and one linux, both didn't recognized the arduino.</p>
"
"<p>@mpflaga's answer gives a great alternative, but I thought I'd explain why your code works (grossly simplified). </p>

<p>All the reinterpret cast does is let the compiler know how wide of a variable it assumes is in each element of the array.  When you access <code>data[1]</code>, it uses one byte at an offset of one byte from <code>data[0]</code>.  When you cast to uint32_t and access <code>data[1]</code>, it uses 4 bytes at an offset of 4 bytes. </p>

<p>If your memory looks like this (each square is one byte)...  </p>

<p><img src=""http://i.stack.imgur.com/gec1a.png"" alt=""enter image description here""></p>

<p>...before the cast you are interpreting it as the top layout, after the cast you interpret it as the bottom layout.  It's still exactly the same in memory, you're just telling the compiler to use it differently. The reason that using a union is better is that it is safer.  Your code would read garbage after the end of the array if its length <em>wasn't</em> divisible by 4.</p>

<p>One other quick note, be careful with the sizeof() operator on arrays - it always gives the length in bytes regardless of the element size.</p>
"
"<p>The reason that it is not connecting can be anything from wrong driver installation to the dead Atmega 16u2 chip. But I must exclude the former option as you said you'd tried on different OS and different computers. So double check the driver installation. And if does not work try to find out whether Atmega16u2 is fried or not. One solution might be to reflash the original firmware through an external ICSP programmer. If don't have any programmer but another arduino uno you might try out the gamon's tutorial on flashing firmware on the little USB to serial interface chip.
Anyway if your arduino is new and official you can get the right support online on arduino.cc. but if it is a clone you may try to contact the reseller whom you bought from.</p>
"
"<p>This would be better answered on Stack Exchange Electrical Engineering.</p>

<p>Also <a href=""http://arduino.stackexchange.com/questions/665/powering-arduino-with-solar-panels?rq=1"">see this question and answers</a>. This is not quite the same and the answers there are OK but less than complete or correct, but it adds to the resource available. </p>

<p>You need a battery charging controller, a PV (solar) panel capable of producing somewhat more than maximum battery voltage and enough energy to operate your circuit and a battery with enough voltage to operate the device and enough capacity to store the energy.</p>

<p>Current drain will vary with total circuit. You can measure this will a milliammeter. I'll assume that 50 mA continuous will be enough. Less or much less may suffice. I have a pro mini clone operating at 20 mA on 5V at present and with due care you may be able to operate one with less or much less current depending on application and what your circuit needs are.</p>

<p>Looking at solar current needs at present, the average solar current needed is about Icircuit x 24/SSH mA where SSH = average sunshine hours per day. eg if you had 4 hours of sunshine per day but want to run the circuit for 24 hours a day the sun must provide (24 hours per day)/(4 hours of sun) = 6 x as much current as the circuit needs on average. So if your circuit needs 50 mA continuous the PV panel must provide 6 x 50 mA = 300 mA for 4 hours per day. You will see below that this is not a trivial amount. </p>

<p>Sunshine hours per day may be found for sites worldwide using the excellent www.gaisma.com The <a href=""http://www.gaisma.com/en/location/iraklion.html""><strong>average sunshine hours per day for Iráklion</strong></a> may be found at that link and other locations in Greece can be found <a href=""http://www.gaisma.com/en/dir/gr-country.html""><strong>here</strong></a> but will probably be similar.<br>
For Iráklion the SSH may be found in the 1st line of the 4th chart.<br>
Average hours/day of equivalent full sunshine = kWh/m^2/day = a peak of 8.53 hours in June and a low of 2.08 hours in December.<br>
Wow! 
I think that is about as sunny a place in Summer as anywhere on earth not in the polar regions.  In Winter it gets about the same SSH as in <a href=""http://www.gaisma.com/en/location/manukau.html"">my city</a>. You can calculate PV sizing for peak summer - but if you want year round operation you should use the worst case winter month and add a bit for bad days.<br>
For Iraklion us say 2 SSH per day so the panels needs to provide 24/2 = 12 x winter average load. So per 10 mA of load yo need 120 mA of panel and if the mean load is 50 mA you need 12 x 50 = 300 mA panel output.</p>

<p>Battery voltage needs to be > 5V at all times.<br>
An easy cheap available starting solution is to use a 6B lead acid battery.
These are easyish to charge and provide a relatively stable operating voltage.<br>
Vmax_charge is <strong>about</strong> 7V so an 8V or 9V PV panel is ""about right"". 9V is a common voltage for hobby applications. An alternative is to use a 12V panel. this is probably more suitable as they are widely available and cost per energy out is often lower. This wastes MOST of the panel output but still MAY be the cheapest option in many cases. (A 12V x 600 mA panel is rated at about 18V x 0.6A ~= 10 Watts. Actual Arduino load = 50 mA x 5V x 12:1 = 3 Watts) </p>

<p>At 50 mA load you need 24/2 x 50 mA = 600 mA PV output in full sun.<br>
PV panel sizing is not as may be expected. It is easiest to get a panel that makes at least enough voltage and enough current. This is because panel RATED voltages are usually higher than the voltages they are used at. eg 12V system PV panels are usually rated at 18V max power voltage- so an 18W panel provide 18V at 1 A BUT if attached directly to a 12V battery the input to the battery = 12V x 1A = 12 Watts. There are ways around this but at first, just concentrate on panel mA.</p>

<p>So, you ""need"" a 600 mA panel for a 50 mA load.<br>
Or a 60 mA panel for a 5 mA load.<br>
Or a 6 mA panel for a 0.5 mA load.<br>
Obviously, reducing load current is going to help panel sizing.<br>
So knowing what your application really needs is essential.</p>

<p>Batery is easier.<br>
If you use 6V lead acid then for one day you need.<br>
Hours x load = mAh.<br>
Here load=24 hours. mA = 50 in this example.<br>
mAh = 24 x 50 mA =  1200 mAh = 1.2 Ah. This is the capacity of about the smallest LA battery commonly available. In practice you want to discharge your battery by only a small % of its actual capacity so use a 2.4 Ah or 3.5 Ah or larger. 7Ah is not vastly dearer and will last far longer and will have several days of reserve capacity for bad weather.</p>

<p>Charging can now be discussed - but I'll stop here and see what is said about the above. We can add charging and other detail if it seems useful to do so. </p>

<p><img src=""http://i.stack.imgur.com/F3oG9.jpg"" alt=""enter image description here""></p>

<p>An easy battery to use is 2 x LiIon or LiPo cells in series. </p>
"
"<p>Does using the delay function use any less power than spinning in a polling loop on a timer?</p>
"
"<p>The answer is probably ""they are equal"" because what the CPU is doing is less than 1% of power draw. In order to save power while waiting you can put the chip to sleep. Assuming you have an Arduino uno, this post contains sample code about sleeping and current consumption. <a href=""http://forum.arduino.cc/index.php?topic=78430.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=78430.0</a></p>

<p>Maybe explain what you are doing (what size battery you have) and we can add some advice about ways to save power </p>
"
"<p>Cypress makes very small usb chips capable of host mode. Does this board meet your size requirements? <a href=""http://www.mouser.com/ProductDetail/Cypress-Semiconductor/CY8CKIT-049-41XX/?qs=FSHIiqjonm0YmFbmBQfo1A%3D%3D&amp;kpid=1159933375&amp;gclid=CPjl6KOm4cQCFYGUfgodJh4A_g"" rel=""nofollow"">http://www.mouser.com/ProductDetail/Cypress-Semiconductor/CY8CKIT-049-41XX/?qs=FSHIiqjonm0YmFbmBQfo1A%3D%3D&amp;kpid=1159933375&amp;gclid=CPjl6KOm4cQCFYGUfgodJh4A_g</a></p>

<p>You may also consider ditching the arduino and running everything on the cypress</p>
"
"<p>The fastest way would be to use a laser link!! Yeah lasers. You could go with wifi or some other custom wireless but lasers will guarantee the highest energy density and therefor best bandwidth.  This guy claims near 10 MB/s with his setup:</p>

<p><a href=""http://www.instructables.com/id/Laser-Transceiver/"" rel=""nofollow"">http://www.instructables.com/id/Laser-Transceiver/</a></p>
"
"<p>Does anyone know if you can set the time for the timeout Ethernet Shield library? Let me explain:</p>

<p>I created a very simple function (below) that attempts to connect to an address if it is not accessible returns 0 if it is available returns 1. Problem is that when the site is not available, the microcontroller is waiting for an answer for a long time, wanted to reduce it.</p>

<pre><code>uint8_t ping(const char* address)
{
    EthernetClient http;

    if(http.connect(address, 80)) {
        http.stop();
        return 1;
    }
    else 
        return 0;
}
</code></pre>
"
"<p>In the stream class there is a setTimeout(ms) function. e.g.</p>

<pre><code>String str;
Serial.setTimeout(5000) ;
str = Serial.readStringUntil('\r');
</code></pre>

<p>Where this does timeout the initial connection attempt in http.connect(). Whereas I found it also important to timeout each line, as a web page may not disconnect at the end or not send anything.</p>

<pre><code>int httpGetHeaders() {
  String request, response;
  int result = 0;
  long startOfHttpResponseTime;

  client.setTimeout(1000) ;
  response = """";
  inHeaders = true;
  startOfHttpResponseTime = millis();
  while((client.connected()) &amp;&amp; inHeaders &amp;&amp; ((long)(millis() - startOfHttpResponseTime) &lt; HTTP_RESPONSE_TIMEOUT)) {
    String header = client.readStringUntil('\n');
    header.trim(); // trim off white spaces including CR and LF at end.
    Serial.print(F(""head["")); 
    Serial.print(header.length()); 
    Serial.print(F(""]:\"""")); 
    Serial.print(header);
    Serial.println(F(""\"""")); 
    if (!header.length()) { // first blank line indicates end of headers
      inHeaders = false;
      Serial.println(F(""No longer in Headers"")); 
    }
    else {
      if (header.startsWith(""HTTP"")) {
        Serial.println(F(""HTTP Found"")); 
        int firstspace = header.indexOf("" "");
        result = header.substring(firstspace + 1, header.indexOf("" "", firstspace + 1)).toInt();
        Serial.print(F(""result = "")); 
        Serial.println(result); 
      }
    }
  }

  Serial.print(F(""Result code = ""));
  Serial.println(result);
  return result;
}
</code></pre>

<p>You may want to review the whole code at <a href=""https://github.com/lansing-makers-network/StatusBotArduino/blob/master/StatusBotArduino.ino"" rel=""nofollow"">https://github.com/lansing-makers-network/StatusBotArduino/blob/master/StatusBotArduino.ino</a> I have reduced the connection to a sequence of commands that can be used consectutively in the desired order to meet different needs. The above is just to read a headers response.</p>
"
"<p>I have a functionality on my mega 2560 to connect with other devices. Sometimes, devices can't answer. I don't want to wait for a longwhile. So, how can I interrupt the chunk of program after the specific amount of time? </p>

<p>My code for receiving messages is:</p>

<pre><code>while (!(UCSR1A &amp; (1&lt;&lt;RXC1)));
</code></pre>

<p>so, <code>millis</code> can't solve my problem because I haven't ability to check for conditional loops like that</p>

<pre><code>if(currentMillis - previousMillis &gt; interval) {
</code></pre>
"
"<p>OMG, I was stupid. I can just place millis in this <code>while</code> condition.</p>
"
"<p>I'm trying to connect my Arduino Uno with MySQL.</p>

<p>This is my code:</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;sha1.h&gt;
#include &lt;mysql.h&gt;

/* Setup for Ethernet Library */
byte mac_addr[] = { 0xC8, 0x0A, 0xA9, 0xAF, 0x83, 0x58 }; 
IPAddress server_addr(192,168,0,102);

/* Setup for the Connector/Arduino */
Connector my_conn; // The Connector/Arduino reference
char user[] = ""root"";
char password[] = ""fifa2005"";
char INSERT_SQL[] = ""INSERT INTO test_arduino.hello VALUES ('Hello from Arduino!', NULL)"";

void setup() {
Ethernet.begin(mac_addr);
Serial.begin(115200);
delay(1000);
Serial.println(""Connecting..."");
if (my_conn.mysql_connect(server_addr, 3306, user, password))
delay(500);
else
Serial.println(""Connection failed."");
}

void loop() {
}
</code></pre>

<p>I have the following database:</p>

<pre><code>mysql&gt; CREATE DATABASE test_arduino;
Query OK, 1 row affected (0.00 sec)
mysql&gt; USE test_arduino;
Database changed
mysql&gt; CREATE TABLE hello (source char(20), event_date timestamp);
Query OK, 0 rows affected (0.01 sec)
</code></pre>

<p>This is the output message: </p>

<pre><code>Connecting... Connection failed.
</code></pre>

<p>I am not sure this is the right IP address: <code>192,168,0,102</code>. I tried with the localhost IP address - <code>127.0.0.1</code>, but nothing happened.</p>
"
"<p>I am trying to build a quadcopter using an arduino. I Bought 4 30A ESC's from Ebay the link is <a href=""http://www.ebay.co.uk/itm/4pcs-Brushless-speed-controller-ESC-MultiCopter-KK-Quad-rotor-X-copter-30A-S-/310950293677?pt=LH_DefaultDomain_3&amp;hash=item486614f0ad"" rel=""nofollow"">http://www.ebay.co.uk/itm/4pcs-Brushless-speed-controller-ESC-MultiCopter-KK-Quad-rotor-X-copter-30A-S-/310950293677?pt=LH_DefaultDomain_3&amp;hash=item486614f0ad</a> and a A2212 2200KV motor, im also using a sparkfun arduino uno. I have connected the white (data) servo wire of the ESC to pin 9 of my arduino and the black (ground) servo wire of the ESC to gnd of the arduino. When i connect the battery to the esc i get the 3 beeps because of my 3 cell battery regardless of what code is on the arduino even if the arduino is not present. the code that is on the arduino is. </p>

<pre><code>#include &lt;Servo.h&gt;

Servo motor;

void setup()
{
  Serial.begin(9600);
  motor.attach(0);
}
void loop()
{
  motor.write(100);
}
</code></pre>

<p>I'm not sure what is wrong. Can someone please help me.</p>
"
"<p>I have a <strong>Bluetooth device</strong> from Sparkfun which I would like to use with the <strong>Arduino Mega</strong>. If I connect the module via the hardware serial pin everything works fine but when I use other pins like 12 and 13 with <strong>SoftwareSerial</strong>, the communication doesn't work as expected.</p>

<p><strong>THE CODE</strong></p>

<pre><code>#include &lt;SoftwareSerial.h&gt;

int bluetoothTx = 12;
int bluetoothRx = 13;

SoftwareSerial bluetooth(bluetoothTx, bluetoothRx);

void setup()
{
  //Setup usb serial connection to computer
  Serial.begin(9600);

  //Setup Bluetooth serial connection to android
  bluetooth.begin(115200);
  bluetooth.print(""$$$"");
  delay(100);
  bluetooth.println(""U,9600,N"");
  bluetooth.begin(9600);
}

void loop()
{
  //Read from bluetooth and write to usb serial
  if(bluetooth.available())
  {
    char toSend = (char)bluetooth.read(); 
    Serial.print("" Receiving: "");
    Serial.println(toSend);
  }

  //Read from usb serial to bluetooth
  if(Serial.available())
  {
    char modeS = Serial.read(); 
    Serial.print("" Writing Blu: "");
    Serial.println(modeS);
    bluetooth.print(modeS);
  }
}
</code></pre>

<p>I'm using an Android App (BlueTerm) to test the communication.</p>

<p>Here is what I get when sending a letter from Android to Arduino.</p>

<pre><code> Receiving: ÿ
 Receiving: ÿ
 Receiving: ÿ
 Receiving: ÿ
 Writing Blu: d
 Writing Blu: d
 Writing Blu: d
</code></pre>

<p>I'm not able to receive anything from the Arduino.</p>

<p>I've tried decreasing the baudrate but nothing changed. Do you have any advice?</p>

<p><strong>Update</strong></p>

<p>I have tried without the following lines but nothing changed... It seems that the module can be used only with the hardware serial pins 0 and 1... It's a shame</p>

<pre><code>bluetooth.print(""$$$"");
delay(100);
bluetooth.println(""U,9600,N"");
bluetooth.begin(9600);
</code></pre>
"
"<p>That depends very much on how delay() was written (and how it will be written in the future!). There are ""sleep modes"", which will reduce the power consumption of the arduino - these are one of the best way to reduce power consumption. Delay() may or may not activate these. If not, there could be a replacement Delay() function that could do this.</p>

<p>If you want to reduce power, check out <a href=""http://www.gammon.com.au/power"" rel=""nofollow"">http://www.gammon.com.au/power</a> - this is an excellent step-by-step tutorial on how to reduce power consumption from 50mA down to 288 µA</p>
"
"<p>Can I charge a 4.2&nbsp;V battery with a 5&nbsp;V adapter without damaging the battery?</p>
"
"<p>Is it possible to hook up a GSM/GSRM module <em>AND</em> an SD card at the same time to an Arduino Uno, or any Arduino?</p>

<p>I want to build a cellphone to read off the buttons that are being dialed into it for a poor guy who has no hope of using a regular cellphone, and I figure I need to include wav files for the buttons (and any other functions) on an external source.</p>

<p>I'm a good programmer, so if I can hobble the parts together I can make them talk to each other.  But, I'm not so sure the different schemes for this all use the same pins, so I was wondering if someone would be so kind as to enlighten me..</p>
"
"<p>I have a string which I send to the arduino using serial monitor. Something like that:</p>

<pre><code>my specific string 0x0F 0x2C 0x98 0xBC
</code></pre>

<p>How can I parse this string in the arduino to get an array of hex values:</p>

<pre><code>0x0F 0x2C 0x98 0xBD
</code></pre>

<p>? There are two prerequisites:</p>

<ol>
<li>All hexadecimal starts with <code>#</code></li>
<li>The size of hexadecimal is 2. No <code>0x111</code> or '0xbbb'</li>
</ol>
"
"<p>No. You must use a charger properly designed for the battery; attempting to connect a Li-ion battery directly to a USB charger will damage the battery, possibly catastrophically.</p>
"
"<p>I have a 5.1 home theater(old one), I would like to transform it into a audio streaming system. I have a Arduino UNO and HC-05 Bluetooth Module, and I don't know how to install it in my home theater(if it does). solution please... </p>
"
"<p>Yes.</p>

<hr>

<p>But let me try to talk you through it.</p>

<p><strong>Step 1 - Analysis/Requirements:</strong>
Get your requirements right, what should your system do, what functionality.
So, GSM functionalities and SD card savings (in short).
One of the requirements would be that's it on an Arduino (atmega 328P).
Any other hardware requirements?</p>

<p><strong>Step 2 - Design:</strong>
Check the possibilities with the Arduino, 1 hardware serial and multiple software serial connections. One hardware SPI/I2C I believe.
SD cards often use SPI connection and GSM units most likely use serial.
So this works great. Check some tutorials on SPI and (arduino) serial.</p>

<p><strong>Step 3 - Wiring up</strong>
Wire everything up, as defined in the datasheet of the devices. Cross the Rx and Tx lines. Put MISO to MISO and MOSI to MOSI accordingly.
Be sure everything has enough power (GSM modules typically draw a lot of current when sending/connecting). Usually, if you find out that two devices are attached to the same pin, there might be something wrong (unless you can declare how they're seperated or why this is the case).</p>

<p><strong>Step 4 - Implement</strong>
Well, you stated you're good at programming, so I'll leave this open for you.
But mind that it's only one of the three steps, so you should look at some tutorials, it'll learn a lot faster than asking everything. Try to get a bit comfortable with your thoughts, base them on things you have learned.</p>

<blockquote>
  <p>So this shouldn't be an issue? Those pins aren't shared? - user1833028</p>
</blockquote>

<p>Things like this can be found in the device's datasheet and if you follow some tutorials you'll see that they're different and why.</p>

<p>Also, what helps for me often, is to try to seperate this 'big' project into two smaller projects.
Try to get the GSM working and after that you go for the SD card reader.</p>
"
""
"A small microcontroller board based on the ATmega168 or ATmega328 chip. Use this tag for questions specifically regarding the Mini, and not just general Arduino usage."
"<p>I have seen people using ATtiny45 and other boards and there are hardware configurations files for them. Can we use ATtiny48 as a processor for Arduino?</p>

<p>If so where can I get a boards.txt file that supports it? Alternatively how can I write such a file?</p>
"
"<p>I was reading about using an <a href=""http://thinkingonthinking.com/an-arduino-sketch-from-scratch/"" rel=""nofollow"">Arduino with a Makefile</a>. In the <a href=""https://github.com/sudar/Arduino-Makefile"" rel=""nofollow"">Makefile-Arduino</a> project there is a reference to the Python serial library required to reset the board.
Looking into the usage of PySerial to reset the board, there is some reference to <a href=""http://stackoverflow.com/questions/15460865/disable-dtr-in-pyserial-from-code"">DTR</a> or <a href=""http://johanneshoff.com/arduino-command-line.html"" rel=""nofollow"">here</a></p>

<ul>
<li>What is DTR?</li>
<li>How to control this bit with node-serial and reset the Arduino?</li>
</ul>
"
"<p>This question would be a better match to the Stack Exchange Electrical Engineering group. </p>

<p>A 4.2V battery is very likely a LiIon or LiPo battery. I'll call it LiPO below as it's easier to type.</p>

<p>Most cellphones and many small electronic device use a single LiPo battery and use a 5V input to charge them. To do this they have internal control circuitry that ensures the battery's specifications are met. You can obtain suitable control electronics (in many cases as a single IC requiring maybe a few external resistors to configure it) and it makes great sense to use such a control circuit.</p>

<p>In an emergency you can use a 5V source to charge a 4.2V battery <strong>IF</strong> you know what you are doing and are able to ensure the battery specifications are adhered to. Failing to stay ""in spec"" may lead to the traditional LiPo ""vent with flame"" response, and even if there is no apparent damage the battery life can be greatly or very greatly reduced by out of spec treatment.</p>

<p>Key requirements are:</p>

<ul>
<li><p>NEVER exceed 4.2V at battery terminals.</p></li>
<li><p>NEVER exceed Ichg_max = manufacturers max charging current.<br>
This is usually the same value in mA as the battery capacity in mAh.<br>
ie 1000 mA for a 1000 mAh battery<br>
3300 mA for a 3300 mAh battery etc</p></li>
<li><p>When charging, EITHER stop charging when battery potential reaches 4.2V OR if you are able to hold the battery AT 4.2V, then stop charging when Ichg falls (under battery control) to say Ichgmax/4.</p></li>
<li><p>If Vbattery is under 3.0 V (which it NEVER should be) charge at no more than C/10 (eg  for a 1000 mAh cell) until Vbattery rises to >= 3.0V. If the battery will not rise to 3.0V under C/10 charge it is dead. </p></li>
</ul>

<p>IF you can satisfy ALL these requirements at all times you can charge a LiPo or LiIon battery from 5V without a special charger. </p>
"
"<p>I want to introduce a boolean that is the first iteration of loop and then false 
every subsequent iteration. I want it invisible, so I have to modify loop in some way. Is that possible?</p>
"
"<p>I use the Arduino compatible <a href=""http://www.digilentinc.com/Products/Detail.cfm?NavPath=2,892,1193&amp;Prod=CHIPKIT-WF32"" rel=""nofollow"">chipKIT WF32</a> board. I want to transfer structure data between my board and a Linux PC. Can I do it like the following?</p>

<pre><code>struct data d;
char *tx = (char*)d;
Serial.print(tx);
</code></pre>

<p>Even if the above code works, the data type size in Arduino and on Linux will vary. Is there a way to serialize the data, like <a href=""https://en.wikipedia.org/wiki/Protocol_Buffers"" rel=""nofollow"">Protocol Buffers</a> on Arduino?</p>
"
"<p>i'm trying to understand how to connect this motor:</p>

<p>""Mitsumi 334P/R AB""</p>

<p><a href=""http://www.ebay.com/itm/Mitsumi-334P-R-AB-phase-encoder-encodes-tacho-motor-speed-disk-DC3V-24V-5V-6V-/221702525894?pt=LH_DefaultDomain_0&amp;hash=item339e8013c6"" rel=""nofollow"">Link to the motor i bought</a></p>

<p><img src=""http://i.stack.imgur.com/UST5F.jpg"" alt=""enter image description here""></p>

<p>connections are:</p>

<p>GND - Obvious.</p>

<p>5v - Obvious.</p>

<p>rest of the connections are a bit confusing to me and i do not want to fry my arduino trying.</p>

<ul>
<li>do i need a driver or this looks like a built in one?</li>
<li>do i need to add any electrical components like resistors and capacitors ect?</li>
</ul>
"
"<p>It's just a regular motor, with a (optical) rotary encoder inside. So the first two <code>motor</code> pins are to run the motor. So connect to VCC and GND, or GND and VCC, if you want to run it in reverse. (VCC doesn't have to be 5v; it can be 3v to 30v).</p>

<p>Connect A and B to a digital input pin. You can see what kind of signal you can expect in the screenshot of the oscilloscope, attached to the ebay-listing. So you can measure the speed, and relative position of the motor-shaft.</p>
"
"<p>I bought a Blend Micro (an Arduino Micro with Bluetooth) a few months ago, and after my first experimentation with uploading the Blink sketch something went wrong with the USB connection--it would supply power, but no computer (Windows, OS X or Linux) would show it as a USB device, and Windows would complain that the device was somehow damaged. Anyway, when I plug the board in, it still boots up and runs ""Blink"" so I'd like to try to still use it.</p>

<p>I have a USB-to-FTDI cable, and it would seem fairly straight-forward to use that, but I'm a little uncertain to the appropriate wiring and whether I would need to tell the Arduino software somehow that I was using FTDI.</p>

<p>I can figure out these connections: (I think)</p>

<ul>
<li>black to ground</li>
<li>red to 5V (VIN?)</li>
<li>orange to RX</li>
<li>yellow to TX</li>
</ul>

<p>What about green and brown? Do one of those go to RST (Brown?) and MOSI (Green?)</p>

<p>I figured I would ask before accidentally burning something out.</p>
"
"<p>I've created a function whereby an int ('cleanCount') automatically goes up or down (0-1000) based on the situation. The value changes every few milliseconds. </p>

<p>Based on the value, I would like to turn on or off LEDs. Let's say for every increment of '100' another LED goes on. So if the value is 359 there are 3 leds on, if It would been 899 there would've been 8 LEDs on. </p>

<p>I could simply write</p>

<pre><code>if (cleanCount &lt;= 100) { // turn on NO LEDs
    digitalWrite(led1, LOW);
    digitalWrite(led2, LOW);
    ...
}

...

else if (cleanCount &lt;= 500) { // turn on 4 LEDs
    ...
    digitalwrite(led3, HIGH);
    digitalwrite(led4, HIGH);
    digitalwrite(led5, LOW);
    digitalwrite(led6, LOW);
    ...
}
</code></pre>

<p>but that would be a big pile of code which could be way more efficient. Perhaps.. my code isn't even correct.</p>

<p>So how could this be more efficient or perhaps actually working?</p>

<hr>

<p><em>The whole code, here below.</em></p>

<pre><code>int cleanCount = 1000;
int softpotPin = A0; //analog pin 0



void setup () {
    Serial.begin(9600);
    digitalWrite(softpotPin, HIGH); //enable pullup resistor    
}


void loop() {
    int softpotReading = analogRead(softpotPin);
    if (softpotReading &lt; 980) { // IF AANGERAAKT
        digitalWrite(werktIeLED, HIGH); 
        ++cleanCount;
        Serial.println(cleanCount);
        delay(16); // 5x zo snel als leeglopen
    }
    else if (softpotReading &gt; 980) { // IF NIET AANGERAAKT
        digitalWrite(werktIeLED, LOW); 
        --cleanCount;
        Serial.println(cleanCount);
        delay(64); // 1000 / 60 seconden
    }
    else {      // Als er een fout optreed..
        Serial.println(""Fout!"");
        digitalWrite(werktIeLED, HIGH);    
        delay(250);               
        digitalWrite(werktIeLED, LOW);    
        delay(250);               
    }


}
</code></pre>
"
"<p>Instead of repeating several calls to <code>digitalwrite</code> you should consider changing the pins directly as described <a href=""http://www.arduino.cc/en/Reference/PortManipulation"" rel=""nofollow"">here</a>.</p>

<p>This now depends on which port your LEDs are connected to. Assuming port D you would use <code>DDRD</code> to define the pins as output (usually in <code>setup()</code>) and <code>PORTD</code> to set their values (in <code>loop</code>), e.g.</p>

<pre><code>DDRD = B11111110; // define pins 1..7 as outputs, pin 0 as input
</code></pre>

<p>and</p>

<pre><code>PORTD = B11110000; // switch on first 4 LEDs
</code></pre>

<p>Now all you need to do is to write a function to map your number range to suitable bit strings.</p>

<p>The function could look like this:</p>

<pre><code>int convert(int n) {                                                                     

  int res = 0;   // start with all pins off (zero)
  while (n &gt; 100) { 
    res &lt;&lt;= 1;   // shift pattern 1 bit (i.e. pin) to the left
    res |= 1;    // ""switch on"" lowest pin 
    n -= 100;    // defines step size (1 LED for every  100)
  }
  return res;

}
</code></pre>

<p>It takes your value and returns an <code>int</code> that you can assign to the port. I.e. for 0..100 it returns <code>0</code>, for 101..200 it returns <code>1</code>, for 201..300 it returns <code>3</code> = <code>B11</code>, for 301..400 it returns <code>7</code> = <code>B111</code> and so on. (Note that it does not do any sanity checks on the input / output but that's certainly easy for you to add if needed.)</p>

<p>(In response to comment: Note that the bit pattern I use as example for <code>DDRD</code> above is an example: It sets bit / pin 0 as input. If you use <code>convert</code> you would, of course, set the lowest bit of <code>DDRD</code> to 1 to make it an output.)</p>
"
"<p>Here is a suggestion with the led pins in an array that you loop over.</p>

<p>I suggest making the array global, so put it outside any functions (usually at the top):</p>

<pre><code>byte led_pins[] = {pin1, pin2, pin3, pin4, pin5, pin6, pin7, pin8};
</code></pre>

<p>Then put this in your loop (assumes that you have a <code>int</code> called cleanCount that is in scope:</p>

<pre><code>const int increment = 100;

for (int i = 0; i &lt; sizeof(led_pins) / sizeof(led_pins[0]); i++) {
  boolean onOrOff = cleanCount &gt; (i+1) * increment;
  digitalWrite(led_pins[i], onOrOff);
}
</code></pre>
"
"<p>I'm using an LM35 temperature sensor, and it outputs 190 mV (which agrees with 19°C). I'm using an external reference voltage which I measure as 417mV. (This is set by the pin ""aRefCntrl""). So I should have a reading around 467, but I get 1023, i.e. the ADC overflows. When I use the internal 1.1V reference I get a correct reading. Any ideas?</p>

<p>This is my code (Arduino waits for a request from the PC to send the data):</p>

<pre><code>#define lm35 A0
#define aRefCtrl 10

void setup() {    
  pinMode(aRefCtrl, OUTPUT);
  digitalWrite(aRefCtrl, 0);
  analogReference(EXTERNAL);
  analogRead(lm35); // dummy read
  Serial.begin(9600);  
}  

void loop() {
  if ( Serial.available() ) {
    Serial.read(); // PC's request is a single byte
    int temperature = analogRead(lm35);
    Serial.println(temperature);    
  }
}   
</code></pre>

<p><strong>follow-up</strong> on Ignacio's comment: would a decoupling capacitor do? (I can't test for the moment, I have to order some)</p>
"
"<p>The minimum reference voltage is 1.0 V according to the atmega328 <a href=""http://www.atmel.com/images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet_Complete.pdf"" rel=""nofollow"">datasheet</a>. See table 29-15. ADC Characteristics.</p>
"
"<p>Coming in late but seeing no solutions offered yet, I'll take a stab at it:</p>

<p>Assume your vehicle is traveling obliquely toward the wall.
Assume you can find and measure the perpendicular distance to the wall.
Then you can calculate the travel distance from those two measurements:</p>

<p><img src=""http://i.stack.imgur.com/OsmP1.jpg"" alt=""enter image description here""></p>

<p>Next we need to find the angle between the vehicle's heading (center-line) and the perpendicular. A rotating sensor that senses return-signal strength could probably give good results but is mechanically more complicated. Given that the ultrasonic sensors have a somewhat broad sensing angle, 3 or 5 fixed sensors (1 straight ahead and 1 or 2 to either side) may work well enough if you're just trying to avoid hitting the wall. In that case you could measure with all of the sensors, take the least distance measurement as 'p' and the known angle of that sensor as 'theta'.</p>

<p>What's left is to decide how to make the calculation and work with cosines. For the rotating sensor case, you'll have to find the angle of the sensor at the time of it's smallest reading, and look up in a table (or calculate) the cosine of that angle. For the multiple fixed sensors case, you already know the sensors' angles and therefore, their cosines.</p>

<p>If you have enough code memory it would easy to write your calculations in floating point, certainly for some quick and dirty testing. If not, or you need to speed up the calculations, you can do it in fixed point with less code. it's a little bit harder for the programmer but much easier and quicker for the MCU.</p>
"
"<p>The following solution isn't strictly portable, but it should work as long as both ends are <a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">little-endian</a> (most platforms).</p>

<p>You can use the GCC attribute <code>packed</code> to tell the compiler not to pad the fields like this:</p>

<pre><code>struct __attribute__ ((packed)) my_struct {
  char c;
  int32_t n;
};
</code></pre>

<p>Then you can send your struct like this:</p>

<pre><code>Serial.write((uint8_t*) a_my_struct_ptr, sizeof(my_struct));
</code></pre>

<p>On the receiving end you just copy the received data to a similarly packed struct. If you would rather use <a href=""http://en.wikipedia.org/wiki/Python_%28programming_language%29"" rel=""nofollow"">Python</a> over C/C++ you can use the <code>struct</code> module to unserialize the data.</p>

<hr>

<p>I just googled your product and the <a href=""https://en.wikipedia.org/wiki/MIPS_instruction_set"" rel=""nofollow"">MIPS</a> processor is bi-endian, but I will assume that it is configured for little-endian by default. You can try and see if <code>int</code>s keep their value after transmit. Also remember to use explicit size types such as int16_t, uint64_t, etc.</p>
"
"<p>If you want to take it to to the extreme, I always use an algorithm called Diamond Coordinates. It is described in <a href=""http://www.rchordata.com/files/Using%20Diamond%20Coordinates%20to%20Power%20a%20Differential%20Drive.pdf"" rel=""nofollow"">this</a> PDF.  It performs perfectly, and I keep a C# and Java implementation handy. I'll probably be doing a Python one soon :)</p>

<p><img src=""http://i.stack.imgur.com/u9Z1H.png"" alt=""enter image description here""></p>
"
"<p>I don't think this will be feasible. There are two main issues:</p>

<p><strong>1.</strong> I don't think there's a sensible way to get the HC-05 module to work with A2DP. It's great for a simple serial connection, but Bluetooth-enabled media devices generally won't connect to it if they're looking for audio streaming systems (as far as I know).</p>

<p><strong>2.</strong> The Uno probably isn't powerful enough. Even if you could get the audio data into it, I don't think it will be able to decode the information to an analog audio signal in real-time.</p>

<p>Something like a Raspberry Pi with a suitable Bluetooth module might be a better choice for this.</p>
"
"<p>Since the DUE works on 3.3 volts has anyone successfully modified a 5V 16x2 LCD shield to work with Arduino DUE?  I'm thinking 3.3V will be seen as a logic ""1""
by the 5V LCD shield and there are no 5V outputs that feed back to the 3.3V due if the R/~W line on the LCD is simply grounded.  </p>

<p>Would love to hear anyone's opine on this.</p>

<p>Thanks,
Charlie</p>
"
"<p>I've got a function that decreases over time (1000 / 60 seconds) and by touching a softPotentiometer you can increase that value. By every increment of 200 a LED is lid. So for 0-200, 1 LED; 201-400, 2 LEDs; etc. And since it decreases over time while doing nothing, if it drops below a certain value, a LED is shut off.</p>

<p>However, I've got a (amateur) coded set up, but somehow it lids the LEDs in the opposite direction. In a way that, I've coded it that if it's above 800, lid 5 LED's. However, it will only lid one LED when it's dropped below the 800, in the area of 601-800.</p>

<p>That's exactly the opposite of what I want. So what am I doing wrong here? </p>

<hr>

<p>My code:<br>
<em>And with amateur, I mean that I didn't use arrays and therefor write everything multiple times..</em></p>

<pre><code>int cleanCount = 1000;
int IsItWorkingLED = 13;
int softpotPin = A0; //analog pin 0
int LED1 = 1;
int LED2 = 2;
int LED3 = 4;
int LED4 = 5;
int LED5 = 7;



void setup () {
    Serial.begin(9600);
    digitalWrite(softpotPin, HIGH); //enable pullup resistor    
        pinMode(1, OUTPUT); 
        pinMode(2, OUTPUT); 
        pinMode(4, OUTPUT); 
        pinMode(5, OUTPUT); 
        pinMode(7, OUTPUT);

           digitalWrite(1, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(2, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(4, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(5, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(7, HIGH);   // turn the LED on (HIGH is the voltage level)

}


void loop() {
    int softpotReading = analogRead(softpotPin);
    if (softpotReading &lt; 980) { // IF TOUCHED
        digitalWrite(IsItWorkingLED, HIGH); 
        ++cleanCount;
        Serial.println(cleanCount);
        delay(16); // Drain 5 times as fast
    }
    else if (softpotReading &gt; 980) { // IF NOT DTOUCHED
        digitalWrite(IsItWorkingLED, LOW); 
        --cleanCount;
        Serial.println(cleanCount);
        delay(64); // 1000 / 60 seconds
    }
    else {      // Als er een fout optreed..
        Serial.println(""Something wrong!"");
        digitalWrite(IsItWorkingLED, HIGH);    
        delay(250);               
        digitalWrite(IsItWorkingLED, LOW);    
        delay(250);               
    }

        if (cleanCount &gt;= 0 &amp;&amp; cleanCount &lt;= 200) {
           Serial.println(""Knal 1 LED aan"");
           digitalWrite(LED1, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED2, LOW);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED3, LOW);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED4, LOW);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED5, LOW);   // turn the LED on (HIGH is the voltage level)
        }
        else if (cleanCount &gt;= 201 &amp;&amp; cleanCount &lt;= 400) {
           Serial.println(""Knal 2 LEDs aan"");
           digitalWrite(LED1, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED2, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED3, LOW);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED4, LOW);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED5, LOW);   // turn the LED on (HIGH is the voltage level)
        }
        else if (cleanCount &gt;= 401 &amp;&amp; cleanCount &lt;= 600) {
           Serial.println(""Knal 3 LEDs aan"");
           digitalWrite(LED1, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED2, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED3, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED4, LOW);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED5, LOW);   // turn the LED on (HIGH is the voltage level)
        }
        else if (cleanCount &gt;= 601 &amp;&amp; cleanCount &lt;= 800) {
           Serial.println(""Knal 4 LEDs aan"");
           digitalWrite(LED1, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED2, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED3, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED4, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(LED5, LOW);   // turn the LED on (HIGH is the voltage level)
        }
        else if (cleanCount &gt;= 801 &amp;&amp; cleanCount &lt;= 1000) {
           Serial.println(""Knal 5 LEDs aan"");
           digitalWrite(1, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(2, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(4, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(5, HIGH);   // turn the LED on (HIGH is the voltage level)
           digitalWrite(7, HIGH);   // turn the LED on (HIGH is the voltage level)
        }
        else {
          Serial.println(""Just..do nothing""); 
        }



}
</code></pre>
"
"<p>If your LEDs are connected anode to +5, cathode to i/o pin, they would behave this way. Cathode to ground, anode to i/o would behave as you expect.</p>
"
"<p>You can use the barGraph example from the Arduino code examples. This gives a bar-type graph and not point. I will give rough explination why it will work and the need not to re-invent the wheel.</p>

<pre><code>    int sensorReading = analogRead(analogPin);
  // map the result to a range from 0 to the number of LEDs:
  int ledLevel = map(sensorReading, 0, 1023, 0, ledCount);

  // loop over the LED array:
  for (int thisLed = 0; thisLed &lt; ledCount; thisLed++) {
    // if the array element's index is less than ledLevel,
    // turn the pin for this element on:
    if (thisLed &lt; ledLevel) {
      digitalWrite(ledPins[thisLed], HIGH);
    } 
    // turn off all pins higher than the ledLevel:
    else {
      digitalWrite(ledPins[thisLed], LOW); 
    }
  }
</code></pre>

<p><code>int ledLevel = map(sensorReading, 0, 1023, 0, ledCount);</code></p>

<p>This will give you the point in the array, 0-10, for 0-1000, if you replace <code>1023</code> with <code>1000</code></p>

<p>Simplified <code>map()</code> function:</p>

<p><code>int point = sensorReading*10/1000</code> this gives you a range of 0-10, the int keeps it from having decimal points.</p>

<p>As you can see from the for loop it turns on all the LEDs that are in the array to the end and then turns off those not needed.</p>
"
"<p>Try reversing the if statements.
You say:</p>

<blockquote>
  <p>I've coded it that if it's above 800, lid 5 LED's.</p>
</blockquote>

<p>And your code is:
<code>(softpotReading &lt; 980) { // IF TOUCHED</code></p>

<p>The code describes: <code>IF softpotReading IS SMALLER THAN 980, DO{ code.. }</code></p>

<hr>

<p>In dutch (as OP is dutch, and to be honest his English somehow confuses me a bit, to be sure it's not the other way around also):</p>

<p>Ik denk dat je de IF statements verkeerd om hebt.
Je beschrijft dat bij een waarde hoger dan 800 de ledjes aan gaan...</p>

<p>Echter staat in je code <code>(softpotReading &lt; 980) { // IF TOUCHED</code>
Wat dus zal betekenen dat de code wordt uitgevoerd als die &lt; (kleiner dan) 980 is.</p>

<hr>

<pre><code>    if (softpotReading &gt; 980) { // IF TOUCHED
    digitalWrite(IsItWorkingLED, HIGH); 
    ++cleanCount;
    Serial.println(cleanCount);
    delay(16); // Drain 5 times as fast
}
else if (softpotReading &lt;= 980) { // IF NOT DTOUCHED
    digitalWrite(IsItWorkingLED, LOW); 
    --cleanCount;
    Serial.println(cleanCount);
    delay(64); // 1000 / 60 seconds
}
</code></pre>
"
"<p>So I have 3 ground pins, but I need 4 motors on my Arduino. Can I connect multiple motors to the same ground pin?</p>
"
"<p>The way to do this isn't to overload the loop function, the way to do this is to abuse the linker and replace main(). </p>

<p>The main.cpp file that gets used in the Arduino make prototypes main as <code>int main(void)</code>. On my system at least the linker prefers the longer prototype, so you can just do this:</p>

<pre><code>int main(int argc, char* argv[])
{
    init();

#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();

    //The one shot loop...
    loop();
    if (serialEventRun) serialEventRun();
    //Put whatever else you need to do between before the unending loop here.

    for (;;) {
        loop();
        if (serialEventRun) serialEventRun();
    }

    return 0;    
}
</code></pre>

<p>Both get compiled, but the <code>int main(int argc, char* argv[])</code> prototyped version gets linked as the entry point, so your ""invisibile"" code gets executed.</p>
"
"<p>I am trying to build a set of four stars using an Arduino, potentiometer and a four channel relay to control how fast it speeds across the stars. My question is how can I delay the process, say for 20 or 30 seconds before it starts again?</p>
"
"

<p>Couldn't find any other post that mentions Serial Monitor crippling the normal workflow of the NRF24l01, so here it goes.</p>

<p>I have two Arduino Nano, both with NRF24l01 attached, and an RF24 library working. Both NRF24l01 have 10uF caps soldered on them. One is only sending data, another is receiving only. Both of them flash LED on, successful transmission and successful receiving respectively.</p>

<p>When I run both devices, i see both LEDs flashing, so one succeeds in sending, and another one in receiving. But whenever I try to open Serial Monitor in my Arduino 1.6.1 software, the LEDs flash only every forth of fifth time of expected, and in my Serial Monitor I can see only 1 of 4 or 5 packets received (though received correctly).</p>

<p>Any ideas what I could have done wrong? Could Serial Monitor somehow interfere with Nano talking to NRF24l01?</p>

<p>The code follows, it's simple.</p>

<p>Sender</p>

<pre class=""lang-C++ prettyprint-override""><code>    /*
     Copyright (C) 2011 J. Coliz &lt;maniacbug@ymail.com&gt;

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 2 as published by the Free Software Foundation.
     */

    #include &lt;SPI.h&gt;
    #include ""nRF24L01.h""
    #include ""RF24.h""
    #include ""printf.h""

    // On Successfull Sending Blink PIN

    #define BLPIN 5

    //
    // Hardware configuration
    //

    // Set up nRF24L01 radio on SPI bus plus pins 9 &amp; 10 

    RF24 radio(9,10);

    //
    // Topology
    //

    // Radio pipe addresses for the 2 nodes to communicate.
    const uint64_t pipe = 0xF0F0F0F0E1LL;

    void setup(void)
    {
      pinMode(BLPIN, OUTPUT);

      //
      // Print preamble
      //

      Serial.begin(57600);
      printf_begin();
      printf(""\n\rRF24/examples/GettingStarted/\n\r"");

      //
      // Setup and configure rf radio
      //

      radio.begin();

      // optionally, increase the delay between retries &amp; # of retries
      radio.setRetries(15,15);

      // optionally, reduce the payload size.  seems to
      // improve reliability
      radio.setPayloadSize(8);

      //
      // Open pipes to other nodes for communication
      //

      radio.openWritingPipe(pipe);

      //
      // Dump the configuration of the rf unit for debugging
      //

      radio.printDetails();
    }

    // counter data to be sent
    unsigned long counter = 0;

    void loop(void)
    {

      // Increase the counter and send it
      counter++;
      printf(""Sending counter = %lu..."", counter);

      if (radio.write( &amp;counter, sizeof(unsigned long) ))
      {
        printf(""ok...\n\r"");
        digitalWrite(BLPIN, HIGH); 
        delay(10);
        digitalWrite(BLPIN, LOW); 
      }
      else
        printf(""failed.\n\r"");

      // Try again 1s later
      delay(1000);
    }
</code></pre>

<p>Receiver</p>

<pre class=""lang-C++ prettyprint-override""><code>    /*
     Copyright (C) 2011 J. Coliz &lt;maniacbug@ymail.com&gt;

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 2 as published by the Free Software Foundation.
     */

    #include &lt;SPI.h&gt;
    #include ""nRF24L01.h""
    #include ""RF24.h""
    #include ""printf.h""

    // On Receiver Blink PIN

    #define BLPIN 5

    //
    // Hardware configuration
    //

    // Set up nRF24L01 radio on SPI bus plus pins 9 &amp; 10 

    RF24 radio(9,10);

    //
    // Topology
    //

    // Radio pipe addresses for the 2 nodes to communicate.
    const uint64_t pipe = 0xF0F0F0F0E1LL;

    void setup(void)
    {
      pinMode(BLPIN, OUTPUT);

      //
      // Print preamble
      //

      Serial.begin(57600);
      printf_begin();
      printf(""\n\rRF24/examples/GettingStarted/\n\r"");

      //
      // Setup and configure rf radio
      //

      radio.begin();

      // optionally, increase the delay between retries &amp; # of retries
      radio.setRetries(15,15);

      // optionally, reduce the payload size.  seems to
      // improve reliability
      radio.setPayloadSize(8);

      //
      // Open pipes to other nodes for communication
      //

      radio.openReadingPipe(1,pipe);

      //
      // Start listening
      //

      radio.startListening();

      //
      // Dump the configuration of the rf unit for debugging
      //

      radio.printDetails();
    }

    unsigned long counter;

    void loop(void)
    {
      // if there is data ready
      if (radio.available())
      {
        while( radio.available() ) {
          radio.read( &amp;counter, sizeof(unsigned long) );
          // Dump the payloads until we've gotten everything
          printf(""Got payload %lu...\n\r"", counter);
        }
        digitalWrite(BLPIN, HIGH); 
        delay(10);
        digitalWrite(BLPIN, LOW); 
      }
    }
</code></pre>
"
"<p>You can do it as long as the current isn't excessive. I don't think there are any specs available, but the connector and the width / thickness of the copper tracks on the PCB will be the limiting factor.</p>
"
"<p><a href=""http://arduino.cc/en/pmwiki.php?n=Reference/Delay"" rel=""nofollow""><code>delay()</code></a>:</p>

<pre><code>delay(20000); // wait for 20 seconds
</code></pre>
"
"<p><sup>This is my followup question based on a serie of one project. Go my to profile to read 'm all.</sup></p>

<p>So I'm building something which includes a function that has a count (1000) that decreases over time, but by pressing a soft pot meter the count increases. By every increment of 200 one LED is lit. So if the count is 837 4 LEDs are burning. </p>

<p>In my previous question I had issues lighting the LEDs, because they didn't burn even when the code was, as far as I could see correct. Instead it did the opposite of what I coded. Now I changed my code the opposite direction, </p>

<p>writing:</p>

<blockquote>
  <p>digitalWrite(LED1, LOW);   // turn the LED on (LOW is the voltage level)</p>
</blockquote>

<p>Which actually set the LED to bright. While is I'd write it 'HIGH' it would dim. </p>

<p>So my actual question is: How could my LED be lit if it's set to 'low', while you have to set it to 'high' to be actually popping off light?</p>

<hr>

<p><strong><em>My complete code:</em></strong></p>

<pre><code>int cleanCount = 1000;
int IsItWorkingLED = 13;
int softpotPin = A0; //analog pin 0
int LED1 = 1;
int LED2 = 2;
int LED3 = 4;
int LED4 = 5;
int LED5 = 7;



void setup () {
    Serial.begin(9600);
    digitalWrite(softpotPin, HIGH); //enable pullup resistor    
    pinMode(LED1, OUTPUT);  
    pinMode(LED2, OUTPUT);  
    pinMode(LED3, OUTPUT);  
    pinMode(LED4, OUTPUT);  
    pinMode(LED5, OUTPUT);

    digitalWrite(LED1, HIGH);   // turn the LED on (HIGH is the voltage level)
    digitalWrite(LED2, HIGH);   // turn the LED on (HIGH is the voltage level)
    digitalWrite(LED3, HIGH);   // turn the LED on (HIGH is the voltage level)
    digitalWrite(LED4, HIGH);   // turn the LED on (HIGH is the voltage level)
    digitalWrite(LED5, HIGH);   // turn the LED on (HIGH is the voltage level)  
}


void loop() {
    int softpotReading = analogRead(softpotPin);
    if (softpotReading &lt; 980) { // IF TOUCHED
        digitalWrite(IsItWorkingLED, HIGH); 
        ++cleanCount;
        Serial.println(cleanCount);
        delay(8); // Increase 5 times as fast
    }
    else if (softpotReading &gt; 980) { // IF NOT TOUCHED
        digitalWrite(IsItWorkingLED, LOW); 
        --cleanCount;
        Serial.println(cleanCount);
        delay(32); // Decrease slowly
    }
    else {      // If there is something wrong..
        Serial.println(""Something wrong!"");
        digitalWrite(IsItWorkingLED, HIGH);    
        delay(250);               
        digitalWrite(IsItWorkingLED, LOW);    
        delay(250);               
    }

        if (cleanCount &lt;= 200) {
            Serial.println(""Knal 1 LED aan"");
            digitalWrite(LED1, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED2, HIGH);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED3, HIGH);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED4, HIGH);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED5, HIGH);   // turn the LED on (LOW is the voltage level)
        }
        else if (cleanCount &gt;= 201 &amp;&amp; cleanCount &lt;= 400) {
            Serial.println(""Knal 2 LEDs aan"");
            digitalWrite(LED1, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED2, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED3, HIGH);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED4, HIGH);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED5, HIGH);   // turn the LED on (LOW is the voltage level)
        }
        else if (cleanCount &gt;= 401 &amp;&amp; cleanCount &lt;= 600) {
            Serial.println(""Knal 3 LEDs aan"");
            digitalWrite(LED1, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED2, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED3, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED4, HIGH);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED5, HIGH);   // turn the LED on (LOW is the voltage level)
        }
        else if (cleanCount &gt;= 601 &amp;&amp; cleanCount &lt;= 800) {
            Serial.println(""Knal 4 LEDs aan"");
            digitalWrite(LED1, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED2, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED3, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED4, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(LED5, HIGH);   // turn the LED on (LOW is the voltage level)
        }
        else if (cleanCount &gt;= 801 &amp;&amp; cleanCount &lt;= 1000) {
            Serial.println(""Knal 5 LEDs aan"");
            digitalWrite(1, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(2, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(4, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(5, LOW);   // turn the LED on (LOW is the voltage level)
            digitalWrite(7, LOW);   // turn the LED on (LOW is the voltage level)
        }
        else {
            Serial.println(""Just..do nothing""); 
        }



}
</code></pre>
"
"<p>I'm working on sketches uploading over BLE. I had to write my own uploader (looking at avrdude sources with one eye) so i can change uploading behaviour as needed and it's working over USB just perfect but it does not get response from bootloader if trying over Bluetooth LE.</p>

<p>My hardware:</p>

<ul>
<li>Arduino Uno (and i'm having Arduino Mega2560)</li>
<li>HM-10 BLE module</li>
</ul>

<p>As HM-10 does not support DTR/RTS i had to add my own software reboot:</p>

<p>In brief: it reads incoming bytes on interrupt event and compares to reset command passed in ble_setup. If it's equal then it uses watchdog timer to reboot the board. If it's not equal it stores byte in byffer, then sketch loop() just returns incoming byes back (""echo"").</p>

<pre><code>#include &lt;avr/wdt.h&gt;

const char *ble_reset_cmd;
int ble_reset_index = 0;
int ble_available = 0;       // chars available
int ble_byte;                // income buffer as 1 char
int *ble_bytes = &amp;ble_byte;  // income buffer
boolean delete_ble_bytes = false;

//#define BLE_DEBUG

// reboot Arduino board using Watchdog timer
void reboot() {
//    #ifdef BLE_DEBUG
    Serial.println(""rebooting ..."");
//    #endif

//    digitalWrite(13, HIGH);
//    delay(2000);

    wdt_enable(WDTO_15MS);
    while(1) { };
}

void ble_setup(int baud, const char *reset_cmd) {
    Serial.begin(baud);
    ble_reset_cmd = reset_cmd;
}

int Serial_available() {
    return ble_available;
}

int Serial_read() {
    if (ble_available &lt; 0)
        return -1;

    int inByte = ble_bytes[--ble_available];
    if (ble_available == 0 &amp;&amp; delete_ble_bytes) {
        // restore buffer as 1 char buffer
        delete[] ble_bytes;
        ble_bytes = &amp;ble_byte;
        delete_ble_bytes = false;
    }
    return inByte;
}

void serialEvent() {
    if (Serial.available() &lt;= 0)
        return;

    int inByte = Serial.read();
    if (inByte == ble_reset_cmd[ble_reset_index]) {
        // entered char is cmd character

        if (ble_reset_cmd[++ble_reset_index] == 0)
            reboot();

        #ifdef BLE_DEBUG  
        Serial.write(""ble_index = "");
        Serial.print((byte)ble_reset_index);
        Serial.write('\n');
        #endif 

    } else {
        // entered char is NOT cmd character

        if (ble_reset_index &gt; 0) {
            // got character not from cmd, so we should to return characters
            // starting ble_reset_cmd until current index and then this character

            ble_available = ble_reset_index + 1;
            ble_reset_index = 0;

            #ifdef BLE_DEBUG
            Serial.print(""Copy "");
            Serial.print((byte)(ble_available - 1));
            Serial.println("" bytes"");
            #endif

            // recreate input buffer using cmd characters
            ble_bytes = new int[ble_available + 1];
            delete_ble_bytes = true;
            ble_bytes[0] = inByte;
            for (int i=0; i&lt;(ble_available-1); i++) {
              ble_bytes[i + 1] = ble_reset_cmd[ble_available - i - 2];
            }
            ble_bytes[ble_available] = 0; // null-terminated array

            #ifdef BLE_DEBUG
            Serial.print(""input buffer now contains "");
            Serial.print(ble_available);
            Serial.println("" bytes"");
            #endif

        } else {

            #ifdef BLE_DEBUG
            Serial.println(""ble_index = 0"");
            #endif

            // pass inByte next ...
            ble_available++;
            ble_byte = inByte;
        }

    }
} 

// ----------------------------------- 

int led = 13;
int ledHIGH = 0;

void setup() {
  ble_setup(9600, ""AT+RESET"");
  Serial.print(""ready\n"");
  pinMode(led, OUTPUT);
}

void loop() {
  while (Serial_available() &gt; 0) {
    int inByte = Serial_read();

//    Serial.write('&gt;');
//    Serial.write(inByte);
//    Serial.write('\n');
    ledHIGH = 1- ledHIGH;
    digitalWrite(led, ledHIGH);
    Serial.write(inByte); // echo
  }
}
</code></pre>

<p>As i said it's working good for USB uploading:
right after rebooting bootloader waits for upload commands and start to reply:</p>

<pre><code>015-04-07 21:22:10.860 Apploader[11226:303] Apploader v0.1
2015-04-07 21:22:12.772 Apploader[11226:303] DTR/RTS supported by Serial, resetting
2015-04-07 21:22:13.075 Apploader[11226:303] draining ...
2015-04-07 21:22:13.327 Apploader[11226:303] drain done
2015-04-07 21:22:13.328 Apploader[11226:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:22:13.328 Apploader[11226:303] draining ...
2015-04-07 21:22:13.723 Apploader[11226:303] drain done
2015-04-07 21:22:13.724 Apploader[11226:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:22:13.724 Apploader[11226:303] draining ...
2015-04-07 21:22:13.977 Apploader[11226:303] drain done
2015-04-07 21:22:13.978 Apploader[11226:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:22:13.979 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:13.980 Apploader[11226:303] Recv: . [0x10] 
2015-04-07 21:22:13.980 Apploader[11226:303] Send: A [0x41]  . [0x81]   [0x20] 
2015-04-07 21:22:13.984 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:13.984 Apploader[11226:303] Recv: . [0x04] 
2015-04-07 21:22:13.985 Apploader[11226:303] Recv: . [0x10] 
2015-04-07 21:22:13.985 Apploader[11226:303] Send: A [0x41]  . [0x82]   [0x20] 
2015-04-07 21:22:13.988 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:13.988 Apploader[11226:303] Recv: . [0x04] 
2015-04-07 21:22:13.989 Apploader[11226:303] Recv: . [0x10] 
2015-04-07 21:22:13.989 Apploader[11226:303] Send: B [0x42]  . [0x86]  . [0x00]  . [0x01]  . [0x00]  . [0x01]  . [0x01]  . [0x01]  . [0x03]  . [0xff]  . [0xff]  . [0xff]  . [0xff]  . [0x00]  . [0x80]  . [0x04]  . [0x00]  . [0x00]  . [0x00]  . [0x80]  . [0x00]   [0x20] 
2015-04-07 21:22:13.996 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:13.997 Apploader[11226:303] Recv: . [0x10] 
2015-04-07 21:22:13.997 Apploader[11226:303] Send: E [0x45]  . [0x05]  . [0x04]  . [0xd7]  . [0xc2]  . [0x00]   [0x20] 
2015-04-07 21:22:14.000 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:14.001 Apploader[11226:303] Recv: . [0x10] 
2015-04-07 21:22:14.003 Apploader[11226:303] Send: P [0x50]   [0x20] 
2015-04-07 21:22:14.004 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:14.008 Apploader[11226:303] Recv: . [0x10] 
</code></pre>

<p>But when trying over BLE bootloader stops listening in 200ms and then launches sketch, i can see sketch setup() started as it prints ""ready"". Also i can see it actually reboots the board as it sends ""rebooting"".</p>

<pre><code>015-04-07 21:23:30.287 Apploader[11253:303] Apploader v0.1
2015-04-07 21:23:30.296 Apploader[11253:1503] CBCentralManager state is 5
2015-04-07 21:23:31.297 Apploader[11253:303] BleSerialDevice: open()
2015-04-07 21:23:31.298 Apploader[11253:303] Waiting for peripheral to be discovered ...
2015-04-07 21:23:31.591 Apploader[11253:1503] Found peripheral: &lt;CBPeripheral: 0x100401940 identifier = D92ECAAB-51A5-44D5-8C6C-536CD797867E, Name = ""Ardu"", state = disconnected&gt;
2015-04-07 21:23:31.593 Apploader[11253:1503] Stop scanning
2015-04-07 21:23:31.595 Apploader[11253:1503] Connecting to &lt;CBPeripheral: 0x100401940 identifier = D92ECAAB-51A5-44D5-8C6C-536CD797867E, Name = ""Ardu"", state = disconnected&gt;
2015-04-07 21:23:32.025 Apploader[11253:1503] Connected to peripheral &lt;CBPeripheral: 0x100401940 identifier = D92ECAAB-51A5-44D5-8C6C-536CD797867E, Name = ""Ardu"", state = connected&gt;
2015-04-07 21:23:32.041 Apploader[11253:1503] Discovered services for peripheral &lt;CBPeripheral: 0x100401940 identifier = D92ECAAB-51A5-44D5-8C6C-536CD797867E, Name = ""Ardu"", state = connected&gt;
2015-04-07 21:23:32.042 Apploader[11253:1503] Discovered service &lt;CBService: 0x103701450&gt;
2015-04-07 21:23:32.043 Apploader[11253:1503] Discovered service &lt;CBService: 0x1037015f0&gt;
2015-04-07 21:23:32.043 Apploader[11253:1503] Discovered service &lt;CBService: 0x103701630&gt;
2015-04-07 21:23:32.044 Apploader[11253:1503] Discovered characteristics for service &lt;CBService: 0x103701630&gt;
2015-04-07 21:23:32.044 Apploader[11253:1503] Discovered characteristic &lt;CBCharacteristic: 0x1037005c0&gt;
2015-04-07 21:23:32.045 Apploader[11253:1503] Subscribed to Rx value
2015-04-07 21:23:32.046 Apploader[11253:303] Connected successfully
2015-04-07 21:23:33.342 Apploader[11253:303] BleSerialDevice: open()
2015-04-07 21:23:33.343 Apploader[11253:303] already connected, exiting
2015-04-07 21:23:33.343 Apploader[11253:303] DTR/RTS supported by Serial, resetting
2015-04-07 21:23:33.594 Apploader[11253:303] Within interval
2015-04-07 21:23:33.595 Apploader[11253:303] Perform reset
2015-04-07 21:23:33.596 Apploader[11253:303] Send: A [0x41] T [0x54] + [0x2b] R [0x52] E [0x45] S [0x53] E [0x45] T [0x54] 
2015-04-07 21:23:33.647 Apploader[11253:303] Skip draining after reset
2015-04-07 21:23:33.648 Apploader[11253:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:23:33.648 Apploader[11253:303] Draining for 200 ms ...
2015-04-07 21:23:33.649 Apploader[11253:303] Start reading
2015-04-07 21:23:33.712 Apploader[11253:1503] Rx value received 15 bytes: r [0x72] e [0x65] b [0x62] o [0x6f] o [0x6f] t [0x74] i [0x69] n [0x6e] g [0x67]   [0x20] . [0x2e] . [0x2e] . [0x2e] . [0x0d] . [0x0a] 
2015-04-07 21:23:33.713 Apploader[11253:1503] _characterRead = true
2015-04-07 21:23:33.780 Apploader[11253:1503] Rx value received 6 bytes: r [0x72] e [0x65] a [0x61] d [0x64] y [0x79] . [0x0a] 
2015-04-07 21:23:33.780 Apploader[11253:1503] _characterRead = true
2015-04-07 21:23:33.850 Apploader[11253:303] Finish reading
2015-04-07 21:23:33.851 Apploader[11253:303] Drained 21 bytes
2015-04-07 21:23:33.852 Apploader[11253:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:23:33.853 Apploader[11253:303] Draining for 200 ms ...
2015-04-07 21:23:33.853 Apploader[11253:303] Start reading
2015-04-07 21:23:33.982 Apploader[11253:1503] Rx value received 2 bytes: 0 [0x30]   [0x20] 
2015-04-07 21:23:33.983 Apploader[11253:1503] _characterRead = true
2015-04-07 21:23:34.054 Apploader[11253:303] Finish reading
2015-04-07 21:23:34.055 Apploader[11253:303] Drained 2 bytes
2015-04-07 21:23:34.056 Apploader[11253:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:23:34.056 Apploader[11253:303] Reading 1 bytes ...
2015-04-07 21:23:34.057 Apploader[11253:303] Start reading
2015-04-07 21:23:34.057 Apploader[11253:303] _characterRead = false
2015-04-07 21:23:34.184 Apploader[11253:1503] Rx value received 1 bytes: . [0x00] 
2015-04-07 21:23:34.185 Apploader[11253:1503] _characterRead = true
2015-04-07 21:23:34.186 Apploader[11253:303] Finish reading
2015-04-07 21:23:34.186 Apploader[11253:1503] Rx value received 2 bytes: 0 [0x30]   [0x20] 
2015-04-07 21:23:34.186 Apploader[11253:1503] _characterRead = true
2015-04-07 21:23:34.186 Apploader[11253:303] Recv: . [0x00] 
2015-04-07 21:23:34.187 Apploader[11253:303] stk500_getsync() attempt 1 of 5: not in sync: resp=0x00
</code></pre>

<p>Once again - bootloader stops listening in 200 ms instead of 1-1.5 secons as over USB:</p>

<pre><code>2015-04-07 21:23:33.596 Apploader[11253:303] Send: A [0x41] T [0x54] + [0x2b] R [0x52] E [0x45] S [0x53] E [0x45] T [0x54] 
...
2015-04-07 21:23:33.780 Apploader[11253:1503] Rx value received 6 bytes: r [0x72] e [0x65] a [0x61] d [0x64] y [0x79] . [0x0a]
</code></pre>

<p>I expect bootloader to reply with 0x14 0x10 as over USB:</p>

<pre><code>2015-04-07 21:22:13.978 Apploader[11226:303] Send: 0 [0x30]   [0x20] 
2015-04-07 21:22:13.979 Apploader[11226:303] Recv: . [0x14] 
2015-04-07 21:22:13.980 Apploader[11226:303] Recv: . [0x10] 
</code></pre>

<p>As you can see later communication over Bluetooth is working good, as i receive exactly what was sent (0x30 0x20)</p>

<p>So when sketch is launched it's ok.</p>

<p>My ideas what's wrong:</p>

<ol>
<li>baud rate</li>
</ol>

<p>Since serial.begin(N) is invoked after bootloader stops and launch sketch bootloader by default uses another baud rate? Is it correct? HM-10 default daud rate is 9600 and in sketch i also use 9600. </p>

<ol start=""2"">
<li>wrong wire connection?</li>
</ol>

<p>Bluetooth-arduino:
rx -> tx
tx -> rx
Since its working for sketch i believe it's ok. Do i need any capacitors or resistors?</p>

<p>Any thoughts are highly appreciated!</p>

<p><strong>UPDATE</strong>:</p>

<p>It seems i've found <a href=""https://github.com/arduino/Arduino/blob/master/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168.c"" rel=""nofollow"">Uno bootloader source code</a> and bootloader baud rate is 19200 by default</p>

<pre><code>/* set the UART baud rate */
/* 20060803: hacked by DojoCorp */
//#define BAUD_RATE   115200
#ifndef BAUD_RATE
#define BAUD_RATE   19200
#endif
</code></pre>

<p><strong>UPDATE2</strong>:</p>

<p>I'm in stuck as in this tutorial 115200 is used:
<a href=""http://makezine.com/projects/diy-arduino-bluetooth-programming-shield/"" rel=""nofollow"">http://makezine.com/projects/diy-arduino-bluetooth-programming-shield/</a></p>

<p>in step 8. ""build the programmer circuit"" R1 2.2K is set on arduino rx pin. Why? Another thing i can't understand is that SoftwareSerial baud rate is set to 38400 but BT module baud rate is set 115200 using ""AT"" command. why?</p>
"
"<p>Your assumption that a high is required to light a LED is false. All you need is to meet certain minimum voltage and current thresholds. Since the anode of the LED is tied high, <a href=""http://www.sysrecon.com/electronics/how-to-use-light-emitting-diodes-leds/"" rel=""nofollow"">the way to meet these</a> is to bring the cathode low.</p>

<p><a href=""http://www.sysrecon.com/electronics/how-to-use-light-emitting-diodes-leds/"" rel=""nofollow""><img src=""http://i.stack.imgur.com/Z9V7P.png"" alt=""LED symbol""></a></p>
"
""
An IC that offers Wi-Fi networking compatible with b/g/n standards. It also has integrated TCP/IP protocol stack. Extremely popular along IoT community as a low cost and powerful board. 
"<p>I just bought an Arduino Mega2560 R3 and it doesn't connect to my Laptop. The connection is somewhat random, sometimes it connects and sometimes it doesn't.</p>

<p>Can someone help me identify whats the problem?</p>

<p>When it gets connected I can upload sketches.</p>

<p>I would like to remove the Atmega 16U2 and replace it with ftdi USB to Serial, would it be possible?</p>
"
"<p>You can use your USB/Serial adapter to program the 2560 as the Arduino uses the 16u2 as the same thing to program the mega. You shouldn't remove the 16u2, just wait till you get the programmers and reflash the 16u2 with its firmaware and it will work, I actually had the same problem where the DFU didn't work and the 16u2 stopped responding, after reflashing the firmware it worked. The firmaware can be found under(as of 1.6.0):</p>

<p><code>...\Arduino\hardware\arduino\avr\firmwares\atmegaxxu2\MEGA-dfu_and_usbserial_combined.hex</code> </p>

<p>You need to connect the Serial pins on the FTDI and Mega in the below fashion:</p>

<pre><code> FTDI           MEGA
 GND&lt;-----------&gt;GND
 CTS&lt;-----------&gt;GND
 VCC&lt;-----------&gt;VCC
 TXD&lt;-----------&gt;RX0
 RXD&lt;-----------&gt;TX0
 RTS/DTR&lt;---||--&gt;RST
</code></pre>

<p>The Capacitor between the <code>DTR</code> pin and <code>RST</code> pin are needed this should be 100nF.</p>

<p><img src=""http://i.stack.imgur.com/6oMHQ.jpg"" alt=""enter image description here""></p>

<blockquote>
  <p>I have bought an I |SP programmer but it will take 3 weeks to reach and no I dont have another arduino, TBH I'm scared to buy another one... –  echo_salik</p>
</blockquote>

<p>If you are buying clones, those will more than likely give issues as they will be cutting back on costs in places, i.e. QC checks.</p>
"
"<p>How can I fix this sketch to make it so that once the button is pressed, it performs some action for a certain amount of time and then returns back to a low state until it is pressed again. For example, I need to run a pump for 5 seconds when the button is pressed and then turn off automatically. And then, when I press the button again it will repeat, etc. I am not trying to use a relay module if it is not necessary. Here is my current sketch and a Lab View of the components: </p>

<p><a href=""http://i.stack.imgur.com/P3fk0.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/P3fk0.png"" alt=""My Sketch""></a></p>

<pre><code>#include &lt;LiquidCrystal.h&gt;
#include &lt;SoftwareSerial.h&gt;


int switchPin = 8;
int ledPin = 13;
int buttonPresses = 0;
boolean lastButton = LOW;
boolean currentButton = LOW;
boolean ledOn = false;

LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

void setup()
{
  Serial.begin(9600);
  pinMode(switchPin, INPUT);
  pinMode(ledPin, OUTPUT);
  lcd.begin(16, 2);
}

boolean debounce(boolean last) //just a debounce function
{
  boolean current = digitalRead(switchPin);
  if (last != current)
  {
    delay(5);
    current = digitalRead(switchPin);
  }
  return current;
}

void loop()
{
  {currentButton = debounce(lastButton);
  if (lastButton == LOW &amp;&amp; currentButton == HIGH)
  {
    ledOn = !ledOn;

    buttonPresses++;
    lcd.clear();
    lcd.print(""Number of Button "");
    lcd.setCursor(0,1);
    lcd.print(""Presses = "");
    lcd.print(buttonPresses);  
  }
   lastButton = currentButton;
   digitalWrite(ledPin, ledOn);
  }
}
</code></pre>

<p>THANK YOU!</p>
"
"<p>This code should work. You will need to declare the following variables:</p>

<ul>
<li>lastPress   // The last time the button was pressed</li>
<li>outputState  // The state of the timed output </li>
<li>outputPin  // The pin number for the timed output</li>
<li>PERIOD  // The amount of time that the outptu remains on</li>
</ul>

<p>The code:</p>

<pre><code>void loop()
{
    currentButton = debounce(lastButton);
    if (lastButton == LOW &amp;&amp; currentButton == HIGH)
    {
        ledOn = !ledOn;

        buttonPresses++;
        lcd.clear();
        lcd.print(""Number of Button "");
        lcd.setCursor(0,1);
        lcd.print(""Presses = "");
        lcd.print(buttonPresses);

        outputState = HIGH;
        lastPress = millis();  
    }

    if (outputState &amp;&amp; ((millis() - lastPress) &gt; PERIOD))
    {
        outputState = LOW;
    }

    digitalWrite(outputPin, outputState);

    lastButton = currentButton;
    digitalWrite(ledPin, ledOn);
}
</code></pre>

<p>A relay should be used to drive a pump etc.. The Arduino Uno can only drive 5V at maximum 20mA.</p>
"
"<p>I'm trying to port some Arduino code that I wrote for the Arduino Mega to an ATtiny and I'm having trouble figuring out how to do output. Here is what I have:</p>

<pre><code>char foo;
#include &lt;SoftwareSerial.h&gt;
const int rx=3;
const int tx=4;

SoftwareSerial mySerial(rx,tx);

void setup() 
{ 
mySerial.begin(9600);
} 

void loop() {
 if (mySerial.available()) {
   char data = mySerial.read();
   mySerial.write(data);
 }

 mySerial.println(""hello"");
}
</code></pre>

<p>To my understanding this should print ""hello"" to the console over and over again but for some reason it uploads successfully but then it doesn't do anything.</p>

<p>Here is the programmer that I am using to connect my ATtiny to my computer: <a href=""https://learn.sparkfun.com/tutorials/tiny-avr-programmer-hookup-guide/programming-in-arduino"" rel=""nofollow"">https://learn.sparkfun.com/tutorials/tiny-avr-programmer-hookup-guide/programming-in-arduino</a></p>
"
"<p>This is writing serial data to digital pin 4. If you have a serial to USB converter attached to pins 3,4 and you have a terminal attached to said serial to USB converter, it will print to that terminal.</p>

<p>Also, on an ATtiny, you have to check which pins are pins 3,4. They are probably not the physical pins 3,4, and it is dependent on which pin mappings you are using (dependent on ATtiny libraries).</p>
"
"<p>You don't have any output because you don't have a serial adapter connected to the device. The programmer you have is only for programming and does not support a UART serial connection.</p>
"
"<p>I have a fan control circuit with Arduino(pwm). I did all things and it worked. My question is why we did not directly connect the fan to Arduino. Why should we have a driver circuit?</p>

<p><img src=""http://i.stack.imgur.com/Oa8rY.png"" alt=""""></p>
"
"<p>This is an electronics question, and it should be forwarded to the electronics stackexchange.</p>

<p>The fan needs to have a proper amount of current to spin, and because the microcontroller that controls the fan draw very little current on its output pins (check the datasheet for the exact value, but it should be a few milliamps), unless you have a miniature fan, wiring it directly on the microcontroller will not be able to move the fan.</p>

<p>And this is by design that microcontrollers cannot provide much current. Because to provide larger amount of current than what they do, they'd need to have bigger copper tracks between the transistor to avoid having they internal circuits building too much heat, and they would be much much bigger.</p>

<p>So as a work around, we use an transistor, which receives on the ""Base"" pin a voltage, drawing almost no current, which will ""connect"" the collector and emitter pins where you can have a much bigger current flowing (though be careful to respect the datasheet's nominal values for current! Or use either a MOSFET, a Triac or a Relay for bigger currents).</p>
"
"<p>Arduino is a low voltage and low current device. Arduino max current output delivery capecity is 200ma, you can read about diffrent arduino's limitations here,
<a href=""http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations"" rel=""nofollow"">http://playground.arduino.cc/Main/ArduinoPinCurrentLimitations</a></p>

<p><strong>Fan or anything that</strong> has a coil inside it, needs a huge amount of current during their start up. The current draw decreases as it gains its motion to some limit. The initial huge current is called <strong>surge current</strong>. There is a high chance that it will blow you pins dead.</p>

<p>Let's say we are using really small fan. And it managed to start and rotating, that dosen't meant there is no problem at all. When a coil is rotated inside a magnetic field an opposite voltage is induced called <strong>Back Emf</strong> . This is <strong>another</strong> huge <strong>potential concern</strong>. This is why we are always suggested to use a <strong>diode</strong> which will <strong>block</strong> the opposite flow of <strong>current</strong>. </p>

<p><strong>Transistor</strong>, being a low voltage device and as it can deliver tremendous large amount of output current, It is very widely used to drive high current devices</p>
"
"<p>I have been working on this a while and I cannot seem to figure it out. Essentially, I am using the app/server Blynk and their Terminal Widget to sent String inputs to my Arduino board. My code is below:
<code>
  String INFO;
  String fromTerminal = param.asStr();
  int indexstart = fromTerminal.indexOf("","");
  int indexend = fromTerminal.lastIndexOf("","");
  int counter = indexstart - indexend;
  INFO[counter] = fromTerminal;</code></p>

<p>My thoughts on the code was, based on the number of "","" I enter in the string then that will assign my input to an index within the INFO array. However as I have tried several different things, I constantly get errors such as:
cannot convert 'String' to 'char' in assignment.
Oddly enough if I set: INFO[counter] = fromTerminal.toInt();
I dont get an error but I dont think that will allow me to print out my actual input. Any help is much appreciated, thanks!</p>
"
"<p>I know this thread may be dead but if it happens to somebody, the aformentioned method works perfectly fine. You just need to disable timer0 (power_timer0_disable();) and then your 40kHz signal will not fluctuate (in frequency). </p>

<p>In any case, yeah try to avoid digitalWrite if you want speed.</p>
"
"<p><code>Serial.parseInt()</code> reads from the serial buffer until it sees a non-numeric character or it's timeout is reached. When I use it, I put a space after the last number to make it return faster. Can I change the timeout so if I forget the number it doesn't take as long?</p>
"
"<p>Don't use <code>Serial.parseInt()</code>. It is very very wrong. The whole idea behind how it operates is completely wrong and teaches bad practices and methods.</p>

<p>Part of your way of speeding it up is half-way to doing it properly.</p>

<p>You require a delimiter to say ""this is the end of the number"". Relying on time in a system that is inherently asynchronous is just plain daft. You have chosen to add a space. A better choice is to use a proper line ending ""\n"".</p>

<p>Then you should either read the serial character-by-character and parse it as it arrives until you find the EOL character, or read it character by character into a string (NOT a String, a ""string"" - a C string - a character array terminated by a NULL character), and then use <code>atoi()</code> etc to convert it to the numerical format you want.</p>

<p>Many of the methods that Arduino provide are not suitable for professional use and should be avoided at all cost lest they teach you the completely wrong way of doing things.</p>
"
"<p>This is a rotary encoder.I need to turn a stepper motor according to this encoder with some controlling buttons using Arduino.
I don't know about this rotary encoder parameters.
<a href=""http://i.stack.imgur.com/Y4IFS.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/Y4IFS.jpg"" alt=""Page1""></a>
<a href=""http://i.stack.imgur.com/9eVKe.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/9eVKe.jpg"" alt=""Page2""></a></p>
"
"<p>It looks like I have the same problem. 
I used the ""ESP8266_Shield_Demo_Sparkfun"" and often the webpage shows not a proper output (""AT.."" commands instead). How did you adatp the baud rate in the ""SparkFunESP8266WiFi.h""?
Thanks!</p>
"
"<p>I am a complete newbie to Arduino and I just received an ARDX arduino starter kit (the one that comes in the transparent green case)
I have been following the instructions for Circ-01 for the blinking led light but I am curious about the wires. In the breadboard instructional picture it shows a purple wire that is supposed to connect to pin 13 on the arduino. But the kit did not come with a purple wire, it only came with black, red, white, yellow, and green wires. </p>

<p>I also tried following a tutorial on YouTube and the guy in the video used a purple wire that he said was the led ""cathode""</p>

<p>Can i substitute another wire for the purple and? Or did I receive an incomplete kit? I am very confused and the breadboard instruction picture is not very clear. </p>

<p>Thanks for any help!</p>
"
"<p>Personally I like to try to use red wires for +5V, black or blue for ground, and yellow for data. However as Majenko said in a comment, the colour is irrelevant to the operation.</p>

<p>The usefulness of colour is just that if you stick to a system (like red for +5V and black for ground) then there is a visual check you make when connecting up a circuit, so you don't accidentally put things in backwards, like you might if every wire is yellow.</p>

<p>Also, if you run half-a-dozen wires from one place to another, using different colours is another way of making it easier to see you have connected the correct things together.</p>

<p>Having said all that, the colour does not otherwise affect things.</p>
"
"<p>You can, just call </p>

<pre><code>Serial.setTimeout(millisecondValue);
</code></pre>

<p><a href=""https://www.arduino.cc/en/Serial/SetTimeout"" rel=""nofollow"">https://www.arduino.cc/en/Serial/SetTimeout</a></p>

<p>It defaults to one second, and controls the timeouts for readBytes, readBytesUntil, parseInt and parseFloat.</p>
"
"<p>I'm trying to make an OO state machine based program to play music and lights at the same time. It uses the FastLED library and a 13 pixel neopixel strip.  I've confirmed that with the currently wired setup that I can separately play music and also separately run the FastLED Cylon example code. However when I upload the code below it just kinda hangs out and doesn't do anything and doesn't even print the statements in the setup statement.  The weird thing is that if I comment out the Lights lightstrip1() instantiation line and the lightstrip.Update() line, it does play the melody part ok.</p>

<pre><code>#include ""pitches.h""
#include ""FastLED.h""

class Melody{

// notes in the melody Minuet in G.
int melody[126] = {
  NOTE_D4, NOTE_G3, NOTE_A3, NOTE_B3, NOTE_C4, 
  NOTE_D4, NOTE_G3, NOTE_G3, 
  NOTE_E4, NOTE_C4, NOTE_D4, NOTE_E4, NOTE_FS4,
  NOTE_G4, NOTE_G3, NOTE_G3,

  NOTE_C4, NOTE_D4, NOTE_C4, NOTE_B3, NOTE_A3,
  NOTE_B3, NOTE_C4, NOTE_B3, NOTE_A3, NOTE_G3,
  NOTE_FS3,NOTE_G3, NOTE_A3, NOTE_B3, NOTE_G3,
  NOTE_A3,

  NOTE_D4, NOTE_G3, NOTE_A3, NOTE_B3, NOTE_C4, 
  NOTE_D4, NOTE_G3, NOTE_G3, 
  NOTE_E4, NOTE_C4, NOTE_D4, NOTE_E4, NOTE_FS4,
  NOTE_G4, NOTE_G3, NOTE_G3,

  NOTE_C4, NOTE_D4, NOTE_C4, NOTE_B3, NOTE_A3,
  NOTE_B3, NOTE_C4, NOTE_B3, NOTE_A3, NOTE_G3,
  NOTE_A3, NOTE_B3, NOTE_A3, NOTE_G3, NOTE_FS3,
  NOTE_G3,

 // Second part
  NOTE_B4, NOTE_G4, NOTE_A4, NOTE_B4, NOTE_G4,
  NOTE_A4, NOTE_D4, NOTE_E4, NOTE_FS4, NOTE_D4,
  NOTE_G4, NOTE_E4, NOTE_FS4, NOTE_G4, NOTE_D4,
  NOTE_CS4, NOTE_B3, NOTE_CS4, NOTE_A3,
  NOTE_A3, NOTE_B3, NOTE_CS4, NOTE_D4, NOTE_E4, NOTE_FS4,
  NOTE_G4, NOTE_FS4, NOTE_E4,
  NOTE_FS4, NOTE_A3, NOTE_CS4,
  NOTE_D4,

  // BACK TO G MAJOR!!!!
  NOTE_D4, NOTE_G3, NOTE_FS3, NOTE_G3,
  NOTE_E4, NOTE_G3, NOTE_FS3, NOTE_G3,
  NOTE_D4, NOTE_C4, NOTE_B3,
  NOTE_A3, NOTE_G3, NOTE_FS3, NOTE_G3, NOTE_A3,
  NOTE_D3, NOTE_E3, NOTE_FS3, NOTE_G3, NOTE_A3, NOTE_B3,
  NOTE_C4, NOTE_B3, NOTE_A3,
  NOTE_B3, NOTE_D4, NOTE_G3, NOTE_FS3,
  NOTE_G3



  };

// note durations: 4 = quarter note, 8 = eighth note, etc.:
float noteDurations[126] = {
  4, 8,8,8,8,
  4, 4, 4,
  4, 8,8,8,8,
  4, 4, 4,
  4, 8,8,8,8,
  4, 8,8,8,8,
  4, 8,8,8,8,
  1.5,

  4, 8,8,8,8,
  4, 4, 4,
  4, 8,8,8,8,
  4, 4, 4,
  4, 8,8,8,8,
  4, 8,8,8,8,
  4, 8,8,8,8,
  1.5,

  // Second part

  4, 8,8,8,8,
  4, 8,8,8,8,
  4, 8,8,8,8,
  4, 8,8, 4,
  8,8,8,8,8,8,
  4, 4, 4,
  4, 4, 4,
  1.5,
  4, 8,8, 4,
  4, 8,8, 4,
  4, 4, 4,
  8,8,8,8, 4,
  8,8,8,8,8,8,
  4,4,4,
  8,8,4,4,
  1.5
  };


  unsigned long OnTime;  // This will be the time in millis to turn on a note.
  unsigned long OffTime; // This will be the time in millis to turn off a note.

  int ToneState;
  unsigned long previousMillis;

  int speakerPin;
  int noteNumber;
  int maxNoteNumber;

  public:
  Melody(int pin) {
     speakerPin = pin;
     pinMode(speakerPin, OUTPUT);
     previousMillis = 0;  
     OnTime = previousMillis;
     ToneState = 0; // Off
     noteNumber = 0; // Start at the first note.
//     maxNoteNumber = sizeof(noteDurations); // This turns out to 504 for some reason.
     maxNoteNumber = 125;

  }


  void Update() {
     unsigned long currentMillis = millis();

     if (ToneState == 0 &amp;&amp; currentMillis &gt;= OnTime) {
       tone(speakerPin, melody[noteNumber]);
       OffTime = currentMillis + (1000 / noteDurations[noteNumber]);
       ToneState = 1;
       Serial.print(noteNumber);
       Serial.print(""/"");
       Serial.println(maxNoteNumber);

     } else if (ToneState == 1 &amp;&amp; currentMillis &gt;= OffTime) {
       noTone(speakerPin);
       OnTime = currentMillis + ((1000 / noteDurations[noteNumber]) * 0.30);
       ToneState = 0;
       if (noteNumber &lt; maxNoteNumber) {
         noteNumber += 1;
       } else {
         Serial.println(""RESET"");
         noteNumber = 0; // Reset to the begining of the song.
       }
     } 
  }
};

class Lights {
    int ledPin;
        int ledCount;
    unsigned long NextOn;
        int led_R;
        int led_G;
        int led_B;

        CRGB leds[12];

    int ledOn;
        int lightdelay;

    public:
    Lights(int pin, int ledcount, int led_r, int led_g, int led_b) {
      ledPin = pin;
      pinMode(ledPin, OUTPUT);
      digitalWrite(ledPin, LOW);
      ledCount = ledcount;
      led_R = led_r;
      led_G = led_g;
      led_B = led_b;
      ledOn = 0;
      lightdelay = 100;
      NextOn = 0;
      FastLED.addLeds&lt;NEOPIXEL, 7&gt;(leds, ledCount); // It complains if I try to use a variable for the 7. It has to be a constant.
      for (int i = 0; i &lt; ledCount; i++) {
        leds[i] = CRGB::White;
      }
      FastLED.show();
    }

    void Update() {
      unsigned long currentMillis2 = millis();

      if (currentMillis2 &gt; NextOn) {
         if (ledOn &gt;= ledCount) {
           leds[ledOn] = CRGB::Black;
           ledOn = 0;
           leds[ledOn] = CRGB::Red;
         } else if (ledOn == 0) {
           leds[ledCount - 1] = CRGB::Black;
           leds[ledOn] = CRGB::Red; // Need to put RGB to HSV converter in later.
         } else {
           leds[ledOn - 1] = CRGB::Black;
           leds[ledOn] = CRGB::Red; // Need to put RGB to HSV converter in later.
         }
         Serial.print(""LED: "");
         Serial.println(ledOn);
         Serial.println(NextOn);
         FastLED.show();
         NextOn = currentMillis2 + lightdelay;
         ledOn++;
      } 
    }

};


Melody melody1(2);

Lights lightstrip1(7, 12, 250, 0, 0);

void setup() {
  Serial.begin(115200);
  Serial.println(""Started"");
}

void loop() {
   melody1.Update();
   lightstrip1.Update();
}
</code></pre>

<p>Any ideas?</p>
"
"<p>Yes, using a state machine and some object oriented programming. I'd recommend reading this tutorial as it explains the process very well and has plenty of examples.</p>

<p><a href=""https://learn.adafruit.com/multi-tasking-the-arduino-part-1/ditch-the-delay"" rel=""nofollow"">https://learn.adafruit.com/multi-tasking-the-arduino-part-1/ditch-the-delay</a></p>
"
"<p>I am working on arduino Uno board.I am trying to send request Serially from out Side using docklight.I am sending COmmand  is request send every 5S to 10S and get response.When i tested this code with arduino Uno board its working fine. When i tested same code with Customised board whos schematic as below
<a href=""http://i.stack.imgur.com/shBjT.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/shBjT.jpg"" alt=""Schemactic""></a>. For this i got response like this. I am suspecting it might be issue with crystal. I have replace KDS16 with SCTF16.00crystals . It behave same.Can someone suggest what might be wrong</p>

<p><a href=""http://i.stack.imgur.com/yjF0a.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/yjF0a.jpg"" alt=""Respose""></a></p>

<p><a href=""http://i.stack.imgur.com/iFb0I.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/iFb0I.jpg"" alt=""enter image description here""></a></p>

<p>My code </p>

<pre><code>#include ""glob.h""
const int BUFFER_SZ = 32;
char sendBuffer[200]; 
static int OverRide=0;

void Take_Reading() {

  for (int row = 0; row &lt; 8; row++)
  {
    //   // get rid of me:
    digitalWrite(SO_enable, array[row][0]);
    digitalWrite(S1_enable, array[row][1]);
    digitalWrite(S2_enable, array[row][2]);
    delay(50);
    analog_1_pv[row] = ANALOG_SCALING * analogRead(A0);
    analog_2_pv[row] = ANALOG_SCALING * analogRead(A1);
    analog_3_pv[row] = ANALOG_SCALING * analogRead(A2);
    if ( (analog_1_pv[row] &lt;= MINV_RANGE || (analog_1_pv[row] &gt;= MAXV_RANGE) ))
    {
      Current_Value1[row] =  0.0;
    }
    else
    {
      Current_Value1[row] =  (analog_1_pv[row] * 12.5) - 31.25;

    }

    if (  (analog_2_pv[row] &lt;= MINV_RANGE || (analog_2_pv[row] &gt;= MAXV_RANGE) ))
    {
      Current_Value2[row] =  0.0;
    }
    else
    {
      Current_Value2[row] =  (analog_2_pv[row] * 12.5) - 31.25;

    }

    if (  (analog_3_pv[row] &lt;= MINV_RANGE || (analog_3_pv[row] &gt;= MAXV_RANGE) ))
    {
      Current_Value3[row] =  0.0;
    }
    else
    {
      Current_Value3[row] =  (analog_3_pv[row] * 12.5) - 31.25;

    }


    Mod_current[row] = (uint16_t)(Mul_Factor * Current_Value1[row]);
    Mod_current[row + 8] = (uint16_t)(Mul_Factor * Current_Value2[row]);
    Mod_current[row + 16] = (uint16_t)(Mul_Factor * Current_Value3[row]);


  }

}









int ID_Check() {

  int ID_value;
  for (int row = 0; row &lt; 8; row++)
  {
    digitalWrite(SO_enable, array[row][0]);
    digitalWrite(S1_enable, array[row][1]);
    digitalWrite(S2_enable, array[row][2]);
    Status_Out[row] = digitalRead(Output_Read);

  }

  ID_value = 1 * Status_Out[7] + 2 * Status_Out[6] + 4 * Status_Out[5] + 8 * Status_Out[4] + 16 * Status_Out[3] + 32 * Status_Out[2] + 64 * Status_Out[1] + 128 * Status_Out[0];
  return (ID_value);

}




int  Take_Temp_Reading()
{

  Temp_Total = Temp_Total - Temp_readings[Temp_index];
  Temp_readings[Temp_index] = analogRead(A5);
  Temp_Total = Temp_Total + Temp_readings[Temp_index];
  Temp_index = Temp_index + 1;

  if (Temp_index &gt;= numReadings)
  {
    Temp_index = 0;
    Temp_Average = Temp_Total / numReadings;
  }
  temp = (Temp_Average * 5.0) / 1023.0;


  //  temp = float(analogRead(A5)) * 5.0 / 1024.0;
  temp_int = (int)(temp * 100.0);
  return (temp_int);
  // Serial.print(""Temp""); Serial.println(temp);
}

int SPD_Check()
{

  SPD_STATUS = digitalRead(SPD_STATUS_PIN);
  return (SPD_STATUS);
}

int  DC_Status()
{

  DC_STATUS = digitalRead(DC_STATUS_PIN);
  return (DC_STATUS);

}



int   Take_HV_Reading()
{

  //int analog_int= analogRead(A4);

  total = total - readings[index];
  // read from the sensor:
  readings[index] = analogRead(A4);
  // add the reading to the total:
  total = total + readings[index];
  // advance to the next position in the array:
  index = index + 1;

  // if we're at the end of the array...
  if (index &gt;= numReadings1)
  {
    index = 0;
    average = total / numReadings1;

  }
  else
  {

    HV_voltage = (average * 5.0) / 1023.0;
  }
  if (HV_voltage &lt;= 0.25)
  {

    Conv_HV_voltage = 0.0;
  }
  else
  {
    Conv_HV_voltage = 197.837837838 * HV_voltage + 10.8108108108;
  }

  HV_Reading = (uint16_t)(Conv_HV_voltage * 10);

  //  HV_Reading = (uint16_t)(Conv_HV_voltage * 10);

  return(HV_Reading);
}


void  Serial_Command1()

{
  Take_Reading();
  int Temp_read=Take_Temp_Reading();
  int HV_Read=Take_HV_Reading();
  SPD=SPD_Check();
  DISCONNECTOR=DC_Status();
  // Device_ID=ID_Check();
  Device_ID=1;
  Serial.print(""SMCB1"");
  Serial.print("","");
  Serial.print(Device_ID);
  Serial.print("","");
  for (int i = 0; i &lt; 14; i++) {
    Serial.print(Mod_current[i]);
    Serial.print("","");
  }

  for (int i = 23; i &gt; 13; i--) {
    Serial.print(Mod_current[i]);
    Serial.print("","");
  }

  Serial.print(Temp_read);
  Serial.print("","");
  Serial.print(HV_Read);
  Serial.print("","");
  Serial.print(SPD);
  Serial.print("","");
  Serial.print(DISCONNECTOR);
  Serial.print("","");
  Serial.print(DISCONNECTOR);
  Serial.print("","");
  Serial.println(""END"");
}

void Serial_Command2(int a)
{
  Take_Reading();
  int Temp_read=Take_Temp_Reading();
  int HV_Read=Take_HV_Reading();
  SPD=SPD_Check();
  DISCONNECTOR=DC_Status();
  Device_ID=1;
  // Serial.print(""Command2 executed: "");
  snprintf(sendBuffer, a, ""SMCB1,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d ,END"",Device_ID,
  Mod_current[0], Mod_current[1], Mod_current[2], Mod_current[3],
  Mod_current[4], Mod_current[5], Mod_current[6], Mod_current[7],
  Mod_current[8], Mod_current[9], Mod_current[10], Mod_current[11],
  Mod_current[12], Mod_current[13], Mod_current[14], Mod_current[23],
  Mod_current[22], Mod_current[21], Mod_current[20], Mod_current[19],
  Mod_current[18], Mod_current[17], Mod_current[16], Mod_current[15],
  Mod_current[14], Temp_read, HV_Read, SPD, DISCONNECTOR);
  Serial.println(sendBuffer);
  //Serial.println(a);
}





void setup()
{
  Serial.begin(57600);
  Serial.println(""Format 1: &lt;SMCB1,1&gt;"");
  Serial.println(""Format 2: &lt;SMCB1,1,Length&gt;"");
  Serial.println(""Format 2: &lt;SMCB1,1,Length,ON&gt; ON- turn on timer ,off to turn off timer"");
}

// Parse the request, WITHOUT the '&lt;' and '&gt;' delimiters.
void parseRequest(char *request)
{
  // Check the request starts with the prefix ""SMCB1,1"".
  if (strncmp(request, ""SMCB1,1"", 7) != 0) {
    Serial.println(F(""Error: bad request prefix""));
   //  Serial_Command1();
    return;
  }

  // Remove that known prefix.
  // Now we have either """", "",Length"" or "",Timer,On_OFF""
  request += 7;

  // Format 1: """"
  if (request[0] == '\0') {
    //Serial.println(F(""Received format 1""));
    Serial_Command1();
    return;
  }

  // Remove the leading comma.
  // Now we have either ""Length"" or ""Timer,On_OFF""
  if (request[0] != ',') {
    Serial.println(F(""Error: ',' expected""));
    return;
  }
  request++;

  // Format 2: ""Length"", no comma.
  char * comma = strchr(request, ',');
  if (!comma) {

    int length = atoi(request);
    Serial_Command2(length);
    //Serial.print(F(""Received format 2, length = ""));
    // Serial.println(length);
    return;
  }

  // format 3
  int timer = atoi(request);
  char * on_off = comma + 1;
  char * Compare=""ON"";
  bool on = strcmp(on_off, ""ON"") == 0;
  if (!on &amp;&amp; strcmp(on_off, ""OFF"") != 0) {  // sanity check
    Serial.println(F(""Error: expected either ON or OFF""));
    return;
  }
  /*  Serial.print(F(""Received format 3, timer = ""));
   Serial.print(timer);
   Serial.print(F("", on_off = ""));
   Serial.println(on ? ""ON"" : ""OFF"");
   Serial.println(on_off);
   Serial.println(Compare);*/
  int v = strcmp(on_off, Compare);
  if(v==0)
  {
    Serial.println(""Timer is on"");
    OverRide=1;

  }
  else
  {
    Serial.println(""Timer is OFF"");
    OverRide=0;
  }

}

void loop()
{
  static char buffer[BUFFER_SZ];  // received chars
  static size_t pos;              // current position in buffer
  static bool insideRequest;      // are we between '&lt;' and '&gt;'?

  if (Serial.available()) {
    char c = Serial.read();
    if (insideRequest) {
      if (c == '&gt;') {  // end of request received
        buffer[pos] = '\0';  // terminate the string
        parseRequest(buffer);
        pos = 0;             // get ready for the next request
        insideRequest = false;
      }
      else if (pos &lt; BUFFER_SZ-1) {  // add char to buffer
        buffer[pos++] = c;
      }
    }
    else if (c == '&lt;') {  // start of request
      insideRequest = true;
    }



  }


}
</code></pre>
"
"<p>Stumbled on good tutorial here, tried and it does the job:
<a href=""https://blogs.msdn.microsoft.com/abhinaba/2016/01/23/esp8266-wifi-with-arduino-uno-and-nano/"" rel=""nofollow"">https://blogs.msdn.microsoft.com/abhinaba/2016/01/23/esp8266-wifi-with-arduino-uno-and-nano/</a></p>
"
"<p>Yes, if you are using different power sources the grounds always have to be connected, otherwise the boards don't know what zero volts is.</p>

<p>The TX of the Arduino is 5v, you need a level shifter to convert 5v to 3.3v, something like this (<a href=""https://shop.pimoroni.com/products/adafruit-4-channel-i2c-safe-bi-directional-logic-level-converter?utm_medium=cpc&amp;utm_source=googlepla&amp;variant=302017581&amp;gclid=CPqujsPxlc0CFcYcGwodb8YIoA"" rel=""nofollow"">https://shop.pimoroni.com/products/adafruit-4-channel-i2c-safe-bi-directional-logic-level-converter?utm_medium=cpc&amp;utm_source=googlepla&amp;variant=302017581&amp;gclid=CPqujsPxlc0CFcYcGwodb8YIoA</a>)</p>

<p>The TX of the ESP8266 is 3.3v and the RX of the Arduino is 5V and you will need a level shifter to handle this.  You can use the same one as listed above, because it can convert 4 high (5v) signals into 4 low (3.3v) signals.</p>

<p>People say you can so it with resistors, but I have also read that they don't perform well enough to handle fast switching digital signals (so 300 Baud on your serial might be OK, but not 115000 :) )</p>

<p>People also say you don't need level convertors.  That's true things <em>might</em> work for a while without them, but sooner or later something will go pop.  Increasing the voltage will speed up the process so you can imagine what will happen if you connected a 230v supply directly to a USB device.</p>

<p>One final point, do you know the ESP8266 is a 80/160MHz processor with 256KB of RAM, when you compare that to you Arduino its like programming you PC via your phone.  What you could try is connecting the ESP8266 via a FTDI module and program it via the Arduino IDE in Arduino C.  Its a lot easier than all this connection stuff.</p>
"
"<p>I'm trying to convert this array <code>uint8_t data[]</code> in the code below to a character array to be printed in the serial monitor. However, when I run this code I see a blank screen. What am I doing wrong?</p>

<pre><code>Serial.begin(115200);
uint8_t data[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x00,0x01,0x02,0x03,0x04,0x05};
Serial.println((char*)data);
</code></pre>
"
"<p>The WS2812 device requires precise timing down to +/- 150 x 10<sup>-9</sup> seconds.  For details look at <a href=""http://cdn.sparkfun.com/datasheets/Components/LED/WS2812.pdf"" rel=""nofollow"">this</a> chip specification.  As such, it is likely the FastLED library uses processor resources that can not be shared.  Look through the <a href=""https://github.com/FastLED/FastLED"" rel=""nofollow"">FastLED library's code</a> to verify this.</p>

<p>It appears your sketch plays a note, changes the LED pattern then repeats this cycle.  Assuming the resources for FastLED are initialized in the constructor of the library, you might consider destroying and re-instantiating the FastLED class for each of these cycles.  </p>

<p>added later...</p>

<p>Comments about memory space and large amounts of static data in the sketch have merit.  Consider moving your static (unchanging) data from limited RAM to FLASH memory.  <a href=""https://www.arduino.cc/en/Reference/PROGMEM"" rel=""nofollow"">This</a> resource explains how this is accomplished. </p>
"
"<p>When you cast as <code>char *</code>, <code>println</code> thinks you are passing it a string. It will try to print it as a string and stop on the first <code>0x00</code>.</p>

<p>You can use <a href=""https://www.arduino.cc/en/Serial/Write"" rel=""nofollow""><code>Serial.write</code></a> to send the array as integers (no conversion):</p>

<pre><code>Serial.write(data, sizeof(data));
</code></pre>

<p>If you want to send the ASCII representation of these numbers, use a loop. <a href=""https://www.arduino.cc/en/Serial/Print"" rel=""nofollow""><code>Serial.print</code></a> will convert:</p>

<pre><code>int count = sizeof(data) / sizeof(data[0]);
for (int i = 0; i &lt; count; i++) {
    Serial.print(data[i]);
}
Serial.println();
</code></pre>
"
"<p>To print numbers, integers have to be converted to <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a> code.  To accomplish this add 0x30 to each value.  Note, this (only) works for numbers between 0 and 9 as the ASCII value for zero is 0x30.  Good code will check to make sure only the values 0 through 9 are being processed.</p>

<p>When creating a character string you need to identify the end using the NULL character.  Before using an array of characters, set the array position after the last desired character equal to NULL or 0x00. Terminating the string is explained further in <a href=""https://startingelectronics.org/software/arduino/learn-to-program-course/18-strings/"" rel=""nofollow"">this</a> article.</p>
"
"<p>The easiest way to work with these devuces is to connect them to a spare pair of Arduino pins and use SoftwareSerial for communicating (unless you're using one of the Arduinos with more than one UART). SoftwareSerial work up to 9600 baud on 16MHz devices, 4800 on 8MHz devices, so you'll need to set the ESP8266 to accommodate that. They currently ship at 115200 baud. You can use the hardware UART on pins (0, 1) but then re-programming the Arduino means disconnecting &amp; reconnecting the ESP temporarily each time, and gets old pretty quickly.</p>

<p>Here's what I do with new ESPs (If you've re-flashed your ESP, you'll need to download the AT instruction-set emulator and re-flash it with that, first):</p>

<pre><code># To configure a new ESP module:
# Connect the ESP and the FTDI as in your top diagram, set your
# terminal-emulator to 115200 baud, and enter the following:

AT                             # ESP should respond ""OK""
AT+RST                         # Resets the ESP
AT+UART_DEF=9600,8,1,0,0       # Sets ESP UART: 9600,N,8,1,no flow ctl

# Now change the terminal emulator baud rate to 9600

AT+CWMODE=1                    # Set ESP to station mode (client)
ATE0                           # Set ESP's echo off  
AT+CWLAP                       # List access points - after a short pause
                               # the ESP returns a list of WiFi access points
</code></pre>

<p>For future reference, here is a link to the <a href=""http://bbs.espressif.com/download/file.php?id=1474"" rel=""nofollow"">ESP8266 AT Instruction Set</a>.</p>
"
"<p>How can I export the readings that are being sent to my Arduino Mega to a file?</p>

<p>I know there is a write() method but I can't find the documentation on how to use it.</p>

<p>I want the file to be created and stored on my PC not an SD card. Also I want to know if there is a way to do this without using external programs.</p>
"
"<p>if your arduino is connected to a computer, you can create a small application that will listen to serial port and write on a file whatever arduino sends over the serial.</p>

<p>Alternatively you can write directly on an sdCard. (There are many sdCard shields available on the market.)</p>

<p>As for the write method, you probably are referring to <a href=""https://www.arduino.cc/en/Reference/FileWrite"" rel=""nofollow"">write</a> method of File class of <a href=""https://www.arduino.cc/en/Reference/SD"" rel=""nofollow"">SD library</a></p>
"
"<blockquote>
  <p>I know there is a write() method but I can't find the documentation on how to use it.</p>
</blockquote>

<p>You can use: <code>Serial.write(F(""TEXT""));</code> to send text over the ""serial communication"".
This basically means that your Arduino will send the text to your PC over the USB emulated COM port.</p>

<p>The magnifying glass button at the top-right of your Arduino IDE's screen will open the ""Serial Monitor"" here you can see the text that's coming from the Arduino, you can even send text back.</p>

<blockquote>
  <p>How can I export the readings that are being sent to my Arduino Mega to a file?</p>
</blockquote>

<p>You could make your Arduino interface with an SD-card.
Or use that serial connection I told you about.</p>

<p>You could create a program (on the PC) that takes the serial input and stores it into a file. A lot of examples from this should be on the internet.
Another thing might be, to use a more advanced serial terminal. I believe ""terminal.exe"" allows ""logging"" to a file.</p>
"
"<p>I am using multiple vl6180x sensors along with Arduino UNO to detect the light and distance of each sensor. Right now, when I tried to connect three sensors applying i2c protocol(after removing four 10k resistors from two of the sensors for pull up resistors). Results read from serial monitor of Arduino shows the minimum values of three sensors. And the sensitivity, precision for these sensors drop a lot, which I am not satisfied with.</p>

<p>Then I used ""digitalWrite"" function in Arduino and applied to VL6180X pin ""GPIO01-CEO"" to enable certain sensor and disable certain sensor in the Arduino code. Wired thing is that it only works when the first time I set them, like if I put something like enable sensor 1, disable sensor 2, disable sensor 3, delay 1s in the loop, it works well. But later if I continue put enable sensor 2, disable sensor 1, disable sensor 3, then the results made no sense, the whole system cant work. Another thing is that I can only enable one sensor at a time, which is fine as it is described as the i2c protocol that only one slave could do the operation at a time. </p>

<p>Also, the address shows on serial monitor by using function "" sensor.readReg16Bit(VL6180X::I2C_SLAVE__DEVICE_ADDRESS);"" makes no sense once I use ""setAddress"" function to change the sensor address.</p>

<p>There are some files/ datasheet provided online for vl6180x sensor, declaring that this sensor could apply i2c and make multiple of them working properly. Till now, I don't know if this address problem, changing sensor problem lies on the Arduino side or the sensor side. As there are also many videos on youtube indicates Arduino is totally capable of applying i2c protocol.
Any help will be appreciated^^</p>

<pre><code>#include &lt;Wire.h&gt;
#include &lt;VL6180X.h&gt;
#define Address1 0x29
#define Address2 0xA9
#define Address3 0x169

VL6180X sensor;
int pin2 = 2;
int pin4 = 4;
int pin7 = 7;

int pin3 = 3;
int pin5 = 5;
int pin6 = 6;

void setup()
{
  Serial.begin(9600);
  Wire.begin();
  pinMode(pin2,OUTPUT);
  pinMode(pin4,OUTPUT);
  pinMode(pin7,OUTPUT);

  pinMode(pin3,OUTPUT);
  pinMode(pin5,OUTPUT);
  pinMode(pin6,OUTPUT);

  digitalWrite(pin2,HIGH);
  digitalWrite(pin4,HIGH);
  digitalWrite(pin7,HIGH);

  digitalWrite(pin3,HIGH);
  digitalWrite(pin5,HIGH);
  digitalWrite(pin6,HIGH);

  sensor.init();
  sensor.configureDefault();

  Wire.beginTransmission(0x29);
  int error = Wire.endTransmission();
  Serial.println(error);
 // Wire.beginTransmission(VL6180X::I2C_SLAVE__DEVICE_ADDRESS);
 // Wire.read(0x52);
  // Reduce range max convergence time and ALS integration
  // time to 30 ms and 50 ms, respectively, to allow 10 Hz
  // operation (as suggested by Table 6 (""Interleaved mode
  // limits (10 Hz operation)"") in the datasheet).
  sensor.readReg16Bit(VL6180X::I2C_SLAVE__DEVICE_ADDRESS);
  sensor.writeReg(VL6180X::SYSRANGE__MAX_CONVERGENCE_TIME, 30);
  sensor.writeReg16Bit(VL6180X::SYSALS__INTEGRATION_PERIOD, 50);
 // sensor.writeReg16Bit(VL6180X::SYSTEM__MODE_GPIO0,0);
  sensor.writeReg16Bit(VL6180X::INTERLEAVED_MODE__ENABLE,0);
 // sensor.setAddress(VL6180X::I2C_SLAVE__DEVICE_ADDRESS);
  sensor.setTimeout(500);
   // stop continuous mode if already active
  sensor.stopContinuous();
  // in case stopContinuous() triggered a single-shot
  // measurement, wait for it to complete
  delay(300);
  // start interleaved continuous mode with period of 100 ms
  sensor.startInterleavedContinuous(100);
  //sensor.setAddress(Address1);
////  sensor1.setAddress(Address2);
//  sensor1.init();
//  sensor1.configureDefault();
//  //sensor1.setAddress(Address4);
//  sensor1.writeReg(VL6180X::SYSRANGE__MAX_CONVERGENCE_TIME, 30);
//  sensor1.writeReg16Bit(VL6180X::SYSALS__INTEGRATION_PERIOD, 50);
//  sensor1.setTimeout(500);
//  sensor1.stopContinuous();
//  delay(300);
//  sensor1.startInterleavedContinuous(100);


}


void loop()
{

//  digitalWrite(pin2,HIGH);
//  digitalWrite(pin4,HIGH);
//  digitalWrite(pin7,HIGH);
//  digitalWrite(pin3,HIGH);
//  digitalWrite(pin5,HIGH);
//  digitalWrite(pin6,HIGH);
//  int input = random(1,4);
//  Serial.println(input);
//  if (input == 1){
//     hello1();
//   //  int error = Wire.endTransmission();
// // Serial.println(error);
//  }
// 
//  else if (input == 2){
//    hello2();
//    //int error = Wire.endTransmission();
//  //Serial.println(error);
//  }
//
//  else if (input == 3) {
//     hello3();
//   //  int error = Wire.endTransmission();
// // Serial.println(error);
//  }
   hello1();
 //   hello2();
  //  hello3();

//  Serial.print(sensor.readReg16Bit(VL6180X::SYSTEM__MODE_GPIO0));
//  Serial.println();
////  Wire.beginTransmission(0x00);
////  Wire.write(0);
////  Wire.endTransmission();
////  sensor.setAddress(VL6180X::I2C_SLAVE__DEVICE_ADDRESS);
//  //sensor.setAddress(Address2);
//  //digitalWrite(pin4,HIGH);
// // digitalWrite(pin4,HIGH);
//  //digitalWrite(pin7,HIGH);
//  Serial.print(""Ambient 1: "");
//  Serial.print(sensor.readAmbientContinuous());
//  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }
//
//  Serial.print(""\tRange 1: "");
//  Serial.print(sensor.readRangeContinuousMillimeters());
//  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }
//
//  Serial.println();
//  
//  delay(1000);

}
void hello1(){
  sensor.setAddress(0x80);
  Wire.beginTransmission(0x80);
  int error = Wire.endTransmission();
  Serial.println(error);
  digitalWrite(pin2,HIGH);
  digitalWrite(pin4,HIGH);
  digitalWrite(pin7,HIGH);
  digitalWrite(pin3,LOW);
  digitalWrite(pin5,LOW);
  digitalWrite(pin6,HIGH);

  sensor.setAddress(Address1);
  Serial.print(sensor.readReg16Bit(VL6180X::SYSTEM__MODE_GPIO0));
  Serial.println();

  Serial.print(""Ambient 1: "");
  Serial.print(sensor.readAmbientContinuous());
  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

  Serial.print(""\tRange 1: "");
  Serial.print(sensor.readRangeContinuousMillimeters());
  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

  Serial.println();

  delay(1000);
}
void hello2(){
  sensor.setAddress(0x82);
  Wire.beginTransmission(0x82);
  int error = Wire.endTransmission();
  Serial.println(error);
  digitalWrite(pin2,HIGH);
  digitalWrite(pin4,HIGH);
  digitalWrite(pin7,HIGH);
  digitalWrite(pin3,LOW);
  digitalWrite(pin5,HIGH);
  digitalWrite(pin6,LOW);
  sensor.setAddress(Address2);
  //sensor.setAddress(VL6180X::I2C_SLAVE__DEVICE_ADDRESS);
  Serial.print(sensor.readReg16Bit(VL6180X::SYSTEM__MODE_GPIO0));
  Serial.println();
  Serial.print(""Ambient 2: "");
  Serial.print(sensor.readAmbientContinuous());
  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

  Serial.print(""\tRange 2: "");
  Serial.print(sensor.readRangeContinuousMillimeters());
  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

  Serial.println();

  delay(1000);
}

void hello3(){
  sensor.setAddress(0x84);
  Wire.beginTransmission(0x84);
  int error = Wire.endTransmission();
  Serial.println(error);
  digitalWrite(pin2,HIGH);
  digitalWrite(pin4,HIGH);
  digitalWrite(pin7,HIGH);
  digitalWrite(pin3,HIGH);
  digitalWrite(pin5,LOW);
  digitalWrite(pin6,LOW);

  sensor.setAddress(Address3);
  Serial.print(sensor.readReg16Bit(VL6180X::SYSTEM__MODE_GPIO0));
  Serial.println();
  Serial.print(""Ambient 3: "");
  Serial.print(sensor.readAmbientContinuous());
  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

  Serial.print(""\tRange 3: "");
  Serial.print(sensor.readRangeContinuousMillimeters());
  if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

  Serial.println();

  delay(1000);

}
</code></pre>
"
"<p>I intend to design an air pollution monitoring station which will measure these data (CO, NO2, O3, Temperature, Humidity and Pressure). I want to store the data on the SD card during the whole day and deploy it online in CSV format.
I will have five stations in fixed locations and gather their daily data.</p>

<ol>
<li>Any suggestions about specific types of sensors (references)?</li>
<li>How to store the data as CSV format?</li>
<li>How to send the data online at certain time on Arduino? </li>
<li>Is it better to use GSM or WiFi? </li>
</ol>
"
"<blockquote>
  <p>How to store the data as CSV format?</p>
</blockquote>

<p>Write the values to the card with commas between them.</p>

<pre><code>myFile.print(noxValue);
myFile.print("","");
myFile.print(coValue);
myFile.print("","");
myFile.println(ozValue);
... etc ...
</code></pre>

<blockquote>
  <p>How to send the data online at certain time on Arduino?</p>
</blockquote>

<p>You need to make a suitable network request to whatever unknown thing it is you are sending it to. That may be a HTTP POST request, or it could be some completely different mechanism. Until you have decided where you are sending it we can't help you with the how of sending it.</p>

<p>As to the <em>when</em>, you really could do with a Real Time Clock module so you know what the time is. Then at a certain time you can run your code. Some RTC modules have an alarm that can alert you when it's time to send your code. Great for if your MCU has been placed in a sleep mode and needs waking up at the right time.</p>

<blockquote>
  <p>Is it better to use GSM or WiFi?</p>
</blockquote>

<p>That depends if you have access to WiFi where the sensor is. If you do, then WiFi is (more often than not) cheaper. If you don't, then WiFi is impossible and GSM is the only option. </p>
"
"<p>I'm having trouble with flashing <code>amforth</code> on my Arduino UNO.
I'm using an Arduino as ISP to write <code>amforth</code>.</p>

<p>Here's what I do:</p>

<ol>
<li>Upload the code on the Arduino programmer and set Baudrate to 19200</li>
<li>Wire the Arduinos this way -> <a href=""https://cdn.sparkfun.com/assets/3/b/d/8/1/523b53bb757b7f01268b456a.jpg"" rel=""nofollow"">Wiring</a></li>
<li>Run <code>avrdude -P /dev/ttyUSB* -c avrisp -b 19200 -p m328p -e -U flash:w:uno.hex:i -U eeprom:w:uno.eep.hex:i -U efuse:w:0x05:m -U hfuse:w:0xD9:m -U lfuse:w:0xFF:m</code></li>
</ol>

<p>Sometimes it fails to set efuse,  but if I give the command just for it, even if it says <code>""efuse changed, it was 5, not is 0xfd, do you want to change it back?""</code> and I say no, I get the message with the correct fuses.</p>

<p>I log onto the <code>amforth</code> Arduino with the python shell, but my stack is constantly <code>??? -13</code> and different numbers. I found out <code>-13</code> is error code for <code>not found</code>, but... not found what?</p>

<p>What does it mean? What am I missing?
<br>
I have to say that I'm new at this things, I recently studied Forth and discovered that I can use it on my Arduino, and I wanted to try.
<br>
By the way, the Arduino is not original.
<br> The chip is ATmega 328p</p>

<p>EDIT:
I downloaded <code>amforth</code> from <a href=""https://sourceforge.net/projects/amforth/files/amforth/"" rel=""nofollow"">here</a>
Initially I followed [first guide] (different wiring but I've read around it's the same) and then ""clarified my doubts"" with another one from sparkfun.
(no link used because maximum for me is 2 links per post at the moment, I'll write it in the comments)</p>

<p><br>
I tried with versions <code>6.1</code> and <code>6.0</code>, then I decided to try with <code>5.9</code> (the one from the first guide) and now I'm running that (at least it allows me to pop elements from the stack).</p>
"
"<p>I have an Arduino Uno and an ArduCAM-mini 2MP camera:</p>

<p><a href=""http://www.arducam.com/tag/arducam-mini/"" rel=""nofollow"">http://www.arducam.com/tag/arducam-mini/</a></p>

<p>Is it possible to connect this camera, or similar cameras, to the arduino without a shield?  The only tutorials I've found use a shield.</p>

<p>edit - here is what my cam looks like:
<a href=""http://i.stack.imgur.com/lXo3j.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/lXo3j.jpg"" alt=""enter image description here""></a></p>
"
"<p>Judging by the photo (below) it is specifically designed to plug into the SPI ports on a Uno or similar (that is, pins 10 to 13). The other two wires are going to the ICSP header, presumably to pick up +5V and ground.</p>

<p><a href=""http://i.stack.imgur.com/tbj3W.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/tbj3W.jpg"" alt=""Arducam""></a></p>

<p>So yes, most certainly you can use it like that. With the pins done like that it even points horizontally.</p>

<blockquote>
  <p>It wasn't clear to me that I should bend the camera pins as such (mine has 8 pins pointing downward). </p>
</blockquote>

<p>You can buy pins with a 90° angle. If yours are not already soldered on, I would use the bent connector. If the pins are already soldered on, then the camera would lie flat, so just rotate the Arduino itself to point to where you want it to.</p>

<p>However you would need to do something with the +5V and Gnd pins, so that they can be rerouted to the correct place.</p>

<hr>

<p>Looking at another photo on that site.</p>

<p><a href=""http://i.stack.imgur.com/uhPSo.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/uhPSo.jpg"" alt=""Arducam pins""></a></p>

<p>The pins would match most of the pins on a Uno, like this:</p>

<p><a href=""http://i.stack.imgur.com/qheS5.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/qheS5.png"" alt=""Uno pins""></a></p>

<p>The only one that is wrong is AREF - you need +5V into that pin, not AREF, which is why they bent those two pins outwards (+5V and Gnd) and ran wires to the ICSP header.</p>

<hr>

<p>If you mean all your pins are at right-angles already, then you really only need to fix the +5V one (you can probably bend it up). This is the pin-out for the ICSP header (view from above):</p>

<p><a href=""http://i.stack.imgur.com/V4CIY.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/V4CIY.png"" alt=""ICSP header""></a></p>

<p>As you can see, you can pick up +5V from pin 2 (Vcc). Alternatively, run the +5 wire over to where +5 is marked on the Uno on the other side.</p>

<hr>

<p>Another possible approach would be to not bend anything, but solder on a wire to the +5V pin and leave it plugged into AREF. AREF is just an input (analog reference voltage) and it won't hurt to have it left at +5V.</p>
"
"<p>I am planning on building a little device that acts as a soundboard. For this, I want to connect several buttons to a breadboard and get a software solution up and running. While the electrical and software engineering don't present an actual problem, the physical engineering does.</p>

<p>So a few questions come up:</p>

<ol>
<li>How and where can I manufacture such a custom-made device / casing? I'm not even too sure what to google here...</li>
<li>Which material should I be using?</li>
<li>Naturally, I plan to add speakers to the device. Should I just go with portable bluetooth-speakers or are there better / cheaper versions for self-assembly?</li>
<li>Lastly, the device needs a power supply. Would you recommend using a powerbank or a battery-slot type of thing?</li>
</ol>

<p>I'd appreciate any tips and recommendations. Thanks in advance.</p>
"
"<p>Another option is to look for a hardware (Arduino Clone) that has been designed for that, like this board: <a href=""https://bitbucket.org/talk2/whisper-node-avr/overview"" rel=""nofollow"">https://bitbucket.org/talk2/whisper-node-avr/overview</a></p>

<p>Combining such hardware with power-saving code techniques you should be able to run projects for quite long time on batteries!</p>
"
"<p>I have connected a bluetooth module(HC-06) and a voice recognition shield(EasyVR) on an arduino UNO. </p>

<p>By using an another HC-06 on the another arduino(so, 2 arduinos and 2 HC-06 totally), I am going to let two arduionos communicate with each other.</p>

<p>Also, simultaneously, one arduino with HC-06 will recogize the voice by using the voice recognition module. </p>

<p>I have successed each operations, but after combining two codes the bluetooth doesn't work...
(Voice recognition have successed.)</p>

<ol>
<li><p>Is it unable to operate two operations simultaneously?</p></li>
<li><p>Can we use these two sentences in one code?</p>

<p>SoftwareSerial BT(2,3);     --> for bluetooth module
SoftwareSerial Port(12,13);   --> for voice recognition module</p></li>
</ol>
"
"<p>I can't figure out why the output voltage of analogWrite(255) is less than the voltage of digitalWrite(255). My code and an image of my setup are below. Some other useful information is that I am using the NodeMCU by HiLetgo, 3.3k ohm resistors with the meters, and that the meters use 1mA of current DC at full scale. Thanks for your help!</p>

<pre><code>int pPressure       = D2;
int pPrecipProb     = D1;
int pWindSpeed      = D0;

int mTemperature;
int mHumidity;
int mPressure;
int mPrecipProb;
int mWindSpeed;
int mAlert;

void setup() {
  Serial.begin(9600);
  pinMode(pPrecipProb,   OUTPUT);
  pinMode(pWindSpeed,    OUTPUT);
  pinMode(pPressure,     OUTPUT);
  pinMode(LED_BUILTIN,   OUTPUT);     // Initialize the LED_BUILTIN pin as an output
}

// the loop function runs over and over again forever
void loop() {
    mPressure           = (int) constrain(mPressure + 1, 0, 255);
    mPrecipProb         = (int) constrain(mPrecipProb + 1,     0, 255 );
    mWindSpeed          = (int) constrain(mWindSpeed + 1,     0, 255 );

    if(mPressure == 255)
    {
      mPressure = 0;
      mPrecipProb = 0;
      mWindSpeed = 0;
    }

    digitalWrite(pPressure,      HIGH   );
    analogWrite(pPrecipProb,    255 );
    analogWrite(pWindSpeed,     mWindSpeed  );


    delay(10);                    

}
</code></pre>

<p><a href=""http://i.stack.imgur.com/GEaro.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/GEaro.jpg"" alt=""Left ""></a></p>

<p>Left: AnalogWirte(255)</p>

<p>Middle: DigitalWrite(HIGH)</p>

<p>Right: the other one that cycles</p>
"
"<p>First, do something simpler, and eliminate possible causes.</p>

<ol>
<li>Are you <em>certain</em> the NodeMCU's CPU is an 8bit PWM? If it were
9bits, it would read about 50% full scale, and 10bits would be about
25% of digitalWrite (which is what I think I can see on the photo).</li>
<li>Swap the analogue meters around, and see if the difference is consistent
with the pin, or consistent with the meters.</li>
<li>Use a digital multimeter (DMM) to measure voltage. It should be a
small load. So this should eliminate, or identify, the analogue
meters as a culprit.</li>
</ol>

<p>If there is still a difference in voltage, do the NodeMCU equivalent of:  </p>

<pre><code>void setup() {
  pinMode(10, OUTPUT);  // a pin capable of analogOut and DigitalOut
}

void loop() {
  digitalWrite(10, HIGH);
  analogWrite(9, 255);  // a pin capable of analogOut and DigitalOut

  delay(100);
}
</code></pre>

<p>Then swap 9 and 10. </p>

<p>If the DMM shows the analogue output is consistently lower, then go back and check that PWM is 8 bits, and the device output range for PWM is the same output voltage as digitalWrite to a GPIO.</p>
"
"<p>I am using the Teensy 3.2 and would like to create 2 Clock signals via PWM.</p>

<p>PWM 1: 4MHz</p>

<p>PWM 2: 1kHz</p>

<p>I have to use two different timers, but how can I synchronize both clocks, so that the rising edges align?</p>

<p>My current code:</p>

<pre><code>pinMode(PIN_CLK1, OUTPUT);
analogWriteFrequency(PIN_CLK1, 4000000);
analogWrite(PIN_CLK1, 128);
pinMode(PIN_CLK2, OUTPUT);
analogWriteFrequency(PIN_CLK2, 1000);
analogWrite(PIN_CLK2, 128);    
//now align rising edges
</code></pre>

<p>Thanks in advcance.</p>
"
"<p>I found the path to the files i want change in the github link so i can change the files(C:\Program Files\Arduino\hardware\arduino\avr\cores\arduino).</p>

<p>I enable the uart for 9 bit, i add sbi(*_ucsrb, UCSZ12);  in HardwareSerial::begin</p>

<p>I decided that i only send a Flag to my PC when the 9th bit is set. For that i change the _rx_buffer to a 2 byte matrix (short _rx_buffer). Now i send the databyte in the low-byte and flags for 9 bit, framing error and overrun error in the high-byte. That i can do that i change the void HardwareSerial::_rx_complete_irq(void) code like the follow:</p>

<pre><code>void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0))
  {
    bool is_address = UCSR0B &amp; _BV(RXB80);
    bool is_framError = UCSR0A &amp; _BV(FE0);
    bool is_overError = UCSR0A &amp; _BV(DOR0);
    unsigned char c = *_udr;
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;

    if (i != _rx_buffer_tail) 
    {
     _rx_buffer[_rx_buffer_head] = c;
     _rx_buffer[_rx_buffer_head] |= is_address &lt;&lt; 8;
     _rx_buffer[_rx_buffer_head] |= is_framError &lt;&lt; 9;
     _rx_buffer[_rx_buffer_head] |= is_overError &lt;&lt; 10;
     _rx_buffer_head = i;
    } 
  } 
  else {    *_udr;  };
}
</code></pre>

<p>I hope this will work and i can evaluate the data right at the PC.</p>

<p>Frindly wishes sniffi</p>
"
"<p>You can use a terminal program like <a href=""http://www.chiark.greenend.org.uk/~sgtatham/putty/"" rel=""nofollow"">putty</a> or <a href=""https://en.m.wikipedia.org/wiki/Minicom"" rel=""nofollow"">Minicom</a> to write that data to a log file. Then you can use whatever program or app to process this log file.
Both programs can read from the serial interface.</p>
"
"<blockquote>
  <p>Is it unable to operate two operations simultaneously?</p>
</blockquote>

<p>The only way you can do two operations simultaneously is to have two Arduinos. An Arduino can only do one thing at a time. In order to make it seem like it's doing things at once you have to create your sketch accordingly. The use of <code>delay()</code> is right out. As are long loops using things like <code>while()</code>. In short: <em>anything that <strong>blocks</strong> is bad</em>.</p>

<blockquote>
  <p>Can we use these two sentences in one code?</p>
</blockquote>

<p>Not reliably, no.  They are both resource hungry and, to a large extent, blocking. A general rule is, if you need at least two more UARTs than the board provides then you need a different board. You can only reliably work with one software UART at a time.</p>

<p>I would suggest upgrading to a more capable board with more hardware UARTs. Either that or use a bluetooth system that doesn't use UART, such as an SPI based BLE module.</p>
"
"<ol>
<li><p>You can ask a technical school or when you have a frind as an industial   mechanic in the trainee perhapes that can ask his master. That is where i will be ask first. Normaly when you ask at a school and you pay for the material they help a lot.</p></li>
<li><p>I would use aluminum or acrylic glass.</p></li>
<li><p>Sry at this point i can´t help</p></li>
<li><p>i would use a powerbank because the newer have a really good battery performance.</p></li>
</ol>
"
"<p>This question cannot be answered, and the reason should become obvious:</p>

<blockquote>
  <p>How and where can I manufacture such a custom-made device / casing? I'm not even too sure what to google here...</p>
</blockquote>

<p>You could do it in your garden shed with wood. You could commission a manufacturing plant to injection mould a case for you. You could build it out of LEGO®.</p>

<blockquote>
  <p>Which material should I be using?</p>
</blockquote>

<p>Wood, plastic, metal, cheese, oyster shells...</p>

<blockquote>
  <p>Naturally, I plan to add speakers to the device. Should I just go with portable bluetooth-speakers or are there better / cheaper versions for self-assembly?</p>
</blockquote>

<p>Yes. No. Maybe. Speakers come in many forms. What is suitable for your project? Who knows? Not I!</p>

<blockquote>
  <p>Lastly, the device needs a power supply. Would you recommend using a powerbank or a battery-slot type of thing?</p>
</blockquote>

<p>Whatever your project needs is what is suitable.</p>

<p>In short: We don't have a clue what your project is, what its requirements are, what you are trying to do, etc, so we cannot help you.</p>

<p><strong>I would recommend, instead, taking a look at what existing enclosures are available and designing your project to fit one of those.</strong></p>
"
"<p>I have the basic version of the <a href=""http://www.sainsmart.com/sainsmart-l293d-motor-drive-shield-for-arduino-duemilanove-mega-uno-r3-avr-atmel.html"" rel=""nofollow"">stepper motor driver</a> and a Nano, I see the pins are set to plug directly in to a Uno or similar Arduino, but according to the documentation it just needs most of the digital pins connected to the arduino - <a href=""https://learn.adafruit.com/adafruit-motor-shield/faq"" rel=""nofollow"">https://learn.adafruit.com/adafruit-motor-shield/faq</a></p>

<p>As it seems they are the opposite position to plug into a breadboard for testing, I may need to wire and solder them (11 to D11, 3 to D3, 5 to D5, 6 to D6). Is this correct or does the Nano not have the power/amperage/timing or something to run this type of shield, hence the lack of compatibility listed for that shield?</p>
"
"<p>I believe, though it's not clear, that the shield in question uses a 74HC595 shift register to control the main motor drivers - the other pins are for the servo interfaces (and they are just wired 1:1). Theoretically you can therefore use any pins you like to control the motor drivers themselves.</p>

<p>It's not the same as the Adafruit one which looks to use direct Arduino control of the motor drivers.</p>
"
"<p>I want to know about the how to validate the <strong>Username and Password</strong></p>
"
"<p>The </p>

<pre><code>Vin pin = 5V or 3.3V
</code></pre>

<p>You cannot use the 5V from the USB to power up the FAN and the LOAD because the USB port usually delivers only 100mA, and this is not enough to switch the relay and the LOAD. 
That is why you must use an external power supply (Vcc) that is between 7 to 12 volts to power up the Arduino board and the transistor + relay. The load uses its own power supply, for instance if you use a light bulb then you might connect it to the 110/220V mains or any other power source.</p>

<p><strong>or</strong></p>

<p>you can also use a fan that has one of the pins of the fan is a PWM input. The fan has an internal transistor to switch the 12V power when given a 0-5V input. That is the pin you want to connect to the actuator pin.</p>

<p><strong>please get back to me if it was helpful</strong></p>
"
"<p>I am new to IOT and tried out integration and small test code with Arduino Mega with SIM808 + GSM + GPS Module it works fine with SIM808 Library.
My requirement is to put it in enclosure but when the power restarts for some reason, We have to manually Start the SIM 808 + GPS + GSM Module, 
can we control it from Program ?? Software Trigger from Arduino Code ??</p>

<p>May be if we have some pins to connect and trigger Power On. 
Kindly provide inputs/suggestion for the below module <a href=""http://www.ebay.in/itm/222142520400?euid=007afe9cc2264537b4beecab12b7dd90&amp;bu=44483664891&amp;cp=1&amp;sojTags=bu=bu"" rel=""nofollow"">http://www.ebay.in/itm/222142520400?euid=007afe9cc2264537b4beecab12b7dd90&amp;bu=44483664891&amp;cp=1&amp;sojTags=bu=bu</a></p>

<p>If you are aware of some module which can be started through program kindly suggest.</p>

<p>One reference found for a different module with Software Trigger - <a href=""http://www.geeetech.com/wiki/index.php/Arduino_GPRS_Shield"" rel=""nofollow"">http://www.geeetech.com/wiki/index.php/Arduino_GPRS_Shield</a></p>
"
"<p>I can't get a great view of the board, but if you are pressing the button just below ""GSM"" and ""Made"" then I would suggest soldering some leads onto the button and connecting them to a digital output and Gnd on the Arduino.  (You might need resistors and stuff)  Then when you wanted to press the button you could pulse the line high.</p>
"
"<p>I'm sorry, I know you are new, but this is not a very good question.  You know exactly what you mean, but look at it from the point of view of someone who doesn't know what you want to do or how you want to do it.</p>

<p>I'm going to guess that you mean and try and give you an answer:</p>

<ul>
<li>I think you are using the Arduino IDE to program an ESP8266 12E. </li>
<li>You want to use the ESP8266 as a web server and want a method of
displaying a login page.</li>
<li>I'm going to guess you know how to connect the ESP8266 to you local
WIFI.  </li>
<li>I'm going to guess you can use one of the examples supplied    with
the IDE to create a web server that will present 'hello world'<br>
pages.</li>
<li>You need to look at how to create a page that will POST<br>
information back to the server, using a FORM.  WWW.W3Schools.com will
be a good place to learn this.</li>
<li>Once you have the POSTed information you are going to need to look at
a different example to see how to parse it on the ESP8266.</li>
<li>Once you have extracted the information you will need to verify that
the supplied data matches the data hardcoded into the webserver.  </li>
<li>Once you have got plain text authentication working you should look<br>
at adding encryption of the data.</li>
</ul>

<p>I hope that gives you a steer in the right direction.  If not please come back with as much detail as you can.</p>
"
"<p>I am in grade 6. I have a very nice pet dog in my house but it often enters Mom's kitchen to spoil all the foods. So I am thinking of a device to attach with him which can locate its position. But I am totally new to arduino programming. I have found some tutorials of arduino UNO to locate position with GPS. But I don't know how to set up the alarm when my dog reaches the position of our kitchen and what will be the code for it. If I wanna set alarm for different position, like kitchen and two toilets, what would be the code then? I know Java a very little bit. C too. Nothing else. Is there any altruist to help me out, please?</p>
"
"<p>I need to know how I can make http posts and http get from Arduino MKR1000 ( act as a client) to a local server.</p>

<p>I made it on Raspberry pi using python like this:</p>

<pre><code>import requests
import json
     url = 'http://192.168.2.139:8040/api/sensor'
     value = {""LDRValue"": 200};
     r = requests.post(url, json=value)
     r = requests.get(url)
</code></pre>
"
"<p>Physically It is impossible to run 2 things at the same time when you have one microcontroller. ""The Arduino is a very simple processor with no operating system and can only run one program at a time"". But I am pretty sure that the solution you are trying to find, hides in multitasking or interuption. There are some cones in <code>delay()</code> function: ""The problem is that delay() is a ""busy wait"" that monopolizes the processor. "" But in multitasking, you share clock of the processor between two different pieces. You can find more about running different things simultanously <a href=""https://learn.adafruit.com/multi-tasking-the-arduino-part-1/overview"" rel=""nofollow"">here</a>.
I have used <code>miles()</code> in one of my projects where were coin validator which was outputing impulses and screen which was showing chash inside it.</p>
"
"<p><a href=""http://i.stack.imgur.com/AhzDw.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/AhzDw.jpg"" alt=""enter image description here""></a></p>

<p>Can any one help me to connect a USB to TTL adapter by D-sun to an ESP8266 module? Any links or suggestions would be appreciated.</p>
"
"<p>Ive recently bought my self a arduino Mega 2560 and managed to get a sort of RANDOM function to work with different cases which go of by the number selected.
My question is is there a way to also make a PWM sequence in such a case? so that the LED is fully light to dark and then the the next case starts?  IS there a more random sequence wich i could then also expand if neccesary?</p>

<p>Mark.</p>

<pre><code>int ledcolor = 0;
 int a = 500; //this sets how long the stays one color for
int b = 2000;
int brightness = 255;    // how bright the LED is
int fadeAmount = 25;    // how many points to fade the LED by

 void setup() { //this sets the output pins

 pinMode(11, OUTPUT);
 pinMode(10, OUTPUT);
 pinMode(9, OUTPUT);
 pinMode(8, OUTPUT);
 }

 void loop() {
 int ledcolor = random(1,16); //this randomly selects a number between 1 and 15

 switch (ledcolor) {

 case 1: //if ledcolor equals 1 then the led on pin 11 will turn on etc.
 analogWrite(11, brightness);
 brightness = brightness - fadeAmount;     break;
 case 2:
 digitalWrite(10, HIGH);
 delay(a);
 digitalWrite(10, LOW);
 break;
 case 3:
 digitalWrite(9, HIGH);
 delay(a);
 digitalWrite(9, LOW);
 break;
</code></pre>
"
"<p>Maybe this link will be helpful for you.</p>

<p><a href=""https://www.hackster.io/charifmahmoudi/arduino-mkr1000-getting-started-08bb4a"" rel=""nofollow"">Arduino-mkr1000-getting-starter-wifi</a></p>

<pre><code>#include &lt;WiFi101.h&gt;
#include &lt;WiFiClient.h&gt;
#include &lt;WiFiServer.h&gt;
#include &lt;WiFiSSLClient.h&gt;
#include &lt;WiFiUdp.h&gt;

/*
* This example is modified from the original file 
* https://github.com/arduino-libraries/WiFi101/blob/master/examples/
 SimpleWebServerWiFi/SimpleWebServerWiFi.ino
*/
#include &lt;SPI.h&gt;
#include &lt;WiFi101.h&gt;

char ssid[] = ""yourNetworkSSID"";      //  your network SSID (name)
char pass[] = ""yourNetworkPassword"";   // your network password
int keyIndex = 0;                 // your network key Index number (needed    only for WEP)
int ledpin = 6;
bool val = true;

int status = WL_IDLE_STATUS;
WiFiServer server(80);

void setup() {
Serial.begin(9600);      // initialize serial communication
Serial.print(""Start Serial "");
pinMode(ledpin, OUTPUT);      // set the LED pin mode
// Check for the presence of the shield
Serial.print(""WiFi101 shield: "");
if (WiFi.status() == WL_NO_SHIELD) {
Serial.println(""NOT PRESENT"");
return; // don't continue
}
Serial.println(""DETECTED"");
// attempt to connect to Wifi network:
while ( status != WL_CONNECTED) {
digitalWrite(ledpin, LOW);
Serial.print(""Attempting to connect to Network named: "");
Serial.println(ssid);                   // print the network name (SSID);
digitalWrite(ledpin, HIGH);
// Connect to WPA/WPA2 network. Change this line if using open or WEP          network:
status = WiFi.begin(ssid, pass);
// wait 10 seconds for connection:
delay(10000);
}
server.begin();                           // start the web server on port 80
printWifiStatus();                        // you're connected now, so print out        the status
digitalWrite(ledpin, HIGH);
 }
 void loop() {
 WiFiClient client = server.available();   // listen for incoming clients

if (client) {                             // if you get a client,
Serial.println(""new client"");           // print a message out the serial     port
String currentLine = """";                // make a String to hold incoming data from the client
while (client.connected()) {            // loop while the client's connected
  if (client.available()) {             // if there's bytes to read from the client,
    char c = client.read();             // read a byte, then
    Serial.write(c);                    // print it out the serial monitor
    if (c == '\n') {                    // if the byte is a newline character

      // if the current line is blank, you got two newline characters in a row.
      // that's the end of the client HTTP request, so send a response:
      if (currentLine.length() == 0) {
        // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
        // and a content-type so the client knows what's coming, then a blank line:
        client.println(""HTTP/1.1 200 OK"");
        client.println(""Content-type:text/html"");
        client.println();

        // the content of the HTTP response follows the header:
        client.print(""Click &lt;a href=\""/H\""&gt;here&lt;/a&gt; turn the LED on pin 9     on&lt;br&gt;"");
        client.print(""Click &lt;a href=\""/L\""&gt;here&lt;/a&gt; turn the LED on pin 9 off&lt;br&gt;"");

        // The HTTP response ends with another blank line:
        client.println();
        // break out of the while loop:
        break;
      }
      else {      // if you got a newline, then clear currentLine:
        currentLine = """";
      }
    }
    else if (c != '\r') {    // if you got anything else but a carriage      return character,
      currentLine += c;      // add it to the end of the currentLine
    }

    // Check to see if the client request was ""GET /H"" or ""GET /L"":
    if (currentLine.endsWith(""GET /H"")) {
      digitalWrite(ledpin, HIGH);               // GET /H turns the LED on
    }
    if (currentLine.endsWith(""GET /L"")) {
      digitalWrite(ledpin, LOW);                // GET /L turns the LED off
    }
  }
}
// close the connection:
  client.stop();
  Serial.println(""client disonnected"");
  }
}

void printWifiStatus() {
// print the SSID of the network you're attached to:
Serial.print(""SSID: "");
Serial.println(WiFi.SSID());

// print your WiFi shield's IP address:
IPAddress ip = WiFi.localIP();
Serial.print(""IP Address: "");
Serial.println(ip);

// print the received signal strength:
long rssi = WiFi.RSSI();
Serial.print(""signal strength (RSSI):"");
Serial.print(rssi);
Serial.println("" dBm"");
// print where to go in a browser:
Serial.print(""To see this page in action, open a browser to http://"");
Serial.println(ip);
}
</code></pre>
"
"<p>In order to fade in and fade out LEDs you need to use <a href=""https://www.arduino.cc/en/Tutorial/PWM"" rel=""nofollow"">PWM</a> feature. And, specifically you need to use the <a href=""https://www.arduino.cc/en/Reference/AnalogWrite"" rel=""nofollow"">analogWrite()</a> function call. Also, you need to make sure all your LEDs are connected to PWM port pins.  Port pins which support the PWM feature for various Arduinos are listed in the above link.</p>

<p>In your code you might try replacing your 500ms delay with a count up followed by a count down loop.  Each loop should contain the appropriate delay and count up or down to the appropriate value.</p>

<p>For instance, you might try a 1ms delay and a count from 0 to 255 followed by a count from 255 to 0.  In both loops just before or just after calling the delay() function, place the call to the analogWrite() function and pass the counter value as the PWM duty cycle (LED brightness setting).</p>

<p>added later...</p>

<p>For example, you might try to see if this code works for the 1st case statement:</p>

<pre><code>int brightness_level;


case 1: //if ledcolor equals 1 then the led on pin 11 will turn on etc.
  for(brightness_level = 0 ; brightness_level &lt; 255 ; brightness_level++)
  {
    analogWrite(11, brightness_level);
    delay(1);
  }
  for(brightness_level = 255 ; brightness_level &gt;= 0 ; brightness_level--)
  {
    analogWrite(11, brightness_level);
    delay(1);
  }
break;
</code></pre>
"
"<p>my group is doing a project which call automatic bed maker. we want to use a servomotor to pull the sheet of the bed. can we possibly make the servomotor stop rotate when the speed of rotation decrease? or is there any way to make the servo motor automatically stop beside using timer.
sorry for broken english.</p>
"
"<p>Hardware newbie here and I need to know how to connect my TSL 1401 line scan camera to an Arduino Mega so that I can send it the needed impulses. The Mega has a hundred different sockets and the Schema just scared me when I looked at it.</p>

<p>I just want to know which socket I can connect to the CLK and SI ports of my camera so that I can get and an analog output of pixels.</p>
"
"<p>I have an ATtiny hooked up to two line scan modules. I'm sending digital signals to the line scan modules then receiving the analog output and storing it in an array. I have an if statement that will make the LED on the ATtiny programmer blink when the number are below a certain range (meaning that lens is covered). </p>

<p>Here is my code:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
const int rx=0;
const int tx=1;

SoftwareSerial mySerial(rx,tx);
int CLK = 2;
int SI = 1;
int Aout = A3; 
int Aout1 = A2;

int LED = 0;

int pixelsArray[128];   //Array to hold the values of the individual pixles.
int pixelsArray1[128];

 void outputPixels()
{
  for(int j = 0; j &lt; 128; j++)
  {
    digitalWrite(LED, LOW);

    if(pixelsArray[j] &lt; 100)
    {
      digitalWrite(LED, HIGH);
      delay(500);
      digitalWrite(LED, LOW);
      delay(500);
    }
  }
}
</code></pre>

<p>The problem that I am having is that when I test my code with one line scan module it works just fine. You will notice that in the <code>readPixels()</code> I have the statement <code>pixelsArray1[i]=analogRead(Aout1);</code> commented out. However, when I try to use it with two the LED start blinking regardless of how much light is hitting the line scanner.</p>

<p>The strange thing is that EVEN when I comment out the <code>digitalWrite(LED, HIGH);</code> statement in the <code>outputPixels()</code> method...THE LED STILL BLINKS!!!</p>

<p>Since the ATtiny does not support URT and can't use the console in Arduino I have no idea how to debug this. Does anyone here have any clue what is wrong?</p>

<p>Here is the datasheets</p>

<p>ATtiny: <a href=""http://www.atmel.com/Images/Atmel-2586-AVR-8-bit-Microcontroller-ATtiny25-ATtiny45-ATtiny85_Datasheet.pdf"" rel=""nofollow"">http://www.atmel.com/Images/Atmel-2586-AVR-8-bit-Microcontroller-ATtiny25-ATtiny45-ATtiny85_Datasheet.pdf</a></p>

<p>ATtiny Programmer: <a href=""https://learn.sparkfun.com/tutorials/tiny-avr-programmer-hookup-guide/?_ga=1.59946280.467360091.1464906372"" rel=""nofollow"">https://learn.sparkfun.com/tutorials/tiny-avr-programmer-hookup-guide/?_ga=1.59946280.467360091.1464906372</a></p>
"
"<p>I want to control 2 dc motors using the arduino board directly. One motor must rotate clockwise and the other counter clockwise. The directions  doesn't change only the speed of each motors. Can this be done without any shield? Them motors may need a higher voltage than the arduino can provide. If I link the arduino board to a power source of about 15 V (the board is arduino mega limits between 6 and 20 ) and I use ""analog.write()"" function can I output more than 5 volts(the internal voltage)?</p>
"
"<p>First of all, let me be clear: I'm a total noob, I have close to zero programming experience and I know i'm out of my league, but I want to learn and understand.
Here's the issue. The following code has been made to control heat pads using 4 relays that turn off/on depending on the temperature that 4 lm35 Temp sensors pick up. Because these sensors can be jumpy sometimes, I want to get the average temperature from, let's say, 50 readings, and make the code check THAT data instead of the raw temp reading.
I have the code for the arduino (I wrote some code and guys over other forums took it and modified it to make it shorter (and that kind of lost me, but the code works)
and then I searched smoothing data and got a piece of code that does exactly what I want: make an array, calculate the average temp, and keep deleting and adding new data.</p>

<p>I tried to join both codes together and I got all different kind of errors, lol
So here I am.</p>

<p><strong>The Code that works without average data is this one:</strong></p>

<pre><code>const byte tempPin[] = {A1, A2, A3, A4};
const byte relayPin[] = {6, 7, 8, 9};

// hysteresis = upperLimit - lowerLimit
const byte lowerLimit = 24;
const byte upperLimit = 31;

float tempC[4];
word reading[4];



word printInterval = 1000; // 1 second
unsigned long printCheck = 0, lastPrintTime = 0;

void setup()
{
  analogReference(INTERNAL);
  Serial.begin(115200);
  for (int i = 0; i &lt; 4; i++) {
    pinMode(relayPin[i], INPUT_PULLUP);
    pinMode(relayPin[i], OUTPUT); // defaults HIGH, relay OFF
  }
}

void loop()
{
  // readings and control
  for (int i = 0; i &lt; 4; i++) {
    reading[i] = analogRead(tempPin[i]);
    tempC[i] = reading[i] / 9.31;


    if (tempC[i] &lt; lowerLimit) {
      digitalWrite(relayPin[i], LOW);   //relay OFF
    }
    else if (tempC[i] &gt; upperLimit) {
      digitalWrite(relayPin[i], HIGH);  // relay ON
    }
  }
  printCheck = millis() - lastPrintTime;
  if (printCheck &gt;= printInterval) {
    for (int i = 0; i &lt; 4; i++) {
      Serial.print(""tempC"");
      Serial.print(i + 1);
      Serial.print("" "");
      Serial.println(tempC[i]);
    }
    Serial.println();
    lastPrintTime = millis(); // reset print timer
  }
}
</code></pre>

<p><strong>The average code I got from Arduino Learning center is this one:</strong></p>

<pre><code>/*

  Smoothing

  Reads repeatedly from an analog input, calculating a running average
  and printing it to the computer.  Keeps ten readings in an array and
  continually averages them.

  The circuit:
    * Analog sensor (potentiometer will do) attached to analog input 0

  Created 22 April 2007
  By David A. Mellis  &lt;dam@mellis.org&gt;
  modified 9 Apr 2012
  by Tom Igoe
  http://www.arduino.cc/en/Tutorial/Smoothing

  This example code is in the public domain.


*/


// Define the number of samples to keep track of.  The higher the number,
// the more the readings will be smoothed, but the slower the output will
// respond to the input.  Using a constant rather than a normal variable lets
// use this value to determine the size of the readings array.
const int numReadings = 10;

int readings[numReadings];      // the readings from the analog input
int readIndex = 0;              // the index of the current reading
int total = 0;                  // the running total
int average = 0;                // the average

int inputPin = A0;

void setup() {
  // initialize serial communication with computer:
  Serial.begin(9600);
  // initialize all the readings to 0:
  for (int thisReading = 0; thisReading &lt; numReadings; thisReading++) {
    readings[thisReading] = 0;
  }
}

void loop() {
  // subtract the last reading:
  total = total - readings[readIndex];
  // read from the sensor:
  readings[readIndex] = analogRead(inputPin);
  // add the reading to the total:
  total = total + readings[readIndex];
  // advance to the next position in the array:
  readIndex = readIndex + 1;

  // if we're at the end of the array...
  if (readIndex &gt;= numReadings) {
    // ...wrap around to the beginning:
    readIndex = 0;
  }

  // calculate the average:
  average = total / numReadings;
  // send it to the computer as ASCII digits
  Serial.println(average);
  delay(1);        // delay in between reads for stability
}
</code></pre>

<p><strong>The monster I created joining both codes is this one:</strong></p>

<pre><code>const byte tempPin[] = {A1, A2, A3, A4};
const byte relayPin[] = {6, 7, 8, 9};

// hysteresis = upperLimit - lowerLimit
const byte lowerLimit = 24;
const byte upperLimit = 31;

float tempC[4];
word reading[4];

const int numReadings = 50;
int readings[numReadings];
int readIndex = 0;
int total = 0;
float average[4];


word printInterval = 1000; // 1 second
unsigned long printCheck = 0, lastPrintTime = 0;

void setup()
{
  analogReference(INTERNAL);
  Serial.begin(115200);
  for (int i = 0; i &lt; 4; i++) {
    pinMode(relayPin[i], INPUT_PULLUP);
    pinMode(relayPin[i], OUTPUT); // defaults HIGH, relay OFF
  }
  for (int thisReading = 0; thisReading &lt; numReadings; thisReading++){
    readings[thisReading] = 0;
  }
}

void loop()
{
  // readings and control
  for (int i = 0; i &lt; 4; i++) {
    reading[i] = analogRead(tempPin[i]);
    tempC[i] = reading[i] / 9.31;
    total[i] = total[i] - readings[readIndex];
    readings[readIndex] = tempC[i]
    total[i] = total[i] + readings[readIndex]
    readIndex[i] = readIndex[i] + 1 ;
    if (readIntex[i] &gt;= numReadings) {
      readIndex = 0;
    }
    average[i] = total[i] / numReadings;

    if (average[i] &lt; lowerLimit) {
      digitalWrite(relayPin[i], LOW);   //relay OFF
    }
    else if (average[i] &gt; upperLimit) {
      digitalWrite(relayPin[i], HIGH);  // relay ON
    }
  }
  printCheck = millis() - lastPrintTime;
  if (printCheck &gt;= printInterval) {
    for (int i = 0; i &lt; 4; i++) {
      Serial.print(""tempC"");
      Serial.print(i + 1);
      Serial.print("" "");
      Serial.println(tempC[i]);
    }
    Serial.println();
    lastPrintTime = millis(); // reset print timer
  }
}
</code></pre>

<p><strong>These are the errors that I got:</strong></p>

<pre><code>Arduino: 1.6.8 (Windows 7), Board: ""Arduino/Genuino Uno""

\temprelayfinal2.ino: In function 'void loop()':

temprelayfinal2:40: error: invalid types 'int[int]' for array subscript

     total[i] = total[i] - readings[readIndex];

            ^

temprelayfinal2:40: error: invalid types 'int[int]' for array subscript

     total[i] = total[i] - readings[readIndex];

                       ^

temprelayfinal2:42: error: expected ';' before 'total'

     total[i] = total[i] + readings[readIndex]

     ^

temprelayfinal2:44: error: 'readIntex' was not declared in this scope

     if (readIntex[i] &gt;= numReadings) {

         ^

temprelayfinal2:47: error: invalid types 'int[int]' for array subscript

     average[i] = total[i] / numReadings;

                         ^

exit status 1
invalid types 'int[int]' for array subscript

This report would have more information with
""Show verbose output during compilation""
option enabled in File -&gt; Preferences.
</code></pre>
"
"<p>According to the Specs of the Attiny, this microcontroller only has 128 bytes of memory (RAM).</p>

<p>In the code you declare two arrays:</p>

<pre><code>int pixelsArray[128];   //Array to hold the values of the individual pixles.
int pixelsArray1[128];
</code></pre>

<p>which will occuppy much more memory than the available on this microcontroller.
Try to reduce the size of the array. Each int entry occupies 2 bytes according to the <a href=""https://www.arduino.cc/en/Reference/Int"" rel=""nofollow"">link</a>.</p>
"
"<p>I am working on a project that uses data taken from 3 separate BNO055 sensors and transmits it to an Arduino Mega 2560. I only have a basic knowledge of the code, and am having trouble figuring out how to use all 3 of them with the Arduino. I have tested out the Arduino with one of the IMUs and it works correctly. I connected the Vin of the BNO055 to the 3.3v of the Arduino, the ground to the ground, the SDA to the SDA 20 pin, and the SCL to the SCL 21. I realize that I have to incorporate the ADR (COM3) of the BNO055, but I am not sure how. Any help would be awesome. Please let me know if you need any other information! </p>

<p>BNO055 Data Sheet:
<a href=""https://cdn-shop.adafruit.com/product-files/2472/BST_BNO055_DS000_13.pdf"" rel=""nofollow"">https://cdn-shop.adafruit.com/product-files/2472/BST_BNO055_DS000_13.pdf</a></p>

<p>UPDATE: I have successfully connected two of the sensors to the Mega by setting the second sensor ADR pin to low. However, nothing I have tried for the third sensor is working. I have been reading online and it seems that I have a couple options. Ether a) Program the software to run one sensor at a time (do not know how to do this) b)Use a multiplexer c) use two Arduinos. Any suggestions that you guys have to best go about this? </p>
"
"<p>Simplest way to do this is two MOSFETs (one per motor, because you don't need to change direction), and some miscellaneous passives, and a flyback diode for each motor.</p>

<p>See <a href=""http://bildr.org/2012/03/rfp30n06le-arduino/"" rel=""nofollow"">this tutorial</a> for wiring diagrams and details.</p>
"
"<p>First things first: do you know that a GPS can locate your dog accurately enough in your home?</p>

<p>Basically, even with a good GPS receiver, the best accuracy you can expect (using off-the-shelf receivers, non-military or DGPS) is maybe 3 m. Typical performance is maybe 4 m, and indoors it will be even worse. The point is, your dog could be 5 m away from your intended location, and you will get an alarm. 5 m in a house might be the room over, two rooms over, or outside the house!</p>

<p>However, if you want to go forward with this, get yourself a GPS module, connect it to your Arduino, install the <a href=""http://arduiniana.org/libraries/tinygpsplus/"" rel=""nofollow"">TinyGPS++</a> library (one of the better Arduino GPS libs IMO), and play with it. It's easy to figure out how to perform an action when the GPS coordinates are in range of a given coordinate set.</p>

<p>You might have better luck using a different form of dog location detection.</p>
"
"<pre><code>total[i] = total[i] - readings[readIndex];
</code></pre>

<p><code>total</code> is of type <code>int</code>. That is, it is a scalar integer. You cannot index into it, <code>total[i]</code> doesn't make sense. That is why the compiler is complaining.</p>
"
"<p>Since you do not have enough RAM for your arrays, something has to
give. A few options:</p>

<ol>
<li>Do you really need the 10-bit precision of the ADC? If you can live
with 8 bits, then use 8-bit arrays (type <code>uint8_t</code>) and store only
the 8 most significant bits of each reading
(<code>pixelsArray[i]=analogRead(Aout)&gt;&gt;2</code>). This will make the arrays
half as big.</li>
<li>If you really need 10-bit precision, maybe you do not need 128-pixel
resolution? Then you could store only every other pixel. This will
also halve the array sizes.</li>
<li>If you do need both the full precision and the full resolution, then
you will have to pack the bits tight. You can pack up to 4 readings
in 5 bytes. But this will increase the complexity of your program.</li>
</ol>

<p><strong>Addendum</strong>: To declare the arrays as being made of 8-bit integers,
just replace</p>

<pre><code>int pixelsArray[128];
int pixelsArray1[128];
</code></pre>

<p>by</p>

<pre><code>uint8_t pixelsArray[128];
uint8_t pixelsArray1[128];
</code></pre>

<p>Here “uint8_t” means “unsigned 8-bit integer”, whereas “int” is a
regular integer, i.e. signed and, on the AVRs, 16-bits long.</p>
"
"<p>guys.</p>

<p>I'm writing here because I cannot find an obvious error, so I'm stuck. Could you please help me?</p>

<p>Here's the code:</p>

<pre><code>int arrayAAA[] = {6, 8, 10, 12};
int arrayBBB[] = {9, 15, 27, 41};

const int arrayAAALength = sizeof(arrayAAA)/sizeof(int);
const int arrayBBBLength = sizeof(arrayBBB)/sizeof(int);

int newArrayLength = 0;

void setup() {

    Serial.begin(9600);

}

void loop() {

  String dir = ""AAA"";

  if (dir == ""AAA""){

      //Copy existing array to the new one...
      newArrayLength = arrayAAALength;              //Get the size of source array
      int newArray[newArrayLength];                 //Make the new array of the same size
      memcpy(newArray, arrayAAA, sizeof(arrayAAA)); //Copy content of the source array to the new one

      /*
      for (int i = 0; i &lt; newArrayLength; i++){
          Serial.print(newArray[i]); //Here everything works just fine...
          Serial.print(""   "");
      }
       */    
  }

  for (int i = 0; i &lt; newArrayLength; i++){
      Serial.print(newArray[i]); //But here I see this error: 'newArray' was not declared in this scope
      Serial.print(""   "");
  }

  Serial.println();
  Serial.println();

}
</code></pre>

<p>What I'm trying to do is to copy the array to a new one, but depending on the circumstances I need to take different source arrays (AAA or BBB).</p>

<p>The problem is in checking the values of an newly crreated array: </p>

<pre><code>'newArray' was not declared in this scope
</code></pre>

<p>if I try to check its valus outside of if statment.</p>

<p>It seems my stupid mistake, but I can't find it.</p>
"
"<p>The clue is in the indenting:</p>

<pre><code>  if (dir == ""AAA""){

      //Copy existing array to the new one...
      newArrayLength = arrayAAALength;              //Get the size of source array
      int newArray[newArrayLength];                 //Make the new array of the same size &lt;&lt;&lt;==== DEFINED IN THE SCOPE OF ""IF""
      memcpy(newArray, arrayAAA, sizeof(arrayAAA)); //Copy content of the source array to the new one

      /*
      for (int i = 0; i &lt; newArrayLength; i++){
          Serial.print(newArray[i]); //Here everything works just fine...
          Serial.print(""   "");
      }
       */    
  }

  for (int i = 0; i &lt; newArrayLength; i++){
      Serial.print(newArray[i]); //But here I see this error: 'newArray' was not declared in this scope &lt;&lt;=== USED IN THE SCOPE OF ""FOR""
      Serial.print(""   "");
  }
</code></pre>

<p>As you can see by the indenting the definition of <code>newArray</code> is in a different block of code which you come right out of before you use it.</p>

<p>You must define <code>newArray</code> at a scope that is <em>outside</em> where you use it.</p>

<p>From that code you don't actually need to copy the contents of one array into another - you can just <em>point</em> to the array you want to use with a pointer.  Alternatively, if you do need to clone the array contents (for some other purpose we don't know of) then you should pre-create an array that is big enough to hold <em>either</em> of your other arrays.</p>

<pre><code>int newArray[max(arrayAAALength, arrayBBBLength)];
</code></pre>
"
"<p>I have been trying to get the simple example code for reading and writing to RFID tags to work from NDEF and PN532 library but I cant get the board to be recognized.  I have gotten the board to read a card using the Adafruit_PN532 library using a SPI connection but when I switch over to the other libraries it isn't recognized.  Is there a different wiring set up so that the NDEF and PN532 libraries can see the card?  </p>

<p>This code works with the wiring set up</p>

<pre><code>    /**************************************************************************/
    /*! 
    @file     iso14443a_uid.pde
    @author   Adafruit Industries
    @license  BSD (see license.txt)

    This example will attempt to connect to an ISO14443A
    card or tag and retrieve some basic information about it
    that can be used to determine what type of card it is.   

    Note that you need the baud rate to be 115200 because we need to print
    out the data and read from the card at the same time!

This is an example sketch for the Adafruit PN532 NFC/RFID breakout boards
This library works with the Adafruit NFC breakout 
  ----&gt; https://www.adafruit.com/products/364

Check out the links above for our tutorials and wiring diagrams 
These chips use SPI or I2C to communicate.

Adafruit invests time and resources providing this open source code, 
please support Adafruit and open-source hardware by purchasing 
products from Adafruit!

*/
/**************************************************************************/
#include &lt;Wire.h&gt;
#include &lt;SPI.h&gt;
#include &lt;Adafruit_PN532.h&gt;

// If using the breakout with SPI, define the pins for SPI communication.
#define PN532_SCK  (2)
#define PN532_MOSI (3)
#define PN532_SS   (4)
#define PN532_MISO (5)

// If using the breakout or shield with I2C, define just the pins connected
// to the IRQ and reset lines.  Use the values below (2, 3) for the shield!
#define PN532_IRQ   (2)
#define PN532_RESET (3)  // Not connected by default on the NFC Shield

// Uncomment just _one_ line below depending on how your breakout or shield
// is connected to the Arduino:

// Use this line for a breakout with a SPI connection:
Adafruit_PN532 nfc(PN532_SCK, PN532_MISO, PN532_MOSI, PN532_SS);

// Use this line for a breakout with a hardware SPI connection.  Note that
// the PN532 SCK, MOSI, and MISO pins need to be connected to the Arduino's
// hardware SPI SCK, MOSI, and MISO pins.  On an Arduino Uno these are
// SCK = 13, MOSI = 11, MISO = 12.  The SS line can be any digital IO pin.
//Adafruit_PN532 nfc(PN532_SS);

// Or use this line for a breakout or shield with an I2C connection:
//Adafruit_PN532 nfc(PN532_IRQ, PN532_RESET);

void setup(void) {
  Serial.begin(115200);
  Serial.println(""Hello!"");

  nfc.begin();

  uint32_t versiondata = nfc.getFirmwareVersion();
  if (! versiondata) {
    Serial.print(""Didn't find PN53x board"");
    while (1); // halt
  }

  // Got ok data, print it out!
  Serial.print(""Found chip PN5""); Serial.println((versiondata&gt;&gt;24) &amp; 0xFF, HEX); 
  Serial.print(""Firmware ver. ""); Serial.print((versiondata&gt;&gt;16) &amp; 0xFF, DEC); 
  Serial.print('.'); Serial.println((versiondata&gt;&gt;8) &amp; 0xFF, DEC);

  // Set the max number of retry attempts to read from a card
  // This prevents us from waiting forever for a card, which is
  // the default behaviour of the PN532.
  nfc.setPassiveActivationRetries(0xFF);

  // configure board to read RFID tags
  nfc.SAMConfig();

  Serial.println(""Waiting for an ISO14443A card"");
}

void loop(void) {
  boolean success;
  uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };  // Buffer to store the returned UID
  uint8_t uidLength;                // Length of the UID (4 or 7 bytes depending on ISO14443A card type)

  // Wait for an ISO14443A type cards (Mifare, etc.).  When one is found
  // 'uid' will be populated with the UID, and uidLength will indicate
  // if the uid is 4 bytes (Mifare Classic) or 7 bytes (Mifare Ultralight)
  success = nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, &amp;uid[0], &amp;uidLength);

  if (success) {
    Serial.println(""Found a card!"");
    Serial.print(""UID Length: "");Serial.print(uidLength, DEC);Serial.println("" bytes"");
    Serial.print(""UID Value: "");
    for (uint8_t i=0; i &lt; uidLength; i++) 
    {
      Serial.print("" 0x"");Serial.print(uid[i], HEX); 
    }
    Serial.println("""");
    // Wait 1 second before continuing
    delay(1000);
  }
  else
  {
    // PN532 probably timed out waiting for a card
    Serial.println(""Timed out waiting for a card"");
  }
}
</code></pre>

<p>But switching over to the PN532 and NDEF libraries this code doesn't work </p>

<pre><code>#if 0
#include &lt;SPI.h&gt;
#include &lt;PN532_SPI.h&gt;
#include &lt;PN532.h&gt;
#include &lt;NfcAdapter.h&gt;

PN532_SPI pn532spi(SPI, 10);
NfcAdapter nfc = NfcAdapter(pn532spi);
#else

#include &lt;Wire.h&gt;
#include &lt;PN532_I2C.h&gt;
#include &lt;PN532.h&gt;
#include &lt;NfcAdapter.h&gt;

PN532_I2C pn532_i2c(Wire);
NfcAdapter nfc = NfcAdapter(pn532_i2c);
#endif

void setup(void) {
    Serial.begin(9600);
    Serial.println(""NDEF Reader"");
    nfc.begin();
}

void loop(void) {
    Serial.println(""\nScan a NFC tag\n"");
    if (nfc.tagPresent())
    {
        NfcTag tag = nfc.read();
        tag.print();
    }
    delay(5000);
}
</code></pre>

<p>I get the output of </p>

<pre><code>NDEF Reader
Didn't find PN53x board
</code></pre>
"
"<p>I've flashed AT firmware onto my nodeMCU development board and when I reconnect it, the built in LED gets switched on and the module continuously sends some garbage data to the serial monitor. So how do I reset the module? ( pressing the reset button does nothing except giving a momentary pause to the above process) the same problem occurs when I upload a sketch onto the module. How do I reset it before uploading a new sketch?</p>
"
"<p>i am having problem in my  Bluetooth controlled robot i.e after changing in(which is being damaged due to some cause ) of Arduino  now when i am trying to use my robot with new ic and same program its motor is moving very slowly and even right motor stops working please help me please?</p>
"
"<p>My final project goal is to make Brushless gimbal for drones using only Arduino MEGA 2560 and 9DOF IMU for control. On Instructables I found two excellent tutorials. Both are different than mine in selected components.</p>

<p>I use the following components:</p>

<p>Arduino MEGA2560 </p>

<p>Motors - Quanum 2208 Precision Brushless Gimbal Motor ( httpx://goo.gl/RDBvJL)</p>

<p>Motor Driver - H bridge L298n (httpx://goo.gl/A4ZQi5)</p>

<p>9DOF Razor IMU (httpx://goo.gl/myg9oj )</p>

<p>I'm stuck with 9DOF Razor IMU. Surfing on the internet I found a great tutorial and  github repository (httpx://goo.gl/jh2pfU). This tutorial is excellent and AHRS works great with the FTDI Basic Breakout 3.3V. They gave me a good starting point, but my goal is use only Arduino MEGA2560 and sensors.</p>

<p>I want to connect the Arduino and 9DOF IMU directly and use the accelerometer data (Yaw, Pitch, Roll) for directly control the engines. On the website of the manufacturer Sparkfun (httpx://goo.gl/myg9oj ) I can’t find any datasheet exclusively for 9DOF IMU that could help me to connect Arduino and IMU. There are only datasheet of sensors that are on IMU ( ITG-3200 (MEMS triple-axis gyro), ADXL345 (triple-axis accelerometer), and HMC5883L (triple-axis magnetometer)  which are useless for me. </p>

<p>That's why I decided to use code from this site ( httpx://goo.gl/zOnYjN ) and he works great. I connected everything as is in tutorial and  Arduino SerialMonitor show me the desired values YPR. Values load very quickly directly from IMU and printed on SerialMonitor.</p>

<p>Values on SerialMonitor looks like this: </p>

<h1>YPR=72.13,1.74,-16.38</h1>

<h1>YPR=72.14,1.72,-16.39</h1>

<h1>YPR=72.12,1.71,-16.39</h1>

<h1>YPR=72.13,1.71,-16.37</h1>

<h1>YPR=72.13,1.70,-16.40 …</h1>

<p><strong>HELP ME</strong></p>

<p>This is my first solo Arduino project and I have a lot of questions about it. 
How could I parse the data that appears on SerialMonitor to get new variables eg. Yaw = 72.12, Pitch = 1.74, Roll = -16.39?</p>

<p>Is it possible to do that?</p>

<p>Does anyone have any experience with 9DOF razor IMU and maybe know  better way to collect information from the accelerometer 9DOF razor IMU?</p>

<p>I want to achieve three separate variables which i will use to control the brushless motor. I think this should be an easier method as it is just comma separated numbers but then again i am new to arduino serial communication so i would appreciate any help with this. Even if it's only how to parse and extract the values. </p>
"
"<p>Using the exponential moving average filter suggested by Gerben, things
become quite simpler:</p>

<pre><code>const byte tempPin[] = {A1, A2, A3, A4};
const byte relayPin[] = {6, 7, 8, 9};

// hysteresis = upperLimit - lowerLimit
const byte lowerLimit = 24;
const byte upperLimit = 31;

const int numReadings = 64;
const word printInterval = 1000; // 1 second

float tempC[4];
unsigned long lastPrintTime = 0;

void setup()
{
  analogReference(INTERNAL);
  Serial.begin(115200);
  for (int i = 0; i &lt; 4; i++) {
    digitalWrite(relayPin[i], HIGH);
    pinMode(relayPin[i], OUTPUT);
  }
}

void loop()
{
  // readings and control
  for (int i = 0; i &lt; 4; i++) {
    float raw_temp = analogRead(tempPin[i]) / 9.31;
    tempC[i] += (raw_temp - tempC[i]) / numReadings;  // filter
    if (tempC[i] &lt; lowerLimit) {
      digitalWrite(relayPin[i], LOW);   //relay OFF
    }
    else if (tempC[i] &gt; upperLimit) {
      digitalWrite(relayPin[i], HIGH);  // relay ON
    }
  }
  if (millis() - lastPrintTime &gt;= printInterval) {
    for (int i = 0; i &lt; 4; i++) {
      Serial.print(""tempC"");
      Serial.print(i + 1);
      Serial.print("" "");
      Serial.println(tempC[i]);
    }
    Serial.println();
    lastPrintTime = millis(); // reset print timer
  }
}
</code></pre>
"
"<p>I programmed by Uno using your <a href=""http://rodbhar.com/how-to-install-amforth-on-the-arduino-uno/"" rel=""nofollow"">first guide</a> and it seems to work OK.</p>

<pre><code>amforth 6.1 ATmega
8P Forthduino
</code></pre>

<p>For example, using the serial monitor, I entered:</p>

<pre><code>6 7 * .
</code></pre>

<p>It printed:</p>

<pre><code>42  ok
&gt; 
</code></pre>

<p>Then  entered the ASCII table example:</p>

<pre class=""lang-forth prettyprint-override""><code>\ print a ascii table
: .ascii
base @
$7f $20 do
    i emit
    decimal  ."" , dec: "" i .
    hex      ."" , hex: "" i .
    8 base ! ."" , oct: "" i .
    2 base ! ."" , bin: "" i .
    cr
loop
base !
;
</code></pre>

<p>Then when I invoked it with "".ascii"" it printed the table:</p>

<pre class=""lang-none prettyprint-override""><code>&gt; .ascii
 , dec: 32 , hex: 20 , oct: 40 , bin: 100000 
!, dec: 33 , hex: 21 , oct: 41 , bin: 100001 
"", dec: 34 , hex: 22 , oct: 42 , bin: 100010 
#, dec: 35 , hex: 23 , oct: 43 , bin: 100011 
$, dec: 36 , hex: 24 , oct: 44 , bin: 100100 
%, dec: 37 , hex: 25 , oct: 45 , bin: 100101 
&amp;, dec: 38 , hex: 26 , oct: 46 , bin: 100110 
', dec: 39 , hex: 27 , oct: 47 , bin: 100111 
(, dec: 40 , hex: 28 , oct: 50 , bin: 101000 
), dec: 41 , hex: 29 , oct: 51 , bin: 101001 
*, dec: 42 , hex: 2A , oct: 52 , bin: 101010 
+, dec: 43 , hex: 2B , oct: 53 , bin: 101011 
,, dec: 44 , hex: 2C , oct: 54 , bin: 101100 
-, dec: 45 , hex: 2D , oct: 55 , bin: 101101 
., dec: 46 , hex: 2E , oct: 56 , bin: 101110 
/, dec: 47 , hex: 2F , oct: 57 , bin: 101111 
0, dec: 48 , hex: 30 , oct: 60 , bin: 110000 
1, dec: 49 , hex: 31 , oct: 61 , bin: 110001 
2, dec: 50 , hex: 32 , oct: 62 , bin: 110010 
3, dec: 51 , hex: 33 , oct: 63 , bin: 110011 
4, dec: 52 , hex: 34 , oct: 64 , bin: 110100 
5, dec: 53 , hex: 35 , oct: 65 , bin: 110101 
6, dec: 54 , hex: 36 , oct: 66 , bin: 110110 
7, dec: 55 , hex: 37 , oct: 67 , bin: 110111 
8, dec: 56 , hex: 38 , oct: 70 , bin: 111000 
9, dec: 57 , hex: 39 , oct: 71 , bin: 111001 
:, dec: 58 , hex: 3A , oct: 72 , bin: 111010 
;, dec: 59 , hex: 3B , oct: 73 , bin: 111011 
&lt;, dec: 60 , hex: 3C , oct: 74 , bin: 111100 
=, dec: 61 , hex: 3D , oct: 75 , bin: 111101 
&gt;, dec: 62 , hex: 3E , oct: 76 , bin: 111110 
?, dec: 63 , hex: 3F , oct: 77 , bin: 111111 
@, dec: 64 , hex: 40 , oct: 100 , bin: 1000000 
A, dec: 65 , hex: 41 , oct: 101 , bin: 1000001 
B, dec: 66 , hex: 42 , oct: 102 , bin: 1000010 
C, dec: 67 , hex: 43 , oct: 103 , bin: 1000011 
D, dec: 68 , hex: 44 , oct: 104 , bin: 1000100 
E, dec: 69 , hex: 45 , oct: 105 , bin: 1000101 
F, dec: 70 , hex: 46 , oct: 106 , bin: 1000110 
G, dec: 71 , hex: 47 , oct: 107 , bin: 1000111 
H, dec: 72 , hex: 48 , oct: 110 , bin: 1001000 
I, dec: 73 , hex: 49 , oct: 111 , bin: 1001001 
J, dec: 74 , hex: 4A , oct: 112 , bin: 1001010 
K, dec: 75 , hex: 4B , oct: 113 , bin: 1001011 
L, dec: 76 , hex: 4C , oct: 114 , bin: 1001100 
M, dec: 77 , hex: 4D , oct: 115 , bin: 1001101 
N, dec: 78 , hex: 4E , oct: 116 , bin: 1001110 
O, dec: 79 , hex: 4F , oct: 117 , bin: 1001111 
P, dec: 80 , hex: 50 , oct: 120 , bin: 1010000 
Q, dec: 81 , hex: 51 , oct: 121 , bin: 1010001 
R, dec: 82 , hex: 52 , oct: 122 , bin: 1010010 
S, dec: 83 , hex: 53 , oct: 123 , bin: 1010011 
T, dec: 84 , hex: 54 , oct: 124 , bin: 1010100 
U, dec: 85 , hex: 55 , oct: 125 , bin: 1010101 
V, dec: 86 , hex: 56 , oct: 126 , bin: 1010110 
W, dec: 87 , hex: 57 , oct: 127 , bin: 1010111 
X, dec: 88 , hex: 58 , oct: 130 , bin: 1011000 
Y, dec: 89 , hex: 59 , oct: 131 , bin: 1011001 
Z, dec: 90 , hex: 5A , oct: 132 , bin: 1011010 
[, dec: 91 , hex: 5B , oct: 133 , bin: 1011011 
\, dec: 92 , hex: 5C , oct: 134 , bin: 1011100 
], dec: 93 , hex: 5D , oct: 135 , bin: 1011101 
^, dec: 94 , hex: 5E , oct: 136 , bin: 1011110 
_, dec: 95 , hex: 5F , oct: 137 , bin: 1011111 
`, dec: 96 , hex: 60 , oct: 140 , bin: 1100000 
a, dec: 97 , hex: 61 , oct: 141 , bin: 1100001 
b, dec: 98 , hex: 62 , oct: 142 , bin: 1100010 
c, dec: 99 , hex: 63 , oct: 143 , bin: 1100011 
d, dec: 100 , hex: 64 , oct: 144 , bin: 1100100 
e, dec: 101 , hex: 65 , oct: 145 , bin: 1100101 
f, dec: 102 , hex: 66 , oct: 146 , bin: 1100110 
g, dec: 103 , hex: 67 , oct: 147 , bin: 1100111 
h, dec: 104 , hex: 68 , oct: 150 , bin: 1101000 
i, dec: 105 , hex: 69 , oct: 151 , bin: 1101001 
j, dec: 106 , hex: 6A , oct: 152 , bin: 1101010 
k, dec: 107 , hex: 6B , oct: 153 , bin: 1101011 
l, dec: 108 , hex: 6C , oct: 154 , bin: 1101100 
m, dec: 109 , hex: 6D , oct: 155 , bin: 1101101 
n, dec: 110 , hex: 6E , oct: 156 , bin: 1101110 
o, dec: 111 , hex: 6F , oct: 157 , bin: 1101111 
p, dec: 112 , hex: 70 , oct: 160 , bin: 1110000 
q, dec: 113 , hex: 71 , oct: 161 , bin: 1110001 
r, dec: 114 , hex: 72 , oct: 162 , bin: 1110010 
s, dec: 115 , hex: 73 , oct: 163 , bin: 1110011 
t, dec: 116 , hex: 74 , oct: 164 , bin: 1110100 
u, dec: 117 , hex: 75 , oct: 165 , bin: 1110101 
v, dec: 118 , hex: 76 , oct: 166 , bin: 1110110 
w, dec: 119 , hex: 77 , oct: 167 , bin: 1110111 
x, dec: 120 , hex: 78 , oct: 170 , bin: 1111000 
y, dec: 121 , hex: 79 , oct: 171 , bin: 1111001 
z, dec: 122 , hex: 7A , oct: 172 , bin: 1111010 
{, dec: 123 , hex: 7B , oct: 173 , bin: 1111011 
|, dec: 124 , hex: 7C , oct: 174 , bin: 1111100 
}, dec: 125 , hex: 7D , oct: 175 , bin: 1111101 
~, dec: 126 , hex: 7E , oct: 176 , bin: 1111110 
 ok
&gt; 
</code></pre>

<hr>

<p>I suspect your issue is you are not using it the way it is supposed to be used. Can you show the exact commands you type which cause the error?</p>

<hr>

<p><em>(Edited to add)</em></p>

<p>After fairly extensive investigation of the source, I think that <code>.s</code> is not necessarily implemented for the Uno .hex file.</p>

<p>I found one suggested implementation <a href=""https://www.mail-archive.com/search?l=amforth-devel@lists.sourceforge.net&amp;q=subject:%22Re%3A+[Amforth]+.S+%E2%80%9Cdot-s%E2%80%9D%22&amp;o=newest&amp;f=1"" rel=""nofollow"">here</a>:</p>

<pre class=""lang-forth prettyprint-override""><code>: .s  ( -- )\ stack picture listing order
depth
begin dup while dup pick . 1- repeat
drop
;
</code></pre>

<p>Running that it seems to work OK:</p>

<pre><code>&gt; 1 2 3 4 .s
1 2 3 4  ok
</code></pre>

<p>The <code>.s</code> word is implemented in the file <code>dot-s.asm</code> where you can see exactly how they did it (it's not the same as the Forth version above).</p>
"
"<p>Looking at <a href=""https://learn.sparkfun.com/tutorials/arduino-comparison-guide"" rel=""nofollow"" title=""Sparkfun comparsion"">the Sparkfun comparison</a>, it seems that the Due is by far the fastest of the Arduinos and has I/O capabilities similar to the Mega. So why was it retired with no obvious successor?</p>
"
"<p><em>Made corrections per @Majenko's comment</em></p>

<p>The following will <strong>not</strong> work on real Arduinos, but it did work for me on the ESP8266 and the Teensy3, which are what I use mostly, and the only ones I tested the code for: <a href=""https://github.com/jayeye/jardino/tree/master/esp8266/ase25017"" rel=""nofollow"">https://github.com/jayeye/jardino/tree/master/esp8266/ase25017</a></p>

<pre><code>#include &lt;vector&gt;
  ...
  size_t vector_size = 42;
  std::vector&lt;int&gt; foo(vector_size);  // foo is a vector of 42 integers
</code></pre>

<p><strong>Another correction:</strong> Exceptions do not work even on the aforementioned platforms, so do not access the vector with <code>.at(n)</code></p>

<p>If you <em>must</em> have an array, use a unique_ptr with an array allocator:</p>

<pre><code>#include &lt;memory&gt;
  ...
  size_t vector_size = 42;
  std::unique_ptr&lt;int[]&gt; arr(new int[vector_size]);
</code></pre>

<p>When <code>arr</code> goes out of scope, the array will be automatically freed.</p>

<p>You can always use malloc(), but you'll have to remember to free() it, and that's always a source of bugs.</p>
"
"<p>Because, basically (in my opinion, anyway) it was rubbish.</p>

<p>Yes, it has grunt. Yes, it has IO, but the chips themselves are pretty rancid.</p>

<p>There are far better options than the SAM3X from other manufacturers.</p>

<p>Also, since all the in-fighting began between the two Arduino factions (.org / .cc) the majority of actual progress and innovation has been by third parties (Intel mostly).</p>
"
"<p>A more low-tech solution might be better. For example, a couple of light beams across the doorway to the kitchen. An human would block both of them as they passed, and a dog only the lower one. You could sound an alarm if the lower one is broken, and the upper one is not broken (within a second).</p>

<hr>

<p>Or do something with infra-red transmitters / receivers. There are lots of Arduino projects using those. You could have a transmitter in the kitchen pointing towards the doorway, sending some code (eg. 1234). Mount on the dog an Arduino with an IR decoder sketch. When the dog enters the kitchen it will get the code, and then you could sound a beeper. The beeper alone might make the dog change its mind about going in, especially if you go after it yelling ""bad dog!"" every time the beeper goes off.</p>

<p>Since the IR beam is just light, it would only go in a straight line, and if properly positioned would flood the kitchen, but not hit anywhere else.</p>

<hr>

<h2>Proof of concept</h2>

<p>I made up a test of my idea of the IR transmitter.</p>

<p><em>(Please don't report me to the moderators for being off-topic. I know the question was about a GPS, but the <strong>real</strong> question is how to detect that the dog has come into the kitchen).</em></p>

<p>You can get IR (infra-red) LEDs cheaply at any electronics supplier (or eBay). They are like normal LEDs except that they transmit in the IR light range. They can also usually handle higher currents, like 80 mA.</p>

<hr>

<h2>Sender</h2>

<p>So, to drive that from the Arduino we need a transistor to boost the output from the Arduino pin, like this:</p>

<p><a href=""http://i.stack.imgur.com/ZF3ps.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/ZF3ps.png"" alt=""IR driver""></a></p>

<p>Note that the positive pin of the LED will have a longer lead. The positive pin goes to the 39 ohm resistor, and the negative (shorter) lead goes to the transistor collector. In the schematic the negative pin (cathode) is at the bottom and has a horizontal line (think of the horizontal line as a minus sign).</p>

<p>The 39 ohm resistor limits current through the LED to 74 mA. Assuming a LED forward voltage of 2.1V we have:</p>

<pre><code> (5V - 2.1V) / 39Ω = 74 mA
</code></pre>

<p>The 470 ohm resistor limits current through the transistor base.</p>

<hr>

<h2>Sender code</h2>

<p>Then some simple code to send a IR code (using PWM modulation like TV remotes do). There is a library for that, so the code is very simple:</p>

<pre class=""lang-c++ prettyprint-override""><code>#include &lt;IRLib.h&gt;

IRsend My_Sender;

const unsigned long DOG_ALERT_CODE = 0xBADA;

void setup()
  {
  }

void loop() 
  {
  My_Sender.send (NEC, DOG_ALERT_CODE, 20); 
  delay (1000);
  }
</code></pre>

<p>That sends the code 0xBADA (which I just picked at random) every second using the NEC IR protocol.</p>

<p>The objective would be to have this plugged into the power somewhere in the kitchen, and aimed at the doorway. The IR library uses digital pin 3 (on the Uno at least). That happens to be the Timer 2 ""B"" output to send 38 kHz PWM (pulse-width-modulated) signal, which it interrupts from time to time to encode the code into it.</p>

<hr>

<h2>Receiver</h2>

<p>Now we need something on the dog to detect the IR code. The objective is to notice the code above (eg. 0xBADA) and if found, sound a tone on a speaker, otherwise ignore it. That way we can still use remotes in the kitchen, and the speaker won't sound.</p>

<p><a href=""http://i.stack.imgur.com/6WURi.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/6WURi.png"" alt=""IR Receiver""></a></p>

<p>The code for the receiver is a bit more complex, but not much:</p>

<pre><code>#include &lt;IRLib.h&gt;
#include &lt;TonePlayer.h&gt;

const byte SPEAKER = 9;  // output pin is fixed (OC1A)
const byte IR_READER = 11;
const unsigned long BEEP_WIDTH = 50;
const int BEEP_FREQUENCY = 880;  // Hz
const unsigned long DOG_ALERT_CODE = 0xBADA;

// pin D9 (Uno), D11 (Mega)
TonePlayer tone1 (TCCR1A, TCCR1B, OCR1AH, OCR1AL, TCNT1H, TCNT1L);  

IRrecv My_Receiver(IR_READER); 
IRdecode My_Decoder;

void setup()
  {
  My_Receiver.enableIRIn(); // Start the receiver
  pinMode (SPEAKER, OUTPUT);  
  }

unsigned long lastTone;

void loop()
  {
  if (My_Receiver.GetResults(&amp;My_Decoder)) 
    {
    My_Decoder.decode();
    if (My_Decoder.decode_type == NEC)
      {
      if (My_Decoder.value == DOG_ALERT_CODE)
        {
        tone1.tone (BEEP_FREQUENCY);
        lastTone = millis ();
        }  // end of wanted code
      }  // end of NEC type
      My_Receiver.resume();
    }  // end of if we got a result

    // if time up, stop the beep
    if (millis () - lastTone &gt;= BEEP_WIDTH)
      tone1.noTone ();

  } // end of loop
</code></pre>

<p>This also uses the IR library, this time to detect an incoming code. You wire the ""Data"" pin of the IR detector to digital pin 11 on the Arduino (Uno or similar). The other two pins of the IR detector go to Ground and +5V as marked. </p>

<p>To play a sound get a small piezo speaker and wire that to digital pin 9 (one side) and Ground (other side).</p>

<p>Because of the way that the IR library uses interrupts, I had to use my own Tone library to generate a tone. You can download that from:</p>

<p><a href=""http://www.gammon.com.au/Arduino/TonePlayer.zip"" rel=""nofollow"">http://www.gammon.com.au/Arduino/TonePlayer.zip</a></p>

<hr>

<h2>Testing</h2>

<p>How well did it work? Certainly at short distances (like three feet or one metre) we got a positive result. There could be variance based on the light conditions in the room, and the exact parts you get.</p>

<p>You might want to read the <a href=""https://learn.adafruit.com/tv-b-gone-kit/design-notes"" rel=""nofollow"">design notes for TV B Gone</a> where they discuss the technicalities of sending IR beams. In particular for their design they used <strong>four</strong> IR LEDs to give adequate range. You could add more LEDs by duplicating the transistor driver shown above a few times. In other words, duplicate the transistors, LEDs and resistors. They could all be driven from the same output pin.</p>

<p>As mentioned in the TV B Gone article, you can get different IR LEDs. Some have a narrow beam, but go further, others have a wider beam, but go less far.</p>

<p>Also you could arrange them to point in slightly different directions to cover more of the room.</p>

<p>You could also change the length of the beep when the code is detected (BEEP_WIDTH) in milliseconds. And also the frequency (BEEP_FREQUENCY) which I had at 880 Hz. A higher frequency might annoy the dog more but be less audible to humans. I suppose it depends if you want the dog to hear it or the people in the house.</p>

<hr>

<h2>Hardware size and power</h2>

<p>You probably want a small Arduino (like a Nano) which is physically quite small. Also powering it could be an issue. You could get 3 x AA batteries, which would nominally output around 4.5V, and connect them directly to the +5V pin of the Arduino.</p>

<p>To save battery power you could have the Arduino sleep for (say) a second, wake and eheck for a code, and then sleep again. See my post about power savings for more details about that sort of thing.</p>

<hr>

<h2>Hardware photos</h2>

<p><a href=""http://i.stack.imgur.com/CSEqi.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/CSEqi.jpg"" alt=""IR Transmitter and receiver""></a></p>

<p><a href=""http://i.stack.imgur.com/slBY3.jpg"" rel=""nofollow""><img src=""http://i.stack.imgur.com/slBY3.jpg"" alt=""Piezo speaker""></a></p>
"
"<p>I have simple code working on Serial Communication asn below. With Same data i would impliment Modbus protocol> I have Used Modbus library for arduino earlier which works fine with 9600 baudrate and wont work with higher baudrates.And also have restriction In library ,They directly storing values into Buffers SO i cant able to fig out weather request send proper or improper.
I never Worked on EMbeded c Chip level code.Is there any way to Implement without library for arduino</p>

<p>In below code I would Like Serial value into register and when function called i could read value. Similarly the <strong>function CODE</strong> for Modbus should be implemented.</p>

<p>I am looking for simple c code or implement c code Where i can perform the operation this way.</p>

<p>I am trying to Send modbus Request </p>

<p>I found CRC error calculation like in one of forum</p>

<pre><code> unsigned int crc_fn(unsigned char *dpacket,unsigned int len)    // CRC 16 Function(Error calculation)
    {
        unsigned int crc = 0xffff,poly = 0xa001;
        unsigned char i=0,j=0;

        for(i=0;i&lt;len;i++)
        {
            crc^= dpacket[i];
            for(j=0;j&lt;8;j++)
            {
                if(crc &amp; 0x01)
                {
                    crc &gt;&gt;= 1;
                    crc ^= poly;
                }
                else
                crc &gt;&gt;= 1;
            }
        }
        return (crc);
    }
</code></pre>

<p><strong>I would like to See my code in arduino Like this With CRC check</strong></p>

<pre><code>void Serial_access(void)
{
    unsigned char i=0,len=0,ser_data[60],crc_data[60],j=0;
    unsigned int crc1=0,crc2=0;
    crc1 = crc_fn(&amp;rxbuf[0],6);
    _delay_ms(100);
    if((rxbuf[6] == (unsigned char)(crc1))&amp;&amp;(rxbuf[7] == (unsigned char)(crc1&gt;&gt;8)))
    {
        if(rxbuf[0]==DEVICE_ID)
        {
            if(rxbuf[1] == Function_code)
            {
                if((rxbuf[5]&gt;=1)&amp;&amp;(rxbuf[5]&lt;30))
                {
                    //Address = ((unsigned int)(rxbuf[2]&lt;&lt;8)+((unsigned int)(rxbuf[3])));
                    len = (rxbuf[5]*2);
                    _delay_ms(10);
                    ser_data[0] = 0;
                    ser_data[1] = 0;
                    ser_data[2] = 0;
                    ser_data[3] = 0;
                    ser_data[4] = 0;
                    ser_data[5] = 0;
                    ser_data[6] = 0;
                    ser_data[7] = 0;
                    ser_data[8] = 0;
                    ser_data[9] = 0;
                    ser_data[10] = 0;
                    ser_data[11] = 0;
                    ser_data[12] = 0;
                    ser_data[13] = 0;
                    ser_data[14] = 0;
                    ser_data[15] = 0;
                    ser_data[16] = 0;
                    ser_data[17] = 0;
                    ser_data[18] = 0;
                    ser_data[19] = 0;
                    ser_data[20] = 0;
                    ser_data[21] = 0;
                    ser_data[22] = 0;
                    ser_data[23] = 0;
                    ser_data[24] = 0;
                    ser_data[25] = 0;
                    ser_data[26] = 0;
                    ser_data[27] = 0;
                    ser_data[28] = 0;
                    ser_data[29] = 0;
                    ser_data[30] = 0;
                    ser_data[31] = 0;
                    ser_data[32] = 0;
                    ser_data[33] = 0;
                    ser_data[34] = 0;
                    ser_data[35] = 0;
                    ser_data[36] = 0;
                    ser_data[37] = 0;
                    ser_data[38] = 0;
                    ser_data[39] = 0;
                    ser_data[40] = 0;
                    ser_data[41] = 0;
                    ser_data[42] = 0;
                    ser_data[43] = 0;
                    ser_data[44] = 0;
                    ser_data[45] = 0;
                    ser_data[46] = 0;
                    ser_data[47] = 0;
                    ser_data[48] = 0;
                    ser_data[49] = 0;
                    ser_data[50] = 0;
                    ser_data[51] = 0;
                    ser_data[52] = 0;
                    ser_data[53] = 0;
                    ser_data[54] = 0;
                    ser_data[55] = 0;
                    ser_data[56] = 0;
                    ser_data[57] = 0;
                    ser_data[58] = 0;

                    crc_data[0] = DEVICE_ID;
                    crc_data[1] = Function_code;
                    crc_data[2] = len;

                    j=3;
                    for(i=0;i&lt;len;i++)
                    {
                        crc_data[j++] = ser_data[i];
                    }
                    crc2 = crc_fn(&amp;crc_data[0],(len+3));
                    _delay_ms(100);
                    serial_send(DEVICE_ID);
                    serial_send(Function_code);
                    serial_send(len);
                    for(i=0;i&lt;len;i++)
                    {
                        serial_send(ser_data[i]);
                    }
                    _delay_ms(10);
                    serial_send((unsigned char)(crc2));
                    serial_send((unsigned char)(crc2&gt;&gt;8));
                }
            }
        }
    }
    index = 0;
    for(i=0;i&lt;16;i++)
        rxbuf[i] = 0;
    rec_flag = 0;
    check_flag = 1; 
}
</code></pre>

<p>Here code written in C++, How can we convert these to C</p>

<pre><code>int8_t Modbus::query( modbus_t telegram ) {
  uint8_t u8regsno, u8bytesno;
  if (u8id != 0) return -2;
  if (u8state != COM_IDLE) return -1;

  if ((telegram.u8id == 0) || (telegram.u8id &gt; 247)) return -3;

  au16regs = telegram.au16reg;

  // telegram header
  au8Buffer[ ID ]         = telegram.u8id;
  au8Buffer[ FUNC ]       = telegram.u8fct;
  au8Buffer[ ADD_HI ]     = highByte(telegram.u16RegAdd );
  au8Buffer[ ADD_LO ]     = lowByte( telegram.u16RegAdd );

  switch ( telegram.u8fct ) {
  case MB_FC_READ_COILS:
  case MB_FC_READ_DISCRETE_INPUT:
  case MB_FC_READ_REGISTERS:
  case MB_FC_READ_INPUT_REGISTER:
    au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );
    au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );
    u8BufferSize = 6;
    break;
  case MB_FC_WRITE_COIL:
    au8Buffer[ NB_HI ]      = ((au16regs[0] &gt; 0) ? 0xff : 0);
    au8Buffer[ NB_LO ]      = 0;
    u8BufferSize = 6;
    break;
  case MB_FC_WRITE_REGISTER:
    au8Buffer[ NB_HI ]      = highByte(au16regs[0]);
    au8Buffer[ NB_LO ]      = lowByte(au16regs[0]);
    u8BufferSize = 6;
    break;
  case MB_FC_WRITE_MULTIPLE_COILS:
    u8regsno = telegram.u16CoilsNo / 16;
    u8bytesno = u8regsno * 2;
    if ((telegram.u16CoilsNo % 16) != 0) {
      u8bytesno++;
      u8regsno++;
    }

    au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );
    au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );
    au8Buffer[ NB_LO + 1 ]    = u8bytesno;
    u8BufferSize = 7;

    u8regsno = u8bytesno = 0; // now auxiliary registers
    for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {


    }
    break;

  case MB_FC_WRITE_MULTIPLE_REGISTERS:
    au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );
    au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );
    au8Buffer[ NB_LO + 1 ]    = (uint8_t) ( telegram.u16CoilsNo * 2 );
    u8BufferSize = 7;

    for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {
      au8Buffer[ u8BufferSize ] = highByte( au16regs[ i ] );
      u8BufferSize++;
      au8Buffer[ u8BufferSize ] = lowByte( au16regs[ i ] );
      u8BufferSize++;
    }
    break;
  }

  sendTxBuffer();
  u8state = COM_WAITING;
  return 0;
}

int8_t Modbus::poll() {
  // check if there is any incoming frame
  uint8_t u8current = port-&gt;available();

  if (millis() &gt; u32timeOut) {
    u8state = COM_IDLE;
    u16errCnt++;
    return 0;
  }

  if (u8current == 0) return 0;

  // check T35 after frame end or still no frame end
  if (u8current != u8lastRec) {
    u8lastRec = u8current;
    u32time = millis() + T35;
    return 0;
  }
  if (millis() &lt; u32time) return 0;

  // transfer Serial buffer frame to auBuffer
  u8lastRec = 0;
  int8_t i8state = getRxBuffer();
  if (i8state &lt; 7) {
    u8state = COM_IDLE;
    u16errCnt++;
    return i8state;
  }

  // validate message: id, CRC, FCT, exception
  uint8_t u8exception = validateAnswer();
  if (u8exception != 0) {
    u8state = COM_IDLE;
    return u8exception;
  }

  // process answer
  switch ( au8Buffer[ FUNC ] ) {
  case MB_FC_READ_COILS:
  case MB_FC_READ_DISCRETE_INPUT:
    // call get_FC1 to transfer the incoming message to au16regs buffer
   // get_FC1( );
    break;
  case MB_FC_READ_INPUT_REGISTER:
  case MB_FC_READ_REGISTERS :
    // call get_FC3 to transfer the incoming message to au16regs buffer
    get_FC3( );
    break;
  case MB_FC_WRITE_COIL:
  case MB_FC_WRITE_REGISTER :
  case MB_FC_WRITE_MULTIPLE_COILS:
  case MB_FC_WRITE_MULTIPLE_REGISTERS :
    // nothing to do
    break;
  default:
    break;
  }
  u8state = COM_IDLE;
  return u8BufferSize;
}


int8_t Modbus::poll( uint16_t *regs, uint8_t u8size ) {

  au16regs = regs;
  u8regsize = u8size;

  // check if there is any incoming frame
  uint8_t u8current = port-&gt;available();
  if (u8current == 0) return 0;

  // check T35 after frame end or still no frame end
  if (u8current != u8lastRec) {
    u8lastRec = u8current;
    u32time = millis() + T35;
    return 0;
  }
  if (millis() &lt; u32time) return 0;

  u8lastRec = 0;
  int8_t i8state = getRxBuffer();
  if (i8state &lt; 7) return i8state;

  // check slave id
  if (au8Buffer[ ID ] != u8id) return 0;

  // validate message: CRC, FCT, address and size
  uint8_t u8exception = validateRequest();
  if (u8exception &gt; 0) {
    if (u8exception != NO_REPLY) {
      buildException( u8exception );
      sendTxBuffer();
    }
    return u8exception;
  }

  u32timeOut = millis() + long(u16timeOut);

  // process message
  switch ( au8Buffer[ FUNC ] ) {
  case MB_FC_READ_COILS:
  case MB_FC_READ_DISCRETE_INPUT:
    return process_FC1( regs, u8size );
    break;
  case MB_FC_READ_INPUT_REGISTER:
  case MB_FC_READ_REGISTERS :
    return process_FC3( regs, u8size );
    break;
  case MB_FC_WRITE_COIL:
    return process_FC5( regs, u8size );
    break;
  case MB_FC_WRITE_REGISTER :
    return process_FC6( regs, u8size );
    break;
  case MB_FC_WRITE_MULTIPLE_COILS:
    return process_FC15( regs, u8size );
    break;
  case MB_FC_WRITE_MULTIPLE_REGISTERS :
    return process_FC16( regs, u8size );
    break;
  default:
    break;
  }
}

void Modbus::init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {
  this-&gt;u8id = u8id;
  this-&gt;u8serno = (u8serno &gt; 3) ? 0 : u8serno;
  this-&gt;u8txenpin = u8txenpin;
  this-&gt;u16timeOut = 1000;// intially set for 1000
}


int8_t Modbus::getRxBuffer() {
  boolean bBuffOverflow = false;

  if (u8txenpin &gt; 1) digitalWrite( u8txenpin, LOW );

  u8BufferSize = 0;
  while ( port-&gt;available() ) {
    au8Buffer[ u8BufferSize ] = port-&gt;read();
    u8BufferSize ++;

    if (u8BufferSize &gt;= MAX_BUFFER) bBuffOverflow = true;
  }
  u16InCnt++;

  if (bBuffOverflow) {
    u16errCnt++;
    return ERR_BUFF_OVERFLOW;
  }
  u32timeOut=500;
   // u32timeOut = millis() + (unsigned long) u16timeOut;
  return u8BufferSize;
}


void Modbus::sendTxBuffer() {
  uint8_t i = 0;

  // append CRC to message
  uint16_t u16crc = calcCRC( u8BufferSize );
  au8Buffer[ u8BufferSize ] = u16crc &gt;&gt; 8;
  u8BufferSize++;
  au8Buffer[ u8BufferSize ] = u16crc &amp; 0x00ff;
  u8BufferSize++;

  // set RS485 transceiver to transmit mode
  if (u8txenpin &gt; 1) {
    switch ( u8serno ) {
#if defined(UBRR1H)
    case 1:
      UCSR1A = UCSR1A | (1 &lt;&lt; TXC1);
      break;
#endif

#if defined(UBRR2H)
    case 2:
      UCSR2A = UCSR2A | (1 &lt;&lt; TXC2);
      break;
#endif

#if defined(UBRR3H)
    case 3:
      UCSR3A = UCSR3A | (1 &lt;&lt; TXC3);
      break;
#endif
    case 0:
    default:
      UCSR0A = UCSR0A | (1 &lt;&lt; TXC0);
      break;
    }
    digitalWrite( u8txenpin, HIGH );
  }

  // transfer buffer to serial line
  port-&gt;write( au8Buffer, u8BufferSize );

  // keep RS485 transceiver in transmit mode as long as sending
  if (u8txenpin &gt; 1) {
    switch ( u8serno ) {
#if defined(UBRR1H)
    case 1:
      while (!(UCSR1A &amp; (1 &lt;&lt; TXC1)));
      break;
#endif

#if defined(UBRR2H)
    case 2:
      while (!(UCSR2A &amp; (1 &lt;&lt; TXC2)));
      break;
#endif

#if defined(UBRR3H)
    case 3:
      while (!(UCSR3A &amp; (1 &lt;&lt; TXC3)));
      break;
#endif
    case 0:
    default:
      while (!(UCSR0A &amp; (1 &lt;&lt; TXC0)));
      break;
    }

    // return RS485 transceiver to receive mode
    digitalWrite( u8txenpin, LOW );
  }
  port-&gt;flush();
  u8BufferSize = 0;

  // set time-out for master
//  u32timeOut = millis() + (unsigned long) u16timeOut;
 u32timeOut=500;
  // increase message counter
  u16OutCnt++;
}



uint16_t Modbus::calcCRC(uint8_t u8length) {
  unsigned int temp, temp2, flag;
  temp = 0xFFFF;
  for (unsigned char i = 0; i &lt; u8length; i++) {
    temp = temp ^ au8Buffer[i];
    for (unsigned char j = 1; j &lt;= 8; j++) {
      flag = temp &amp; 0x0001;
      temp &gt;&gt;= 1;
      if (flag)
        temp ^= 0xA001;
    }
  }
  // Reverse byte order.
  temp2 = temp &gt;&gt; 8;
  temp = (temp &lt;&lt; 8) | temp2;
  temp &amp;= 0xFFFF;
  // the returned value is already swapped
  // crcLo byte is first &amp; crcHi byte is last
  return temp;
}

uint8_t Modbus::validateRequest() {
  // check message crc vs calculated crc
  uint16_t u16MsgCRC =
    ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)
    | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes
  if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {
    u16errCnt ++;
    return NO_REPLY;
  }

  // check fct code
  boolean isSupported = false;
  for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {
    if (fctsupported[i] == au8Buffer[FUNC]) {
      isSupported = 1;
      break;
    }
  }
  if (!isSupported) {
    u16errCnt ++;
    return EXC_FUNC_CODE;
  }

  // check start address &amp; nb range
 // uint16_t u16regs = 4000;
 uint16_t u16regs = 0;
  uint8_t u8regs;
  switch ( au8Buffer[ FUNC ] ) {
  case MB_FC_READ_COILS:
  case MB_FC_READ_DISCRETE_INPUT:
  case MB_FC_WRITE_MULTIPLE_COILS:
    u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;
    u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]) / 16;
    u8regs = (uint8_t) u16regs;
    if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;
    break;
  case MB_FC_WRITE_COIL:
    u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;
    u8regs = (uint8_t) u16regs;
    if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;
    break;
  case MB_FC_WRITE_REGISTER :
    u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);
    u8regs = (uint8_t) u16regs;
    if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;
    break;
  case MB_FC_READ_REGISTERS :
  case MB_FC_READ_INPUT_REGISTER :
  case MB_FC_WRITE_MULTIPLE_REGISTERS :
    u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);
    u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]);
    u8regs = (uint8_t) u16regs;
    if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;
    break;
  }
  return 0; // OK, no exception code thrown
}


uint8_t Modbus::validateAnswer() {
  // check message crc vs calculated crc
  uint16_t u16MsgCRC =
    ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)
    | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes
  if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {
    u16errCnt ++;
    return NO_REPLY;
  }

  // check exception
  if ((au8Buffer[ FUNC ] &amp; 0x80) != 0) {
    u16errCnt ++;
    return ERR_EXCEPTION;
  }

  // check fct code
  boolean isSupported = false;
  for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {
    if (fctsupported[i] == au8Buffer[FUNC]) {
      isSupported = 1;
      break;
    }
  }
  if (!isSupported) {
    u16errCnt ++;
    return EXC_FUNC_CODE;
  }

  return 0; // OK, no exception code thrown
}


void Modbus::buildException( uint8_t u8exception ) {
  uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code

  au8Buffer[ ID ]      = u8id;
  au8Buffer[ FUNC ]    = u8func + 0x80;
  au8Buffer[ 2 ]       = u8exception;
  u8BufferSize         = EXCEPTION_SIZE;
}
</code></pre>

<p>The functionality Check</p>

<pre><code>void Modbus::get_FC3() {
  uint8_t u8byte, i;
  u8byte = 3;

  for (i = 0; i &lt; au8Buffer[ 2 ] / 2; i++) {
    au16regs[ i ] = word(
    au8Buffer[ u8byte ],
    au8Buffer[ u8byte + 1 ]);
    u8byte += 2;
  }
}


int8_t Modbus::process_FC1( uint16_t *regs, uint8_t u8size ) {
  uint8_t u8currentRegister, u8currentBit, u8bytesno, u8bitsno;
  uint8_t u8CopyBufferSize;
  uint16_t u16currentCoil, u16coil;

  // get the first and last coil from the message
  uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );
  uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );

  // put the number of bytes in the outcoming message
  u8bytesno = (uint8_t) (u16Coilno / 8);
  if (u16Coilno % 8 != 0) u8bytesno ++;
  au8Buffer[ ADD_HI ]  = u8bytesno;
  u8BufferSize         = ADD_LO;

  // read each coil from the register map and put its value inside the outcoming message
  u8bitsno = 0;

  for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {
    u16coil = u16StartCoil + u16currentCoil;
    u8currentRegister = (uint8_t) (u16coil / 16);
    u8currentBit = (uint8_t) (u16coil % 16);

    bitWrite(
    au8Buffer[ u8BufferSize ],
    u8bitsno,
    bitRead( regs[ u8currentRegister ], u8currentBit ) );
    u8bitsno ++;

    if (u8bitsno &gt; 7) {
      u8bitsno = 0;
      u8BufferSize++;
    }
  }

  // send outcoming message
  if (u16Coilno % 8 != 0) u8BufferSize ++;
  u8CopyBufferSize = u8BufferSize +2;
  sendTxBuffer();
  return u8CopyBufferSize;
}

int8_t Modbus::process_FC3( uint16_t *regs, uint8_t u8size ) {

  uint8_t u8StartAdd = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );
  uint8_t u8regsno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );
  uint8_t u8CopyBufferSize;
  uint8_t i;

  au8Buffer[ 2 ]       = u8regsno * 2;
  u8BufferSize         = 3;

  for (i = u8StartAdd; i &lt; u8StartAdd + u8regsno; i++) {
    au8Buffer[ u8BufferSize ] = highByte(regs[i]);
    u8BufferSize++;
    au8Buffer[ u8BufferSize ] = lowByte(regs[i]);
    u8BufferSize++;
  }
  u8CopyBufferSize = u8BufferSize +2;
  sendTxBuffer();

  return u8CopyBufferSize;
}


int8_t Modbus::process_FC5( uint16_t *regs, uint8_t u8size ) {
  uint8_t u8currentRegister, u8currentBit;
  uint8_t u8CopyBufferSize;
  uint16_t u16coil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );

  // point to the register and its bit
  u8currentRegister = (uint8_t) (u16coil / 16);
  u8currentBit = (uint8_t) (u16coil % 16);

  // write to coil
  bitWrite(
  regs[ u8currentRegister ],
  u8currentBit,
  au8Buffer[ NB_HI ] == 0xff );


  // send answer to master
  u8BufferSize = 6;
  u8CopyBufferSize = u8BufferSize +2;
  sendTxBuffer();

  return u8CopyBufferSize;

}


int8_t Modbus::process_FC6( uint16_t *regs, uint8_t u8size ) {

  uint8_t u8add = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );
  uint8_t u8CopyBufferSize;
  uint16_t u16val = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );

  regs[ u8add ] = u16val;

  // keep the same header
  u8BufferSize         = RESPONSE_SIZE;

  u8CopyBufferSize = u8BufferSize +2;
  sendTxBuffer();

  return u8CopyBufferSize;
}


int8_t Modbus::process_FC15( uint16_t *regs, uint8_t u8size ) {
  uint8_t u8currentRegister, u8currentBit, u8frameByte, u8bitsno;
  uint8_t u8CopyBufferSize;
  uint16_t u16currentCoil, u16coil;
  boolean bTemp;

  // get the first and last coil from the message
  uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );
  uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );


  // read each coil from the register map and put its value inside the outcoming message
  u8bitsno = 0;
  u8frameByte = 7;
  for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {

    u16coil = u16StartCoil + u16currentCoil;
    u8currentRegister = (uint8_t) (u16coil / 16);
    u8currentBit = (uint8_t) (u16coil % 16);

    bTemp = bitRead(
    au8Buffer[ u8frameByte ],
    u8bitsno );

    bitWrite(
    regs[ u8currentRegister ],
    u8currentBit,
    bTemp );

    u8bitsno ++;

    if (u8bitsno &gt; 7) {
      u8bitsno = 0;
      u8frameByte++;
    }
  }

  // send outcoming message
  // it's just a copy of the incomping frame until 6th byte
  u8BufferSize         = 6;
  u8CopyBufferSize = u8BufferSize +2;
  sendTxBuffer();
  return u8CopyBufferSize;
}


int8_t Modbus::process_FC16( uint16_t *regs, uint8_t u8size ) {
  uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code
  uint8_t u8StartAdd = au8Buffer[ ADD_HI ] &lt;&lt; 8 | au8Buffer[ ADD_LO ];
  uint8_t u8regsno = au8Buffer[ NB_HI ] &lt;&lt; 8 | au8Buffer[ NB_LO ];
  uint8_t u8CopyBufferSize;
  uint8_t i;
  uint16_t temp;

  // build header
  au8Buffer[ NB_HI ]   = 0;
  au8Buffer[ NB_LO ]   = u8regsno;
  u8BufferSize         = RESPONSE_SIZE;

  // write registers
  for (i = 0; i &lt; u8regsno; i++) {
    temp = word(
    au8Buffer[ (BYTE_CNT + 1) + i * 2 ],
    au8Buffer[ (BYTE_CNT + 2) + i * 2 ]);

    regs[ u8StartAdd + i ] = temp;
  }
  u8CopyBufferSize = u8BufferSize +2;
  sendTxBuffer();

  return u8CopyBufferSize;
}
</code></pre>
"
"<p>I am creating game controller using Gyroscope these data will be transmitted from slave Arduino to master Arduino using <a href=""http://www.seeedstudio.com/wiki/315MHz_Simple_RF_Link_Kit"" rel=""nofollow"">RF315</a>
 then these data will be transmitted to android phone via Bluetooth.
everything is working as expected, but the problem is that the communication is too slow so i receive only about 1 packet in second.</p>

<p>Master Code:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
#include &lt;SPI.h&gt;
#include &lt;Wire.h&gt;
#include &lt;VirtualWire.h&gt;
#define MPU 0x68

int buttonPin=2;
char bluetoothData[30];
double AcX,AcY,AcZ;
int Pitch, Roll,Zed;
int previousValue=0;

SoftwareSerial Genotronex(10,11);
void setup() {
  Serial.begin(9600);
  Genotronex.begin(9600);
  init_MPU();
  vw_set_ptt_inverted(true);
  vw_set_rx_pin(12);
  vw_setup(4000);
  vw_rx_start();
  pinMode(buttonPin, INPUT);
}
void init_MPU(){
  Wire.begin();
  Wire.beginTransmission(MPU);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
  delay(1000);
}
double FunctionsPitchRoll(double A, double B, double C){
  double DatoA, DatoB, Value;
  DatoA = A;
  DatoB = (B*B) + (C*C);
  DatoB = sqrt(DatoB);

  Value = atan2(DatoA, DatoB);
  Value = Value * 180/3.14;

  return (int)Value;
}
void FunctionsMPU(){
  Wire.beginTransmission(MPU);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU,6,true);
  AcX=Wire.read()&lt;&lt;8|Wire.read();   
  AcY=Wire.read()&lt;&lt;8|Wire.read();
  AcZ=Wire.read()&lt;&lt;8|Wire.read();
}
void loop() {
  int val = digitalRead(buttonPin);
  uint8_t buf[VW_MAX_MESSAGE_LEN];
  uint8_t buflen = VW_MAX_MESSAGE_LEN;
  if (vw_get_message(buf, &amp;buflen)){
      FunctionsMPU();
      Pitch = FunctionsPitchRoll(AcY, AcX, AcZ);
        String data="""";//(char*)buf;
        data+=millis();
        data+=""-RP:"";
        data+=Pitch;
        data+=""#"";
        Serial.println(data);
        data.toCharArray(bluetoothData,30);
        Genotronex.write(bluetoothData);
    }
 delay(50);
}
</code></pre>

<p>Slave Code:</p>

<pre><code>#include &lt;SPI.h&gt;
#include &lt;Wire.h&gt;
#include &lt;VirtualWire.h&gt;
#define MPU 0x68

double AcX,AcY,AcZ;
int Pitch, Roll,Zed;
String data;
char packet[20];

void setup(){
  init_MPU();
  vw_set_ptt_inverted(true);
  vw_set_tx_pin(12);
  vw_setup(4000);
}

void loop(){
  FunctionsMPU();
  Pitch = FunctionsPitchRoll(AcY, AcX, AcZ);
 // Serial.print(""Pitch: "");
 // Serial.println(Pitch);

  data=""LP:"";
  data+=Pitch;
  data.toCharArray(packet,30);
  vw_send((uint8_t *)packet,data.length()+1);
  vw_wait_tx();
  delay(50);
}

void init_MPU(){
  Wire.begin();
  Wire.beginTransmission(MPU);
  Wire.write(0x6B);
  Wire.write(0);
  Wire.endTransmission(true);
  delay(1000);
}

double FunctionsPitchRoll(double A, double B, double C){
  double DatoA, DatoB, Value;
  DatoA = A;
  DatoB = (B*B) + (C*C);
  DatoB = sqrt(DatoB);
  Value = atan2(DatoA, DatoB);
  Value = Value * 180/3.14;
  return (int)Value;
}

void FunctionsMPU(){
  Wire.beginTransmission(MPU);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU,6,true);
  AcX=Wire.read()&lt;&lt;8|Wire.read();   
  AcY=Wire.read()&lt;&lt;8|Wire.read();
  AcZ=Wire.read()&lt;&lt;8|Wire.read();
}
</code></pre>
"
"<p>""Why was the Due retired?"" - It is quite interesting that Arduino.CC never explained that. One would think, that a professional company or organisation places a notice in advance with at least a short explanation as to why.</p>

<p>Most of the Arduinos, that have been available on both projects (CC and ORG) have suddenly and without further notice or explanation been retired on CC (the exceptions being Uno and Mega 2560, the cash-cows), but are still alive on ORG.
It would seem, that either the ""divorce"" is proceeding or that the copyright case at the US court is not going as smoothly as Banzi hoped. Well, he could repeatedly ""bend the truth"" by claiming Arduino being completely his idea and design in front of the press (that never bothered to check the obvious facts), but laying such a claim at court is borderline criminal. (see also: arduinohistory.github.io and make your own opinion)
CC has still the biggest chunk of the overall community and also serves as the central nexus for developers. But it seems there is a lot of movement... some people move to Wiring (from which the Arduino IDE was forked), others to 3rd Party sites and yet others try out different  and newly emerging products (eg. Adafruits MCUs and Pi or the Renesas GR series).
ORG on the other hand seems to become the bigger (Arduino branded) hardware supplier and developer. CC has apparently out-sourced this to Intel and tries to live of royalties and ""certification"" fees (which is the central point where Banzi and Martino started to heavily and openly disagree).</p>

<p>""Why was the Due retired?"" - Unless CC doesn't give an explanation, there is no real answer. A lack of interest is certainly not the reason.</p>
"
"<p>I'm fairly new to arduino programming and C/C++. I would like to read a .csv file element wise, and send each element via. a nRF24L01 tranceiver to a raspberry pi. Right now I'm able to read the .csv file with <code>Serial.write(&lt;file&gt;.read())</code>. I was wondering if there's a way to read each element one at a time, if so how would i do that?</p>

<p>My thoughts (Pseudo code-ish):</p>

<pre><code>loop through every element in .csv file {
    save the current element to X.
    send X to raspberry pi (I already have a function for sending)
}
</code></pre>

<p>I hope someone can help. Thanks in advance.</p>
"
"

<p><a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">sscanf</a> should be enough. There is also other options, String class for example with substring method.</p>

<p>Take a look at the example: </p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;

char myString[] = ""#YPR=72.13,1.74,-16.38"";

void setup() {
  // put your setup code here, to run once:
  float yaw = 0;
  float pitch = 0;
  float roll = 0;

  sscanf(myString, ""#YPR=%f,%f,%f"", &amp;yaw, &amp;pitch, &amp;roll);
  Serial.println(yaw);
  Serial.println(pitch);
  Serial.println(roll);
}

void loop() {


}
</code></pre>
"
"<p>I am building a IR-based laser tag system. The basics are working fine. One feature, that I want to have, is different weapon modes with different ranges.</p>

<p>How can I change the range of an IR transmitter with as little hardware as possible, or at best, completely in software?</p>
"
"<p>The <code>read()</code> method works character-wise, not element-wise. Then you
have to rethink your algorithm to loop over characters:</p>

<ul>
<li>store each character in a buffer</li>
<li>send the whole buffer (i.e. a single element) when you see a delimiter</li>
</ul>

<p>Example:</p>

<pre><code>const size_t BUFFER_SZ = ...;
char buffer[BUFFER_SZ];
size_t pos = 0;    // current write position in buffer
int c;

// While we can read a character:
while ((c = &lt;file&gt;.read()) != -1) {

    // If we get a delimiter, then we have a complete element.
    if (c == ',' || c == '\n') {
        buffer[pos] = '\0';         // terminate the string
        raspberry.println(buffer);  // send to the RPi
        pos = 0;                    // ready for next element
    }

    // Otherwise, store the character in the buffer.
    else if (pos &lt; BUFFER_SZ-1) {
        buffer[pos++] = c;
    }
}
</code></pre>

<p>Here the buffer is sent as a string. If you want to parse it into a
number, you can use <code>sscanf</code>.</p>

<p>This code assumes Unix text-file conventions, i.e. each line of the file
(including the last one) being terminated by an LF character. You may
have to adapt if your file is different.</p>
"
"<p>How to connect Arduino MKR1000(with WiFi and act as a client) to a server using a web sockets. </p>

<p>I try this example but it always gives an error that WebSocketClient does not has a connect and setDataArrivedDelegate function.</p>

<pre><code> #include ""Arduino.h""
 #include &lt;Ethernet.h&gt;
 #include &lt;SPI.h&gt;
 #include &lt;WebSocketClient.h&gt;

 char server[] = ""echo.websocket.org"";
 WebSocketClient client;

 void setup() {
 Serial.begin(9600);
 Ethernet.begin(mac);
 client.connect(server);
 client.setDataArrivedDelegate(dataArrived);
 client.send(""Hello World!"");
} 

   void loop() {
    client.monitor();
}

 void dataArrived(WebSocketClient client, String data) {
  Serial.println(""Data Arrived: "" + data);
</code></pre>

<p>}</p>
"
"<p>So I think I have tried everything in order to upload code from ubuntu from a non-root account. </p>

<p>The root account uploads problems fine:</p>

<pre><code>avrdude: ser_open(): can't open device ""/dev/ttyACM0"": Permission denied
avrdude: ser_send(): write error: Bad file descriptor
</code></pre>

<p>I have already tried adding my user to the dialout group</p>

<pre><code>sudo usermod -a -G dialout myuser
</code></pre>

<p>I have followed a bunch of guides telling me to add extra things to my udev rules, none of which have worked. </p>

<p>I <em>can</em> upload with the sudo user. Since I use the command line uploader predominantly I can use an alias to get around this, means typing in my sudo password all the time though. But I really want the problem solved because it's bugging me. Any ideas of what I can try?</p>
"
"<p>To make a completely ""non blocking"" system you need to change your thinking somewhat. Instead of thinking ""A need to fade from X to Y"" you instead need to start thinking ""I am at brightness X at the moment. I want to get to brightness Y. What do I need to do to get there?"".</p>

<p>For instance, you might have a <code>loop()</code> than contains a structure like:</p>

<ul>
<li>My target brightness is Y</li>
<li>My current brightness is X</li>
<li>Is X equal to Y?

<ul>
<li>Yes:

<ul>
<li>Select a different target brightness to get to</li>
</ul></li>
<li>No:

<ul>
<li>If my current brightness is below my target brightness then make it brighter.</li>
<li>Otherwise make it dimmer.</li>
</ul></li>
</ul></li>
</ul>

<p>You can introduce a small delay to slow the fading down, or use <code>millis()</code> to only run that structure at pre-defined intervals (like BlinkWithoutDelay does) to get your desired fade speed.</p>
"
"<p><a href=""https://www.adafruit.com/products/1568?gclid=CLOo8qn-ms0CFZM6gQodhnYIPg"" rel=""nofollow"">This</a> Sharp distance sensor is specified to detect objects that reflect IR light from 100cm-500cm. </p>

<blockquote>
  <p>How can I change the range of an IR transmitter with as little
  hardware as possible, or at best, completely in software?</p>
</blockquote>

<p>I believe the sensors produce an analog output that can feed into an Arduino's ADC.  So software (by it's self) can be used to adjust the threshold distance.</p>

<p>Similar devices I have used have a narrow sensing field.  They only reported the distance to objects directly in front of them.  Also, I found they were effected by defective (burning out?) florescent light sources.  We assumed failing florescent light sources produced IR radiation similar in frequency as used by the sensor's IR emitter.  Also, the analog output is slightly stair stepped in the unit we tested.  I say this in case you were expecting to use increase relative accuracy of several readings if not precision of any given reading.</p>
"
"<p>my code (not exately mine but a heavily modifed version of an existing code)</p>

<pre><code>#include &lt;EEPROM.h&gt;     
#include &lt;SPI.h&gt;        // RC522 Module uses SPI protocol
#include &lt;MFRC522.h&gt;    // Library for Mifare RC522 Devices


 #include &lt;Servo.h&gt;
 Servo daServo;

 #define button1 5
 #define button2 6


#define COMMON_ANODE

#ifdef COMMON_ANODE
#define LED_ON LOW
#define LED_OFF HIGH
#else
#define LED_ON HIGH
#define LED_OFF LOW
#endif

#define redLed 4    // Set Led Pins
#define greenLed 2
#define blueLed 3

#define relay 8         // Set Relay Pin
#define wipeB 7 // Button pin for WipeMode

boolean match = false;          // initialize card match to false
boolean programMode = false;    // initialize programming mode to false

int successRead;        // Variable integer to keep if we have Successful Read from Reader

byte storedCard[4];     // Stores an ID read from EEPROM
byte readCard[4];       // Stores scanned ID read from RFID Module
byte masterCard[4];     // Stores master card's ID read from EEPROM

/*
    We need to define MFRC522's pins and create instance
    Pin layout should be as follows (on Arduino Uno):
    MOSI: Pin 11 / ICSP-4
    MISO: Pin 12 / ICSP-1
    SCK : Pin 13 / ICSP-3
    SS : Pin 10 (Configurable)
    RST : Pin 9 (Configurable)
    look MFRC522 Library for
    other Arduinos' pin configuration 
 */

#define SS_PIN 10
#define RST_PIN 9
MFRC522 mfrc522(SS_PIN, RST_PIN);   // Create MFRC522 instance.

///////////////////////////////////////// Setup ///////////////////////////////////
void setup() { 
  daServo.attach(relay);

  pinMode(redLed, OUTPUT);
  pinMode(greenLed, OUTPUT);
  pinMode(blueLed, OUTPUT);
  pinMode(wipeB, INPUT_PULLUP);     
  pinMode(relay, OUTPUT);
  pinMode(button1, INPUT);
  pinMode(button2, OUTPUT);

  daServo.write(50);        // Make sure door is locked
  digitalWrite(redLed, HIGH);   // Make sure led is off
  digitalWrite(greenLed, LOW);  // Make sure led is off
  digitalWrite(blueLed, LOW);   // Make sure led is off

  //Protocol Configuration
  Serial.begin(9600);    // Initialize serial communications with PC
  SPI.begin();           // MFRC522 Hardware uses SPI protocol
  mfrc522.PCD_Init();    // Initialize MFRC522 Hardware

  //If you set Antenna Gain to Max it will increase reading distance
  //mfrc522.PCD_SetAntennaGain(mfrc522.RxGain_max);

  Serial.println(F(""Access Control v3.3""));   // For debugging purposes
  ShowReaderDetails();  // Show details of PCD - MFRC522 Card Reader details

  //Wipe Code if Button Pressed while setup run (powered on) it wipes EEPROM
  if (digitalRead(wipeB) == LOW) {  // when button pressed pin should get low, button connected to ground
    digitalWrite(redLed, HIGH); // Red Led stays on to inform user we are going to wipe
    Serial.println(F(""Wipe Button Pressed""));
    Serial.println(F(""You have 5 seconds to Cancel""));
    Serial.println(F(""This will be remove all records and cannot be undone""));
    delay(5000);                        // Give user enough time to cancel operation
    if (digitalRead(wipeB) == LOW) {    // If button still be pressed, wipe EEPROM
      Serial.println(F(""Starting Wiping EEPROM""));
      for (int x = 0; x &lt; EEPROM.length(); x = x + 1) {    //Loop end of EEPROM address
        if (EEPROM.read(x) == 0) {              //If EEPROM address 0
          // do nothing, already clear, go to the next address in order to save time and reduce writes to EEPROM
        }
        else {
          EEPROM.write(x, 0);           // if not write 0 to clear, it takes 3.3mS
        }
      }
      Serial.println(F(""EEPROM Successfully Wiped""));
      digitalWrite(redLed, LED_OFF);    // visualize successful wipe
      delay(200);
      digitalWrite(redLed, LED_ON);
      delay(200);
      digitalWrite(redLed, LED_OFF);
      delay(200);
      digitalWrite(redLed, LED_ON);
      delay(200);
      digitalWrite(redLed, LED_OFF);
    }
    else {
      Serial.println(F(""Wiping Cancelled""));
      digitalWrite(redLed, LED_OFF);
    }
  }
  // Check if master card defined, if not let user choose a master card
  // This also useful to just redefine Master Card
  // You can keep other EEPROM records just write other than 143 to EEPROM address 1
  // EEPROM address 1 should hold magical number which is '143'
  if (EEPROM.read(1) != 143) {          
    Serial.println(F(""No Master Card Defined""));
    Serial.println(F(""Scan A PICC to Define as Master Card""));
    do {
      successRead = getID();            // sets successRead to 1 when we get read from reader otherwise 0
      digitalWrite(blueLed, HIGH);    // Visualize Master Card need to be defined
      delay(1000);
      digitalWrite(blueLed, LOW);
      delay(200);
    }
    while (!successRead);                  // Program will not go further while you not get a successful read
    for ( int j = 0; j &lt; 4; j++ ) {        // Loop 4 times
      EEPROM.write( 2 + j, readCard[j] );  // Write scanned PICC's UID to EEPROM, start from address 3
    }
    EEPROM.write(1, 143);                  // Write to EEPROM we defined Master Card.
    Serial.println(F(""Master Card Defined""));
  }
  Serial.println(F(""-------------------""));
  Serial.println(F(""Master Card's UID""));
  for ( int i = 0; i &lt; 4; i++ ) {          // Read Master Card's UID from EEPROM
    masterCard[i] = EEPROM.read(2 + i);    // Write it to masterCard
    Serial.print(masterCard[i], HEX);
  }
  Serial.println("""");
  Serial.println(F(""-------------------""));
  Serial.println(F(""Everything Ready""));
  Serial.println(F(""Waiting PICCs to be scanned""));
  cycleLeds();    // Everything ready lets give user some feedback by cycling leds
}


///////////////////////////////////////// Main Loop ///////////////////////////////////
void loop () {
  int buttonstate = digitalRead(button1);
  if (buttonstate == HIGH) {
   digitalWrite(greenLed,HIGH);
   digitalWrite(redLed,HIGH);
   digitalWrite(blueLed,HIGH);
  }
  else {
    daServo.write(0);
     digitalWrite(greenLed,LOW);
   digitalWrite(redLed,LOW);
   digitalWrite(blueLed,LOW);

  }

  do {
    successRead = getID();  // sets successRead to 1 when we get read from reader otherwise 0
    if (programMode) {
      cycleLeds();              // Program Mode cycles through RGB waiting to read a new card
    }
    else {
      normalModeOn();       // Normal mode, blue Power LED is on, all others are off
    }
  }
  while (!successRead);     //the program will not go further while you not get a successful read
  if (programMode) {
    if ( isMaster(readCard) ) { //If master card scanned again exit program mode
      Serial.println(F(""Master Card Scanned""));
      Serial.println(F(""Exiting Program Mode""));
      Serial.println(F(""-----------------------------""));
      programMode = false;
      return;
    }
    else {
      if ( findID(readCard) ) { // If scanned card is known delete it
        Serial.println(F(""I know this PICC, removing...""));
        deleteID(readCard);
        Serial.println(""-----------------------------"");
      }
      else {                    // If scanned card is not known add it
        Serial.println(F(""I do not know this PICC, adding...""));
        writeID(readCard);
        Serial.println(F(""-----------------------------""));
      }
    }
  }
  else {
    if ( isMaster(readCard) ) {     // If scanned card's ID matches Master Card's ID enter program mode
      programMode = true;
      Serial.println(F(""Hello Master - Entered Program Mode""));
      int count = EEPROM.read(0);   // Read the first Byte of EEPROM that
      Serial.print(F(""I have ""));       // stores the number of ID's in EEPROM
      Serial.print(count);
      Serial.print(F("" record(s) on EEPROM""));
      Serial.println("""");
      Serial.println(F(""Scan a PICC to ADD or REMOVE""));
      Serial.println(F(""-----------------------------""));
    }
    else {

      if ( findID(readCard) ) { // If not, see if the card is in the EEPROM
        Serial.println(F(""Welcome home sir""));
        granted(300);           // Open the door lock for 300 ms
      }
      else {            // If not, show that the ID was not valid
        Serial.println(F(""Im sorry you are not allowed""));
        denied();
      }
    }
  }

}

/////////////////////////////////////////  Access Granted    ///////////////////////////////////
void granted (int setDelay) {
  digitalWrite(blueLed, LOW);   // Turn off blue LED
  digitalWrite(redLed, LOW);    // Turn off red LED
  digitalWrite(greenLed, HIGH);     // Turn on green LED
  daServo.write(180);       // Unlock door!
  delay(5000);                  // Hold door lock open for given seconds




}

///////////////////////////////////////// Access Denied  ///////////////////////////////////
void denied() {
  digitalWrite(greenLed, LOW);  // Make sure green LED is off
  digitalWrite(blueLed, LOW);   // Make sure blue LED is off
  digitalWrite(redLed, HIGH);
  daServo.write(0);
  delay(1000);
  daServo.write(0);
}


///////////////////////////////////////// Get PICC's UID ///////////////////////////////////
int getID() {
  // Getting ready for Reading PICCs
  if ( ! mfrc522.PICC_IsNewCardPresent()) { //If a new PICC placed to RFID reader continue
    return 0;
  }
  if ( ! mfrc522.PICC_ReadCardSerial()) {   //Since a PICC placed get Serial and continue
    return 0;
  }
  // There are Mifare PICCs which have 4 byte or 7 byte UID care if you use 7 byte PICC
  // I think we should assume every PICC as they have 4 byte UID
  // Until we support 7 byte PICCs
  Serial.println(F(""Scanned PICC's UID:""));
  for (int i = 0; i &lt; 4; i++) {  //
    readCard[i] = mfrc522.uid.uidByte[i];
    Serial.print(readCard[i], HEX);
  }
  Serial.println("""");
  mfrc522.PICC_HaltA(); // Stop reading
  return 1;
}

void ShowReaderDetails() {
    // Get the MFRC522 software version
    byte v = mfrc522.PCD_ReadRegister(mfrc522.VersionReg);
    Serial.print(F(""MFRC522 Software Version: 0x""));
    Serial.print(v, HEX);
    if (v == 0x91)
        Serial.print(F("" = v1.0""));
    else if (v == 0x92)
        Serial.print(F("" = v2.0""));
    else
        Serial.print(F("" (unknown)""));
    Serial.println("""");
    // When 0x00 or 0xFF is returned, communication probably failed
    if ((v == 0x00) || (v == 0xFF)) {
        Serial.println(F(""WARNING: Communication failure, is the MFRC522 properly connected?""));
        while(true);  // do not go further
    }
}

///////////////////////////////////////// Cycle Leds (Program Mode) ///////////////////////////////////
void cycleLeds() {
  digitalWrite(redLed, LOW);    // Make sure red LED is off
  digitalWrite(greenLed, HIGH);     // Make sure green LED is on
  digitalWrite(blueLed, LOW);   // Make sure blue LED is off
  delay(200);
  digitalWrite(redLed, LOW);    // Make sure red LED is off
  digitalWrite(greenLed, LOW);  // Make sure green LED is off
  digitalWrite(blueLed, HIGH);  // Make sure blue LED is on
  delay(200);
  digitalWrite(redLed, HIGH);   // Make sure red LED is on
  digitalWrite(greenLed, LOW);  // Make sure green LED is off
  digitalWrite(blueLed, LOW);   // Make sure blue LED is off
  delay(200);
}

//////////////////////////////////////// Normal Mode Led  ///////////////////////////////////
void normalModeOn () {
  digitalWrite(blueLed, HIGH);  // Blue LED ON and ready to read card
  digitalWrite(redLed, HIGH);   // Make sure Red LED is off
  digitalWrite(greenLed, LOW);  // Make sure Green LED is off
  digitalWrite(relay, LOW);         // Make sure Door is Locked

}

//////////////////////////////////////// Read an ID from EEPROM //////////////////////////////
void readID( int number ) {
  int start = (number * 4 ) + 2;        // Figure out starting position
  for ( int i = 0; i &lt; 4; i++ ) {       // Loop 4 times to get the 4 Bytes
    storedCard[i] = EEPROM.read(start + i);     // Assign values read from EEPROM to array
  }
}

///////////////////////////////////////// Add ID to EEPROM   ///////////////////////////////////
void writeID( byte a[] ) {
  if ( !findID( a ) ) {         // Before we write to the EEPROM, check to see if we have seen this card before!
    int num = EEPROM.read(0);       // Get the numer of used spaces, position 0 stores the number of ID cards
    int start = ( num * 4 ) + 6;    // Figure out where the next slot starts
    num++;                              // Increment the counter by one
    EEPROM.write( 0, num );         // Write the new count to the counter
    for ( int j = 0; j &lt; 4; j++ ) {     // Loop 4 times
      EEPROM.write( start + j, a[j] );  // Write the array values to EEPROM in the right position
    }
    successWrite();
    Serial.println(F(""Succesfully added ID record to EEPROM""));
  }
  else {
    failedWrite();
    Serial.println(F(""Failed! There is something wrong with ID or bad EEPROM""));
  }
}

///////////////////////////////////////// Remove ID from EEPROM   ///////////////////////////////////
void deleteID( byte a[] ) {
  if ( !findID( a ) ) {         // Before we delete from the EEPROM, check to see if we have this card!
    failedWrite();          // If not
    Serial.println(F(""Failed! There is something wrong with ID or bad EEPROM""));
  }
  else {
    int num = EEPROM.read(0);   // Get the numer of used spaces, position 0 stores the number of ID cards
    int slot;           // Figure out the slot number of the card
    int start;          // = ( num * 4 ) + 6; // Figure out where the next slot starts
    int looping;        // The number of times the loop repeats
    int j;
    int count = EEPROM.read(0); // Read the first Byte of EEPROM that stores number of cards
    slot = findIDSLOT( a );     // Figure out the slot number of the card to delete
    start = (slot * 4) + 2;
    looping = ((num - slot) * 4);
    num--;          // Decrement the counter by one
    EEPROM.write( 0, num );     // Write the new count to the counter
    for ( j = 0; j &lt; looping; j++ ) {               // Loop the card shift times
      EEPROM.write( start + j, EEPROM.read(start + 4 + j));     // Shift the array values to 4 places earlier in the EEPROM
    }
    for ( int k = 0; k &lt; 4; k++ ) {                 // Shifting loop
      EEPROM.write( start + j + k, 0);
    }
    successDelete();
    Serial.println(F(""Succesfully removed ID record from EEPROM""));
  }
}

///////////////////////////////////////// Check Bytes   ///////////////////////////////////
boolean checkTwo ( byte a[], byte b[] ) {
  if ( a[0] != NULL )           // Make sure there is something in the array first
    match = true;           // Assume they match at first
  for ( int k = 0; k &lt; 4; k++ ) {   // Loop 4 times
    if ( a[k] != b[k] )         // IF a != b then set match = false, one fails, all fail
      match = false;
  }
  if ( match ) {            // Check to see if if match is still true
    return true;            // Return true
  }
  else  {
    return false;           // Return false
  }
}

///////////////////////////////////////// Find Slot   ///////////////////////////////////
int findIDSLOT( byte find[] ) {
  int count = EEPROM.read(0);           // Read the first Byte of EEPROM that
  for ( int i = 1; i &lt;= count; i++ ) {      // Loop once for each EEPROM entry
    readID(i);                              // Read an ID from EEPROM, it is stored in storedCard[4]
    if ( checkTwo( find, storedCard ) ) {   // Check to see if the storedCard read from EEPROM
      // is the same as the find[] ID card passed
      return i;                 // The slot number of the card
      break;                    // Stop looking we found it
    }
  }
}

///////////////////////////////////////// Find ID From EEPROM   ///////////////////////////////////
boolean findID( byte find[] ) {
  int count = EEPROM.read(0);           // Read the first Byte of EEPROM that
  for ( int i = 1; i &lt;= count; i++ ) {      // Loop once for each EEPROM entry
    readID(i);                  // Read an ID from EEPROM, it is stored in storedCard[4]
    if ( checkTwo( find, storedCard ) ) {   // Check to see if the storedCard read from EEPROM
      return true;
      break;    // Stop looking we found it
    }
    else {      // If not, return false
    }
  }
  return false;
}

///////////////////////////////////////// Write Success to EEPROM   ///////////////////////////////////
// Flashes the green LED 3 times to indicate a successful write to EEPROM
void successWrite() {
  digitalWrite(blueLed, LED_OFF);   // Make sure blue LED is off
  digitalWrite(redLed, LED_OFF);    // Make sure red LED is off
  digitalWrite(greenLed, LED_OFF);  // Make sure green LED is on
  delay(200);
  digitalWrite(greenLed, LED_ON);   // Make sure green LED is on
  delay(200);
  digitalWrite(greenLed, LED_OFF);  // Make sure green LED is off
  delay(200);
  digitalWrite(greenLed, LED_ON);   // Make sure green LED is on
  delay(200);
  digitalWrite(greenLed, LED_OFF);  // Make sure green LED is off
  delay(200);
  digitalWrite(greenLed, LED_ON);   // Make sure green LED is on
  delay(200);
}

///////////////////////////////////////// Write Failed to EEPROM   ///////////////////////////////////
// Flashes the red LED 3 times to indicate a failed write to EEPROM
void failedWrite() {
  digitalWrite(blueLed, LED_OFF);   // Make sure blue LED is off
  digitalWrite(redLed, LED_OFF);    // Make sure red LED is off
  digitalWrite(greenLed, LED_OFF);  // Make sure green LED is off
  delay(200);
  digitalWrite(redLed, LED_ON);     // Make sure red LED is on
  delay(200);
  digitalWrite(redLed, LED_OFF);    // Make sure red LED is off
  delay(200);
  digitalWrite(redLed, LED_ON);     // Make sure red LED is on
  delay(200);
  digitalWrite(redLed, LED_OFF);    // Make sure red LED is off
  delay(200);
  digitalWrite(redLed, LED_ON);     // Make sure red LED is on
  delay(200);
}

///////////////////////////////////////// Success Remove UID From EEPROM  ///////////////////////////////////
// Flashes the blue LED 3 times to indicate a success delete to EEPROM
void successDelete() {
  digitalWrite(blueLed, LED_OFF);   // Make sure blue LED is off
  digitalWrite(redLed, LED_OFF);    // Make sure red LED is off
  digitalWrite(greenLed, LED_OFF);  // Make sure green LED is off
  delay(200);
  digitalWrite(blueLed, LED_ON);    // Make sure blue LED is on
  delay(200);
  digitalWrite(blueLed, LED_OFF);   // Make sure blue LED is off
  delay(200);
  digitalWrite(blueLed, LED_ON);    // Make sure blue LED is on
  delay(200);
  digitalWrite(blueLed, LED_OFF);   // Make sure blue LED is off
  delay(200);
  digitalWrite(blueLed, LED_ON);    // Make sure blue LED is on
  delay(200);
}

////////////////////// Check readCard IF is masterCard   ///////////////////////////////////
// Check to see if the ID passed is the master programing card
boolean isMaster( byte test[] ) {
  if ( checkTwo( test, masterCard ) )
    return true;
  else
    return false;
}
/////////////////////Servo Method///////////////////////////////////////
</code></pre>
"
"<p>I am intended to use Gas Sensors (MQ series) on protoboard so I connect it to Arduino and perform analogue read. 
I would like to request if possible to get the interfacing circuit (resistors, amplification.. etc.) or if there are schematics available. </p>

<p>Also, when I read the data digitized into 10bits ADC value, how can I convert it into units (ppm)?</p>

<p>Thank you so much in advance.</p>
"
"<p>You can connect the directly to the Arduino +5, Gnd and Signal.</p>

<p>I don't know of any calibration data for the sensors that I have.  I suppose you could take the maximum concentration the sensor can measure and divide this by 1024, but I don't know if the value returned is linear or logarithmic.<br>
The data sheet does have some info on, but this page may be more helpful
<a href=""http://forum.arduino.cc/index.php?topic=230945.0"" rel=""nofollow"">http://forum.arduino.cc/index.php?topic=230945.0</a></p>

<p>Oh and don't forget the warm up time on the sensors!</p>
"
"<p>I am a newbie..  I am integrating Arduino controller with Matlab</p>

<p>I have connected my arduino DUE board in COM7. And I have also connected a DC Motor in one of the digital output pins (D3)</p>

<p>So when I just execute the matlab built in arduino function to initialise or establish a connection my motor runs for a second and then stops. I dont want my motor to run initially. Is there a solution or an alternative to do this.</p>

<pre><code>a = arduino('COM7', 'Due');
</code></pre>

<p>Thanks in advance.</p>
"
"<p>I have an RFID module that works with tessel based on RFID-pn532 shield from adafruit I was wondering if i could use it with my arduino uno.. here is the link for the RFID module <a href=""http://start.tessel.io/modules/rfid"" rel=""nofollow"">http://start.tessel.io/modules/rfid</a> and this is what it looks like <a href=""http://www.seeedstudio.com/depot/images/product/113990044%201_04.jpg"" rel=""nofollow"">http://www.seeedstudio.com/depot/images/product/113990044%201_04.jpg</a>, please let me know if its possible to use it and also provide me with any useful material regarding this :) </p>

<p>Thank you</p>
"
"<p>I am trying to use <code>vl6180x</code> distance sensor and Arduino UNO board for individual sensor doing individual distance sensing. This sensor follows the i2c protocol. Since for the same type of sensor, <code>i2c</code> protocol says that they would all have the same address. I am thinking about using the <code>chip enable</code> pin(<code>GPIO00</code>) on the sensor chip to toggle sensor when do the distance measuring. </p>

<p>I am able to update the address of the sensor group now. But I think to obtain individual results from different sensors on <code>serial monitor</code> of Arduino. Right now I can only do one time setup sensor thing (like I couldn't update and toggle around different sensors). Once I started to do that, the results from serial monitor were just wrong. Any advice that I can continue toggle around the sensor and make them work from utilize the GPIO00 pin?</p>

<p>Code using is:</p>

<pre><code>#include &lt;Wire.h&gt;
#include &lt;VL6180X.h&gt;
#define Address1 0x20
#define Address2 0x22
#define Address3 0x24

VL6180X sensor;

int pin2 = 2;
int pin3 = 3;
int pin4 = 4;


void setup()
{
  Serial.begin(9600);
  Wire.begin();
  pinMode(pin2,OUTPUT);
  pinMode(pin3,OUTPUT);
  pinMode(pin4,OUTPUT);

  digitalWrite(pin2,HIGH);
  digitalWrite(pin3,HIGH);
  digitalWrite(pin4,HIGH);

  sensor.init();
  sensor.configureDefault();
  sensor.writeReg(VL6180X::SYSRANGE__MAX_CONVERGENCE_TIME, 30);
  sensor.writeReg16Bit(VL6180X::SYSALS__INTEGRATION_PERIOD, 50);
  sensor.writeReg16Bit(VL6180X::INTERLEAVED_MODE__ENABLE,0);
  sensor.setTimeout(500);
  sensor.stopContinuous();
  delay(300);
  sensor.startInterleavedContinuous(100);

}
void loop()
{
//       hello1();
//       delay(1000);

       hello2();
       delay(1000);
//
//       hello3();
//       delay(1000);
//  int input = random(1,4);
//  Serial.println(input);
//  if (input == 1){
//     sensor.setAddress(0x52);
//     Serial.println(sensor.readReg(0x212),HEX);
//     hello1();
//     delay(300);
//     sensor.writeReg(0x212,0x52);
//  }
// 
//  else if (input == 2){
//    sensor.setAddress(0x52);
//    Serial.println(sensor.readReg(0x212),HEX);
//    hello2();
//    delay(300);
//    sensor.writeReg(0x212,0x52);
//  }
//
//
//  else if (input == 3) {
//     sensor.setAddress(0x52);
//     Serial.println(sensor.readReg(0x212),HEX);
//     hello3();
//     delay(300);
//     sensor.writeReg(0x212,0x52);
//  }

}
void hello1(){
    sensor.setAddress(0x29);
    Serial.println(sensor.readReg(0x212),HEX);
    sensor.setAddress(Address1);
//  Wire.beginTransmission(Address1);
//  int error = Wire.endTransmission();
//  Serial.println(error);

    sensor.writeReg(0x212,Address1);
    Serial.println(sensor.readReg(0x212),HEX);
    Serial.println();

    digitalWrite(pin2,HIGH);
    digitalWrite(pin3,LOW);
    digitalWrite(pin4,LOW);

    Serial.print(""Ambient 1: "");
    Serial.print(sensor.readAmbientContinuous());
    if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

    Serial.print(""\tRange 1: "");
    Serial.print(sensor.readRangeContinuousMillimeters());
    if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

    Serial.println();
    sensor.writeReg(0x212,0x52);
    digitalWrite(pin2,HIGH);
    digitalWrite(pin3,HIGH);
    digitalWrite(pin4,HIGH);
}

void hello2(){
    sensor.setAddress(0x52);
    Serial.println(sensor.readReg(0x212),HEX);
    sensor.setAddress(Address2);
//  Wire.beginTransmission(Address2);
//  int error = Wire.endTransmission();
//  Serial.println(error);

    sensor.writeReg(0x212,Address2);
    Serial.println(sensor.readReg(0x212),HEX);
    Serial.println();

    digitalWrite(pin2,LOW);
    digitalWrite(pin3,HIGH);
    digitalWrite(pin4,LOW);

    Serial.print(""Ambient 2: "");
    Serial.print(sensor.readAmbientContinuous());
    if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

    Serial.print(""\tRange 2: "");
    Serial.print(sensor.readRangeContinuousMillimeters());
    if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

    Serial.println();
    sensor.writeReg(0x212,0x52);
//    digitalWrite(pin2,HIGH);
//    digitalWrite(pin3,HIGH);
//    digitalWrite(pin4,HIGH);


}

void hello3(){
    sensor.setAddress(0x52);
    Serial.println(sensor.readReg(0x212),HEX);
    sensor.setAddress(Address3);
    sensor.writeReg(0x212,Address3);
    Serial.println(sensor.readReg(0x212),HEX);
    Serial.println();

    digitalWrite(pin2,LOW);
    digitalWrite(pin3,LOW);
    digitalWrite(pin4,HIGH);

    Serial.print(""Ambient 3: "");
    Serial.print(sensor.readAmbientContinuous());
    if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

    Serial.print(""\tRange 3: "");
    Serial.print(sensor.readRangeContinuousMillimeters());
    if (sensor.timeoutOccurred()) { Serial.print("" TIMEOUT""); }

    Serial.println();
    sensor.writeReg(0x212,0x52);
//    digitalWrite(pin2,HIGH);
//    digitalWrite(pin3,HIGH);
//    digitalWrite(pin4,HIGH);
}
</code></pre>

<p>Any help would be appreciated!   </p>
"
"<p>I would suggest checking out one of the gas sensors that comes with a breakout board. I've found the pins don't quite match the spacing of a protoboard and make it a little difficult to set up. Seeed Studio sells some of the sensors with a breakout board and has some nice examples of how to convert the values to PPM.</p>

<p><a href=""http://www.seeedstudio.com/wiki/Grove_-_Gas_Sensor(MQ5)"" rel=""nofollow"">http://www.seeedstudio.com/wiki/Grove_-_Gas_Sensor(MQ5)</a></p>
"
"<p>You are using only one VL6180 object and then changing its address repeatedly. In your setup(), since all the sensors are enabled and have the same address, you're sending init commands to all of them; I'm not sure what will happen (multiple ACK/NACKs?), but its probably not a good thing. Your hello() functions actually changes the address of all the sensors (twice?), if the commands even work, and then enables only one to read from. A host of undefined problems is expected.</p>

<p>To fix this, you have to do all the config and address changes in setup():</p>

<ul>
<li><p>Before setup(), create 3 VL6180 objects: <code>sensor1</code>, <code>sensor2</code>, <code>sensor3</code></p></li>
<li><p>In setup(), enable ONLY ONE sensor, and call all the sensor initialization commands on one of the objects you created (sensor1, maybe), as usual. Then call <code>setAddress()</code> on that sensor object to change its address to a unique one. This object is now tied to the physical sensor which has been enabled; all future operations related to that sensor, must be done on this object.</p></li>
<li><p>Then, disable this first sensor, and enable another and repeat the same steps as before on another object (sensor2), making sure to make each sensor's address unique. This way, you configure only one sensor at a time.</p></li>
<li><p>After configuring all three, you can now use their respective objects to get readings in loop().</p></li>
</ul>
"
"<p>I have an ATtiny85 and I wanted to use the EEPROM to store the values of the pins I am using in the code. Here is what I tried doing to store the value in the EEPROM:</p>

<pre><code>#include &lt;EEPROM.h&gt;

void setup() {
  EEPROM.write(0, 1);
  EEPROM.write(1, 0);
  EEPROM.write(2, A3);
  EEPROM.write(3, A2);
  EEPROM.write(4, A1);

}
</code></pre>

<p>Then in another sketch I try to read them and store them to a variable:</p>

<pre><code>#include &lt;EEPROM.h&gt;


byte var 1 = EEPROM.read(0); 
byte var 2 = EEPROM.read(1); 
byte var 3 = EEPROM.read(2); 
byte var 4 = EEPROM.read(3);
byte var 5 = EEPROM.read(4);  
</code></pre>

<p>I think that I followed the documentation correctly, but my program still doesn't execute properly. When I set the variables manually without using <code>EEPROM.read();</code> the program runs fine. Am I missing something?</p>
"
"<p>I am trying to make a RBB Arduino based project and I only need 3 pins. In the future I may use one to two more. I wanted to use an ATtiny85 however my code is 13,270 bytes and it would not fit. So I decided to use an ATtiny84 but it also would not fit, it will fit on an ATmega328p but I do not want to use one because i want to keep the project relatively small and I for sure do not need that many pins. Does anyone know of a chip that has a lot of memory but not many pins, or some other solution. Thank you, any help is appreciated.   </p>
"
"<p>There are a few ways to optimize your code and reduce the size. Have a look on this document from Atmel. I've used some tips to reduce the size of my bootloader once.</p>

<p><a href=""http://www.atmel.com/images/doc8453.pdf"" rel=""nofollow"">http://www.atmel.com/images/doc8453.pdf</a></p>

<p>For the AVR family I'm not familiar with any option. You could use a small QFN package for the atmega328p as well... You might find some small ARM with much more memory and small size.</p>
"
"<p>intead of modifying the TX power, why not make the receiver read the light level. You just need to transmit some data, like the weapon ID.</p>

<p>If works you could send more information, including how stable the weapon that hit the target was during the shoot using an accelerometer </p>

<p>Cheers </p>
"
"<p>I have connected to EL wire, 12v EL Inverter to SparkFun EL Sequencer but it does not work (no battery is connected). The connections are the same like in Hookup Guide (<a href=""https://cdn.sparkfun.com/assets/learn_tutorials/3/6/9/ELSequencerHookUp_bb.png"" rel=""nofollow"">https://cdn.sparkfun.com/assets/learn_tutorials/3/6/9/ELSequencerHookUp_bb.png</a>). Furthermore, there is no light indicating that it works but I hear a noise/whistle from the Inverter.</p>

<p>Do I have to program the EL Sequencer or does it automatically turn the EL wire on?</p>
"
"<p>I have a question about connecting a Arduino with Raspberry Pi. </p>

<p>What is the benefit of connecting the two?</p>
"
"<p><a href=""https://www.arduino.cc/en/Tutorial/RowColumnScanning"" rel=""nofollow"">https://www.arduino.cc/en/Tutorial/RowColumnScanning</a>
This code really confused me because I don't know if the ""pixels[x][y]"" is HIGH or LOW in void refreshScreen().  As you look at the code, ""pixels[x][y]"" is HIGH and then LOW in void setup(), and then ""pixels[x][y]"" is HIGH again in void loop(). Could anyone explain this to me, please？</p>
"
"<p>I am trying to flash the AT firmware in esp8266 but i am always getting the error of timed out waiting for packet header.
Note : I am using esptool.py to flash the the chip and i already have some code uploaded to it, which i uploaded using Arduino IDE
Here the Error which i am getting while writing flash.</p>

<p>root@mayank-HP-Notebook:/home/mayank/Desktop# esptool.py -b 115200 -p /dev/ttyACM0 write_flash 0x000000 ""ESP_8266_BIN0.92.bin""
esptool.py v1.2-dev
Connecting...
Running Cesanta flasher stub...</p>

<p>A fatal error occurred: Timed out waiting for packet header</p>
"
"<p>Interfacing hardware is easier with the Arduino: more available I/O pins
capable of sourcing and sinking more current, 5&nbsp;V I/O, analog
inputs, very predictable timings, etc. The Raspberry, on the other hand,
is a real computer with a real OS, has <strong>a lot</strong> more computing power
and memory, has Internet connectivity, can easily run “standard” web
servers like Apache or nginx... or mostly any Linux software for that
matter.</p>

<p>Some projects can benefit from using both. E.g. if you want to make a
web interface for some low-level hardware sensors.</p>
"
"<p>AFAIK, 8 KiB of flash is the most you can have on an AVR in a DIP
package with less than 28&nbsp;pins. If you do not mind soldering
surface-mount parts, the 328P is available in TQFP and VQFN packages,
significantly smaller than the DIP version.</p>

<p>Otherwise you could try to optimize your program to fit in 8&nbsp;KiB.
The Arduino libraries are often inefficient size-wise, and in many
instances you can save quite a lot by rewriting the parts that you need
on top of just <a href=""http://www.nongnu.org/avr-libc/"" rel=""nofollow"">avr-libc</a>. Note that
this libc is always linked to your program by the Arduino IDE.</p>
"
"<p>did you need to switch the ESP8266 into download mode (one of it's <a href=""https://github.com/esp8266/esp8266-wiki/wiki/Boot-Process"" rel=""nofollow"">boot modes</a>) </p>

<p>this mean to make sure that when you flashing GPIO2 is HIGH and GPIO0 is LOW.
then to boot to your new code GPIO0 need to be HIGH</p>
"
"<p><br>
I want to build an arduino car from scratch. I was wondering if you could guide me to choose the proper motors for my car. I want it to have some torque and also some speed( like a sweet combination between those two). I am thinking also to use it in ""unnatural"" conditions ( fields, caves etc).
Thank you in advance.</p>
"
"<p>I think the best solution would be to use WS2812 LEDS. I already implemented this many times also for my home illumination.
WS2812 is a RGB LED with an integrated chip (1m strip with 60 LED will cost about 10$).
One advantage is that you need only 1 output from your Arduino and the library works very well.
Another one is that you don't need power! 5mA is enough to drive 1000 LEDS! So you don't need MOSFETS and you don't need any Relais.</p>
"
"<p>Hello i want to make an interactive dj booth.
When someone touches the foil the sound appears.
How do i connect the leonardo to a keyboard.press('n')?
And connect the board to foil so when you touches the foil the
n key is pressed?</p>

<p>Thank you!</p>
"
"<p>This answer is easily accessible by googling.</p>

<p><a href=""http://google.com?q=arduino+leonardo+hid+keyboard"" rel=""nofollow"">http://google.com?q=arduino+leonardo+hid+keyboard</a><br>
...<br>
<a href=""https://www.arduino.cc/en/Reference/MouseKeyboard"" rel=""nofollow"">https://www.arduino.cc/en/Reference/MouseKeyboard</a><br>
<a href=""http://cal-eng.com/?page_id=579"" rel=""nofollow"">http://cal-eng.com/?page_id=579</a><br>
<a href=""https://www.sparkfun.com/tutorials/337"" rel=""nofollow"">https://www.sparkfun.com/tutorials/337</a><br>
etc.</p>
"
"<p>I am developing a simulation of an anrduino project on Proteus. And I wanted to use the terminal as if it was a GSM Modem. </p>

<p>I have this code somewhere.</p>

<pre><code>mySerial.print(""AT\r"");
</code></pre>

<p>And when this line executes, I get <code>AT</code> written on to the terminal. Then I type <code>OK</code> on the terminal and expect <code>mySerial.available()</code> to be <code>true</code>. But it is not. </p>

<p>What am I missing? What settings are there to configure to make this happen!</p>
"
"<p>I want to power my motor shield without my UNO. I have connected the <code>+ve</code> and <code>-ve</code> terminals resulting in lighting up of the LED. </p>

<p>Is there any way to control the motors in this arrangement from the Arduino?</p>
"
"<p>Welcome!</p>

<p>I'm not sure I understand what you are asking because what you are trying to do doesn't make much sense.  </p>

<p>The motors connected to the motor shield are controlled by the output pins of the Arduino that the motor shield is plugged in to.  </p>

<p>You could run jumper leads from an separate Arduino into your unplugged motor shield, but that's just extending what you already have.  You really do need some form of controller, not necessary a microprocessor, otherwise how can you go forwards and backwards?</p>

<p>Is the problem you have put the Arduino into a plastic case and you can't plug the motor shield in any more?  If so get a set of long male to female connectors (they look like the Arduino connectors) and use them as extensions.</p>

<p>Is the problem you have a different format of board and can't plug it in? If so use the wires method to form the correct connections.</p>

<p>I hope that answers your question, if not please try and explain what I'm misunderstanding.</p>
"
"<p>I’m constructing an arduino based sytem that uses a SD card and I’m looking for a way to safely remove the card from the system during operation. One way would probably be to turn of the arduino before removal of the SD card, but that is not acceptable in this context.  </p>

<p>The library I’m using: 
<a href=""https://www.arduino.cc/en/Reference/SD"" rel=""nofollow"">https://www.arduino.cc/en/Reference/SD</a></p>

<p>Is it possible to safely remove the SD card during operation? If no, how can I minimize the risk of damage to the SD card while inserting and removing it? </p>
"
"<p>The pixels array in initialized to all HIGH in setup().  Then one element of the pixel array is set to LOW in readSensors()  which turns on one LED.  The tricky bit is you have to remember to turn off the previous LED.  That is why in readSensors() there is the line where an element of pixels is set HIGH while the pixels' array pointers are still pointing at the former (already lit) LED.  </p>
"
"<p>The physical construction of the card and socket are designed such that power to the card is cycled properly when the card is inserted and removed. The only thing the firmware has to do is to stop writing to the card before it is removed.</p>

<p>Unexpected removal can cause a problem in ""larger"" systems (e.g. cellphones or PCs) because they may have structures open on the card that are not yet complete, but small embedded systems typically do not have the capability to do so and so once all writes are completed the card can be removed.</p>

<p>Detection of non-presence of a card is another issue though, and the firmware will have to be designed to not fail in such a situation.</p>
"
"<p><strong>Why add an Raspberry Pi to an Arduino?</strong></p>

<p>There are some things that simply are beyond the possibilities of Arduino. The first thing that would cross my mind is video processing, HDMI output, decent sound etc.</p>

<p>A Raspberry Pi can be used to add some features to your project aswell. If you make an Arduino controlled robotic arm, you could add an ""user interface"" to it, using a Raspberry Pi.</p>

<p><strong>Why add an Arduino to an Raspberry Pi?</strong></p>

<p>Some may argue that the Raspberry Pi is much more capable as an Arduino, in every form.
Though, the strengths of Arduino are:</p>

<ul>
<li>Ease of use. (For GPIO on Raspberry Pi you'll likely need to install something, to make it work with your favorite programming language.)</li>
<li>Real time / deterministic timing, this is one of the best things of Arduino. Given that an Arduino has no ""operating system"" that can induce random (tiny) delays in your program (other than the millis()/micros() interrupts).</li>
</ul>

<p><strong>Why do any of this? You could choose an Arduino OR Raspberry Pi</strong></p>

<p>One thing you might not think about is, that by joining an Arduino and a Raspberry Pi, you're joining two important parts of Embedded Systems. Which you can learn a lot from.</p>

<p>Microcontrollers and Single-board computers. This really has a good educational effect. Since you'll not limit yourself to one device or ""way of thinking"".</p>

<p>Moreover, the interfacing between two devices is often important and will bring some extra problems. (And solving them gives extra knowledge/experience)</p>
"
"<p>I'm attempting to reduce the amount of RAM being used by my program by writing some values to the EEPROM of my micro controller. I'm currently programming on the ATtiny85 which has 512 Bytes of EEPROM. According to the documentation this is how you write to EEPROM:</p>

<pre><code>#include &lt;EEPROM.h&gt;

void setup() {
  EEPROM.write(0, 1);
  EEPROM.write(1, 0);
  EEPROM.write(2, 3);
  EEPROM.write(3, 2);
  EEPROM.write(4, 1);

}
</code></pre>

<p>For some reason this isn't working for me and I can't seem to find the error. Am I programming this wrong or can the EEPROM of the ATtiny simply NOT be accessed with Arduino Code?</p>

<p>Here is the Datasheet: <a href=""http://www.atmel.com/Images/Atmel-2586-AVR-8-bit-Microcontroller-ATtiny25-ATtiny45-ATtiny85_Datasheet-Summary.pdf"" rel=""nofollow"">http://www.atmel.com/Images/Atmel-2586-AVR-8-bit-Microcontroller-ATtiny25-ATtiny45-ATtiny85_Datasheet-Summary.pdf</a></p>

<p>Here is the second sketch I'm using to test the EEPROM:</p>

<pre><code>    #include &lt;EEPROM.h&gt;

void setup() {
  EEPROM.write(0, 1);
  EEPROM.write(1, 0);
  EEPROM.write(2, A3);
  EEPROM.write(3, A2);
  EEPROM.write(4, A1);

byte CLK = EEPROM.read(0);

}

void loop() {

  if(CLK == 1)
  {
    for(int i = 0; i &lt; 3; i++)
    {
    digitalWrite(0, HIGH);
    delay(1000);
    digitalWrite(0, LOW);
    delay(1000);
    }
    exit(0); 
  }
  else
  {
    for(int i = 0; i &lt; 100; i++)
    {
    digitalWrite(0, HIGH);
    delay(1000);
    digitalWrite(0, LOW);
    delay(1000);
    }
    exit(0);
  }

  exit(0);

}
</code></pre>
"
"<p>An SDCard is very much like a hard disk drive.  Both in how it is made and how it is treated by the host.  As such there are critical times where interrupting the communication to the SDCard can cause corruption.</p>

<p>To avoid problems it is advisable to finish all transaction before removing the SDCard.  In a perfect situation all data will be flushed from the host's buffers (cache) and the files being accessed closed.  So research the flush() and the close() function calls in the library you are using.</p>

<p>In order to accomplish the above, it is obvious the host device needs to be told the SDCard is about to be removed.  In most cases this is accomplished using a switch (human interface) and some code to flush and close any open files.</p>

<p>All this said, often people pull SDCards with out any obvious problems.  This is likely because SDCard transactions are fast and completed in fractions of a second.  Also pulling an SDCard when periodically reading a file is far safer then when writing to a file or altering any information on the SDCard (for example the name of a file).  If you can suffer the possibility of corruption, it may be that the added effort is not worth it.  However if you stand lose a great deal, I would advise you to do some research into the best ways to avoid SDCard corruption.</p>
"
"<p>In my early days of computing, the computer used to turn on a led when writing to cassette tape or floppy disk. If you wanted to remove the tape or disk, you had to wait for the led to turn off. 
I think that could be your easiest solution.</p>
"
"<p>I have several sensors (Grove multichannel gas sensor, Air Pressure Sensor MPX4115A, Temperature and Humidity Sensor DHT11) where most of them uses I2C communication. 
I wonder if it is possible to read all of them using the I2C communication on a single Arduino board? </p>
"
"<p>When you upload a new sketch with the default settings, the EEPROM will be cleared.</p>

<p>""The -e option instructs avrdude to perform a chip-erase before programming; this is almost always necessary before programming the flash."" </p>

<p>If you're using the Arduino IDE, the -e option is enabled by default. This is probably why it's not working for you.</p>

<p>See also the question <a href=""http://electronics.stackexchange.com/questions/98891/is-there-a-way-to-preserve-eeprom-contents-in-avr-atmega-when-burning-a-new-firm"">Is there a way to preserve EEPROM contents in AVR Atmega when burning a new firmware to flash with avrdude?</a></p>
"
"<p>The Arduino EEPROM library is compatible with the ATTiny range of AVR microcontrollers as the library itself is built on the standard Atmel AVR avr/eeprom.h 'library' so it is compatible with all the AVR microcontrollers.</p>

<p>The EEPROM also doesn't take to being written or read to often as EEPROM can wear very quickly. Reading though does not cause much damage though. </p>

<p>Also note that using <code>exit(0);</code> <strong>will stop the ATTiny from doing anything else</strong> after it is called so I hope your intention is to only run the loop once, if not this would account for either not seeing anything or it only ever running the blinking cycle once.</p>

<p>To answer your follow up question. Yes you can run one sketch to set you values in EEPROM and then use another sketch to read those. That us usually the point of EEPROM it is a memory type that ""keeps its value while there is no power"".</p>

<p>Also you need to make sure the ATTiny is set to preserve EEPROM during upload with the ISP, this is done with the fuse settings. You need to look for a tutorial on fuse calculators for the AVRs. To set the <code>EESAVE</code> you need to set the High fuse to <code>0xD7</code>, you can change this in the <code>boards.txt</code> file. <a href=""http://eleccelerator.com/fusecalc/fusecalc.php?chip=attiny85&amp;LOW=E2&amp;HIGH=D7&amp;EXTENDED=FF&amp;LOCKBIT=FF"" rel=""nofollow"">Here is a fuse calculator.</a></p>

<p>If the code that is on your question at the moment is being used you won't be seeing anything as it needs the pins to be set with <code>pinMode</code>. That's a note for others that see this.</p>

<p>Next what you can do is run a basic test code which blinks the LED without anything else going on.</p>

<p>Basically:</p>



<pre class=""lang-cpp prettyprint-override""><code>void setup(){

 pinMode(0, OUTPUT);

}

void loop(){

 digitalWrite(0, HIGH);
 delay(1000);
 digitalWrite(0, LOW);
 delay(1000);

}
</code></pre>

<p>Below is the code you have written, it works I have it running in front of me.
I have commented it and changed a few things to make it work as intended, although the intention is not clear.</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;EEPROM.h&gt;

byte CLK = 0; //This is a global variable with an initial value

void setup() {
  // put your setup code here, to run once:

  EEPROM.write(0, 1); //set the pin to D1
  delay(5); 

  //read from EEPROM address 0
  //this sets the value of the global variable CLK
  CLK = EEPROM.read(0); //place this inside a function

  //just to give an example...
  byte PIN = CLK;   //PIN variable is a local variable 

  pinMode(PIN ,OUTPUT); //using that local variable

}

void loop() {
  // put your main code here, to run repeatedly:

  // Note: the below if() will always be true as the value 
  // of CLK is never change and shouldn't be changed as
  // it will change the pin number of the output

  if (CLK == 1) {
    for (int a = 0; a &lt; 3; a++) {
      digitalWrite(CLK, HIGH);  //this uses the global variable 
      delay(1000);
      digitalWrite(CLK, LOW);
      delay(1000);
    }
    //putting exit(0); will actually stop the program 
    //remove it
//    exit(0);
  }
  else { 
    for (int a = 0; a &lt; 100; a++) {
      digitalWrite(0, HIGH);  //this has a predefined pin no.
      delay(500);
      digitalWrite(0, LOW);   //this has a predefined pin no.
      delay(500);
    }
    //putting exit(0); will actually stop the program 
    //remove it
//    exit(0);
  }
}
</code></pre>
"
"<p>Should be easy enough.  Do you already know how to connect and communicate with one I2C device?  If so, connecting multiple should be simply a case of connecting them in parallel.</p>

<p>If you don't know how to communicate with a single I2C device, then...</p>

<p>For the Arduino software you can use <a href=""https://www.arduino.cc/en/Reference/Wire"" rel=""nofollow"">Wire</a> to talk to devices over I2C.</p>

<p>For the hardware, connect the I2C clock and data lines from the Arduino to the I2C devices.  More on that <a href=""https://learn.sparkfun.com/tutorials/i2c/why-use-i2c"" rel=""nofollow"">here</a>.</p>
"
"<p>It is possible to use multiple I²C devices, all is needed is for each one to have a different address and the ability to set up the wiring(the <a href=""http://arduino.stackexchange.com/a/25087/2944"">other answer</a> points to wriring info).</p>

<p>Of the sensors you listed only one is an I2C device(Grove sensor). </p>

<p>The DHT11 uses a single digital wire to communicate and the air pressure sensor is an analog device. Although you do mention having several devices, the only thing you need to be sure of is if there are no address conflicts, i.e. there being two devices with the same address on the I²C bus. </p>

<p>If address conflicts are an issue most devices provide a way of changing that address, often there are solder jumpers on the board. This allows you to change a devices address to a unique one.</p>
"
"<p>The speed value is correct, like TisteAndi said.  Your GPS location ""wanders"" around the same way.  You can simply ignore small speed values.</p>

<p>One problem you may not be aware of yet: the printing isn't really coordinated with the GPS updates.  Sometimes that doesn't matter, but if you want your speed to update every second, you'll need to synchronize the two.  And as noted in the code, you can actually lose GPS data if you print too much.</p>

<p>I wrote a GPS library, called <a href=""https://github.com/SlashDevin/NeoGPS"" rel=""nofollow"">NeoGPS</a>, to fix some of these problems.  They are described in the <a href=""https://github.com/SlashDevin/NeoGPS/blob/master/doc/Troubleshooting.md"" rel=""nofollow"">Troubleshooting</a> section of the online documentation.</p>

<p>Also, <code>SoftwareSerial</code> is very inefficient.  I maintain a more-efficient alternative, <a href=""https://github.com/SlashDevin/NeoSWSerial"" rel=""nofollow"">NeoSWSerial</a>.  As you add more features to your GPS program, the efficiency will become important.</p>

<p>Here is your program, modified to use NeoGPS and NeoSWSerial, and it uses TisteAndi's suggestion to set the speed to zero:</p>

<pre><code>#include &lt;Arduino.h&gt;
#include ""NMEAGPS.h""
#include &lt;NeoSWSerial.h&gt;

NeoSWSerial mySerial(4, 3); // RX, TX//

NMEAGPS     gps;
gps_fix     fix;
uint8_t     GPSupdates = 0;

void setup()  
{
  // Open serial communications and wait for port to open:
  Serial.begin(9600);

  // set the data rate for the SoftwareSerial port
  mySerial.begin(9600);

  delay(1000);

  Serial.print(""Sizeof(gps) = ""); Serial.println(sizeof(gps));
  Serial.println();
}

void loop() // run over and over
{
  while (gps.available( mySerial )) {
    fix = gps.read();

    if (fix.valid.speed &amp;&amp; (fix.speed_mkn() &lt; 1000)) {
      // Too slow, zero out the speed
      fix.spd.whole = 0;
      fix.spd.frac  = 0;
    }

    GPSupdates++;
  }

  // Print once every 5 seconds
  if (GPSupdates &gt;= 5) {
    Serial.println(""Acquired Data"");
    Serial.println(""-------------"");
    gpsdump();
    Serial.println(""-------------"");
    Serial.println();

    GPSupdates = 0;
  }

}

void gpsdump()
{
  Serial.print(""Lat/Long(10^-7 deg): "");
  if (fix.valid.location) {
    Serial.print(fix.lat); 
    Serial.print("", "");
    Serial.print(fix.lon);
  }
  Serial.println();

  // GPS characters may be lost during lengthy Serial.print()
  //   See the NeoGPS Troubleshooting section.

  Serial.print(""Lat/Long(float): "");
  if (fix.valid.location) {
    Serial.print(fix.latitude(), 5); 
    Serial.print("", ""); 
    Serial.print(fix.longitude(), 5);
  }
  Serial.println();

  Serial.print(""Date/Time: ""); 
  if (fix.valid.date | fix.valid.time)
    Serial &lt;&lt; fix.dateTime;
  Serial.println();

  //*
  Serial.print(""Date: ""); 
  if (fix.valid.date) {
    Serial.print(fix.dateTime.month); 
    Serial.print(""/""); 
    Serial.print(fix.dateTime.date);
    Serial.print(""/"");
    Serial.print(fix.dateTime.year);
  }

  if (fix.valid.date | fix.valid.time) {
    Serial.print(""  Time: ""); 
    Serial.print(fix.dateTime.hours); 
    Serial.print("":""); 
    Serial.print(fix.dateTime.minutes); 
    Serial.print("":""); 
    Serial.print(fix.dateTime.seconds);
    Serial.print(""."");
    Serial.print(fix.dateTime_cs);
  }
  Serial.println();
  //*/

  Serial.print(""Alt(cm): ""); 
  if (fix.valid.altitude)
    Serial.print(fix.altitude_cm());

  Serial.print("" Course(10^-2 deg): "");
  if (fix.valid.heading)
    Serial.print(fix.heading_cd()); 

  Serial.print("" Speed(10^-3 knots): "");
  if (fix.valid.speed)
    Serial.print(fix.speed_mkn());
  Serial.println();

  Serial.print(""Alt(float): "");
  if (fix.valid.altitude)
    Serial.print(fix.altitude()); 

  Serial.print("" Course(float): "");
  if (fix.valid.heading)
    Serial.print(fix.heading()); 
  Serial.println();

  Serial.print(""Speed(knots): "");
  if (fix.valid.speed)
    Serial.print(fix.speed()); 
  Serial.print("" (mph): "");
  if (fix.valid.speed)
    Serial.print(fix.speed_mph());
  Serial.print("" (mps): ""); 
  if (fix.valid.speed)
    Serial.print(fix.speed_kph()*3600.0/1000.0);
  Serial.print("" (kmph): "");
  if (fix.valid.speed)
    Serial.print(fix.speed_kph());
  Serial.println();

  Serial.print(""Stats: characters: ""); 
  Serial.print(gps.statistics.chars);
  Serial.print("" sentences: "");
  Serial.print(gps.statistics.ok);
  Serial.print("" failed checksum: ""); 
  Serial.println(gps.statistics.crc_errors);
}
</code></pre>

<p>(Notice the increased accuracy of the integer lat/lon!  And you don't need <code>printFloat</code>.)</p>

<p>If you'd like to try it, be sure to follow the NeoGPS <a href=""https://github.com/SlashDevin/NeoGPS/blob/master/doc/Installing.md"" rel=""nofollow"">Installation</a> instructions.  NeoSWSerial is installed like most Arduino libraries.</p>
"
"<p>icant setup lcd tft 3.5in( mcufriend) on arduino mega2560 ? you know arduino 1.6.7 has libraries such as UTFT &amp; UTOUCH ... I JUST SEE A WHITE SCREEN( that is on )   when upload example  on board...however im not sure about my pin out ....please help me    </p>
"
"<p>After a careful study of C/C++ documentation, I finally managed to use pointers in Arduino :)</p>

<p>So, the final code became like this:</p>

<pre><code>int arrayAAA[] = {6, 8, 10, 12};
int arrayBBB[] = {9, 15, 27, 41};

//Create a pointer, which will point to any of your arrays of your choice
int *newArray; 

const int arrayAAALength = sizeof(arrayAAA)/sizeof(int);
const int arrayBBBLength = sizeof(arrayBBB)/sizeof(int);

void setup() {

    Serial.begin(9600);

    //Uses the address of arrayAAA (i.e. inherits the content of arrayAAA). 
    //&amp;: points to address of a chosen array.
    //[0]: is a must to grab all values!
    newArray = &amp;arrayAAA[0]; 

    Serial.print(""arrayAAA:"");
    for (int i = 0; i &lt; arrayAAALength; i++){
        Serial.print(""   "");
        Serial.print(arrayAAA[i]);
    }
    Serial.println();

    Serial.print(""newArray:"");
    for (int i = 0; i &lt; arrayAAALength; i++){
        Serial.print(""   "");
        Serial.print(newArray[i]);
    }
    Serial.println();
}

void loop(){
    //Left empty
}
</code></pre>

<p>And it works perfectly, just what I expected!</p>
"
"<p>I'm using a MG2639 Cell Module with the SMS and GPS functionality.
I have a sketch that sends through SMS the location of the arduino UNO.</p>

<p>This is my code:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt; //to communicate with mg2639 cell module.
#include &lt;SFE_MG2639_CellShield.h&gt; //basic librarie of the module.
#include &lt;AltSoftSerial.h&gt;   //to communicate with the GPS module
#include &lt;TinyGPS++.h&gt;    //to acquire the NMEA codes.

TinyGPSPlus gps;

AltSoftSerial ALTS(9, 8);
char celprim[11]=""4423337388"";
uint8_t GPStatus=0;
long temp=0;

 void configurado()
{
  sms.start(celprim);
  sms.print(""Transmitiendo GPS Tracking...."");
  sms.send();
  delay (6000);
}

     void GPSTracking()
{
   do
      {
        if (ALTS.available()&gt;0)
          if (gps.encode(ALTS.read())) 
      {
        if (gps.date.isValid() &amp;&amp; gps.location.isValid() &amp;&amp; gps.time.isValid()){
          sms.start(celprim); 
          sms.print(""Fecha/Hora/Ubicacion: "");
          sms.print(gps.date.day());
          sms.print(""-"");
          sms.print (gps.date.month());
          sms.print(""-"");
          sms.print(gps.date.year());
          sms.print("" "");
          if ((gps.time.hour()-5) &lt; 10) sms.print(""0"");
          sms.print(gps.time.hour()-5);
          sms.print("":"");
          if (gps.time.minute() &lt; 10) sms.print(""0"");
          sms.print(gps.time.minute());
          sms.print("":"");
          if (gps.time.second() &lt; 10) sms.print(""0"");
          sms.print(gps.time.second());
    sms.print(""https://www.google.com.mx/maps/dir/19.4161748,-99.1664011/"");
          sms.print(gps.location.lat(), 6);
          sms.print("","");
          sms.print(gps.location.lng(), 6);
          sms.print(""/@"");
          sms.print(gps.location.lat(), 6);
          sms.print("","");
          sms.print(gps.location.lng(), 6);
          sms.print("",19z"");
          sms.send();
          GPStatus=1;
        }
    }
      if ((millis()-temp) &gt; 30000 &amp;&amp; GPStatus==0)
      {
        GPStatus=1;
        sms.start(celprim);
        sms.print(""Imposible ubicar equipo, intente mas tarde..."");
        sms.send();        
      }
    }while (GPStatus ==0);
}

void setup()
{
  delay (5000);
  int beginStatus = cell.begin();
  if (beginStatus &lt;= 0)
  {
     while(1)
      ;
  }
  delay (10000);
  sms.setMode(SMS_TEXT_MODE);   //Se pone al modulo en modo de recepción y envio de sms
  ALTS.begin(115200); // Or whatever rate the GPS uses
  configurado();
}

void loop()
{ 
  if (GPStatus==0)
  {
    temp = millis();
    GPSTracking();
  }
}
</code></pre>

<p>Is it possible to use only AltSoftSerial to create 2 serial ports and communicate with both cell and GPS in order to reduce program storage and global variables space? If it's possible, what changes should do in the MG2639 library to make it work?
Or what could i do to reduce space.</p>
"
"<p>I prefer to use arduino type boards as data acquisition units then transfer the data to an actual computer (or raspberry pi) in most of my projects. Arduinos are, in my experience, much more tolerant of fault and accidental crossed circuits than the R pi.  Thus is especially true of the ruggedized or industrial arduino versions. </p>
"
"<p>It looks like Sparkfun probably only put the bootloader on the board. The <a href=""https://learn.sparkfun.com/tutorials/el-sequencerescudo-dos-hookup-guide"" rel=""nofollow"">tutorial</a> is written in a way that suggests the need to flash the board.</p>

<p>Also the board does not imediatly work with the 12V inverter. If you have the battery you should attach it and see the <code>PWR</code> LED turn on.</p>

<p><em>The inverter only provides voltage to the EL wire</em> and <strong>not the Microcontroller</strong>, power to the microcontroller is provided by way of a regulator(<code>U2</code>), <strong><em>not</strong> the LM317</em> the last quote from the one comment shows how you can connect to the 12V inverter.</p>

<p>What you should do instead of having to go the route of all the wiring is to connect both the battery to <code>BATT IN</code> and the inverter, but ensuring that the microcontroller is programmed before hand.</p>

<blockquote>
  <p>Arduino Code</p>
  
  <p>Once you have all of your hardware hooked up properly, it’s time to
  program your Sequencer to run the EL Wire display as you want. You
  will need to download the Arduino code in order to follow along with
  the example.</p>
  
  <p>You can also download the most up-to-date code from the EL Sequencer
  <a href=""https://github.com/sparkfun/EL_Sequencer"" rel=""nofollow"">GitHub repository</a>.</p>
  
  <p>We will be working with the “SparkFun_EL_Example.ino” example. If you
  need a review on how to upload Arduino code to your board or using the
  Arduino IDE, please check our tutorial <a href=""https://learn.sparkfun.com/tutorials/installing-arduino-ide"" rel=""nofollow"">here</a>. Also, if you are unsure
  about installing the FTDI drivers, please check out <a href=""https://learn.sparkfun.com/tutorials/how-to-install-ftdi-drivers"" rel=""nofollow"">this tutorial</a>.</p>
</blockquote>

<p>Also from one of the <a href=""https://learn.sparkfun.com/tutorials/el-sequencerescudo-dos-hookup-guide/discuss"" rel=""nofollow"">Tech support notes</a>:</p>

<blockquote>
  <p>Using 12V to Power Both the EL Inverter &amp; Microcontroller</p>
  
  <p>If you are using a 12V wall adapter to power the 12V Inverter, you
  would still need to provide power to the microcontroller side. One
  solution with your 12V wall adapter to provide power to the 12V
  inverter and Atmega328P is to get a barrel jack adapter to 2 pin JST
  adapter [ <a href=""https://www.sparkfun.com/products/8734"" rel=""nofollow"">https://www.sparkfun.com/products/8734</a> ], thus connecting
  the 12V wall adapter to the “BATT IN.” This is assuming that your wall
  adapter is using a center positive barrel jack.</p>
  
  <p>From there you can connect the 2 pin JST labeled “DC Out” to the 12V
  inverter’s input voltage. To connect, I recommend using the male DC
  barrel jack adapter [ <a href=""https://www.sparkfun.com/products/10287"" rel=""nofollow"">https://www.sparkfun.com/products/10287</a> ] and a
  2pin JSt jumper wire [ <a href=""https://www.sparkfun.com/products/8670"" rel=""nofollow"">https://www.sparkfun.com/products/8670</a> or
  <a href=""https://www.sparkfun.com/products/8671"" rel=""nofollow"">https://www.sparkfun.com/products/8671</a> ]. You will need to wire strip
  the cable to be able to connect it to the screw terminals.</p>
  
  <p>Lastly, you would need to add a solder jumper to SJ1 so that you
  bypass the voltage regulator between your external power (“BATT IN”)
  to provide power to the inverter’s “DC OUT”. This will provide power
  to your 12V inverter’s input.</p>
</blockquote>

<p><strong>Warning: if SJ1 is closed, inverter will see 5V with FTDI plugged in and switch at USB</strong></p>
"
"<p>From what I can tell it's absolutely possible but will take some considerable development time and around $30-$70 of hardware per NFC terminal. Please note I would strongly not recommend this as a first project as it has a lot of individual components that all have to work together flawlessly and each is different. Properly done this will be complex software and hardware wise although more so from the hardware side of things.</p>

<p>Hardware wise you need/terminal:</p>

<ul>
<li><strong>LCD display</strong> (I would recommend segmented for simplicity and cost)</li>
<li><strong>Wifi or ethernet shield/breakout</strong> and ethernet cable if the board is not wifi compatible</li>
<li><strong>Arduino</strong> (MKR1000 has wifi built in), Feather (Adafruit's boards that are frequently Arduino software compatible and have many shields available and guides written on how to use them), or cheap Arduino knock off (preferably not this option as giving money to arduino.cc, Adafruit, or other designers is important if we want new boards regularly)</li>
<li><strong>NFC breakout</strong> or shield (Google/DuckDuckGo/Bing RFID-RC52 for an economical option, they're ~$4 on Ebay)</li>
<li><strong>Power supply</strong> corresponding to the requirements of the chosen board + shields + breakouts</li>
<li><strong>NFC tags</strong></li>
<li><strong>Lock</strong> able to be unlocked by a servo. If you expect security in absence of supervising shop manager (aka just to be safe, assume dishonesty in people using the shop) from this system, the locks need to be better than a Masterlock as those are insecure to even simple soda can shims. The rotary masterlocks can also be reduced to 100 possible combinations and then the combo can be brute forced easily from there so if you get a rotary based lock system make sure the assembly covering the dial is not easily removed.</li>
<li><strong>Servo or stepper</strong> powerful enough to actuate locks</li>
<li><strong>Servo or stepper driver breakout board</strong></li>
</ul>

<p>Then you'd just want to have the public key (note I don't mean a ""public key"" in the general cryptography sense but on that subject, you do want the key encrypted) to the user stored on the NFC tag and then use the arduinos+electronics to read the tags and see point values. User data from wordpress could be downloaded periodically to the boards so the individual checks don't use network resources and the system works offline.</p>
"
"<p><strong>Background</strong></p>

<p>The Nintendo 2DS is a game system from nintendo that has a series of buttons on the front. Included are the Up, Down, Left, Right, A, B, X, Y, L, R, Start, Select and Home buttons. The device operates at 1.8V and all buttons are Digital.</p>

<p><strong>Questions</strong></p>

<ol>
<li>What is the best level shifter to use for this purpose. I was considering <a href=""https://www.sparkfun.com/products/12009"" rel=""nofollow"">buying a couple of these</a> but is there a cheaper/more efficent/better alternative?</li>
<li>Is there a schematic available for the 2DS that shows which, if any, motherboard test pads are connected to buttons?</li>
</ol>

<p>Thanks in advance, Zach</p>
"
"<p>I bought a ESP 8266 &amp; I am able to send AT commands and receive response via serial monitor when I upload a empty sketch. I changed the baud rate from 115200 to 9600 by using <code>AT+CIOBAUD=9600</code> and am able to run AT commands at 9600 baud rate.</p>

<p><strong>Empty Sketch:</strong></p>

<pre><code>void setup() 
{

}
void loop() 
{

}
</code></pre>

<p>Here is how my circuit looks:
<a href=""http://i.stack.imgur.com/Ec228.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/Ec228.png"" alt=""Diagram""></a></p>

<p><strong>Problem</strong></p>

<p>The problem is when I create a custom sketch to run AT commands it doesn't work. Here is how my sketch looks:</p>

<pre><code>#include &lt;SoftwareSerial.h&gt;
SoftwareSerial esp8266(0,1); //RX,TX

void setup()
{

  Serial.begin(9600);
  esp8266.begin(9600); 

  Serial.println(""Run AT Command"");

   esp8266.print(""AT\r\n"");



}

void loop(){
   String response = """";
   while(esp8266.available())     {
        char c = esp8266.read(); 
        response+=c;
        Serial.print(c);
      }  

      if(response != """"){
        Serial.println(response);
      }

}
</code></pre>

<p>ESP8266 is receiving 3.3V but I have read TX and RX sends 5V, and they also need to be 3.3V. Don't know if thats what is causing it, but I am able to run AT commands on empty sketch, so this is a bit weird.</p>
"
"<blockquote>
  <p>Is it possible to use only AltSoftSerial to create 2 serial ports and communicate with both cell and GPS in order to reduce program storage and global variables space?</p>
</blockquote>

<p>The question is a little vague.</p>

<p><code>AltSoftSerial</code> only works on pins 8 &amp; 9, so I thought you were asking if you could connect both the cell and the GPS to pins 8 &amp; 9 (using jumper pads on the back of the board), and use one <code>AltSoftSerial</code> instance to talk to both devices.  If it were possible, this would save RAM (just one instance) and program space (you wouldn't need two link in another software serial class, like <code>SoftwareSerial</code>).  However, this is not possible.  Serial connections are always point-to-point.  Although two ""things"" can listen to one RX line, the TX line cannot be shared by two devices.</p>

<p>If you were asking if you can have two instances of <code>AltSoftSerial</code> on two separate pairs of pins (e.g., 2/3 and 8/9), the answer is again ""No"", because... <code>AltSoftSerial</code> only works on pins 8 &amp; 9.  Also, the SparkFun library only uses SoftwareSerial to talk to the cell.</p>

<blockquote>
  <p>what could i do to reduce space.</p>
</blockquote>

<p>Use <a href=""https://github.com/SlashDevin/NeoGPS"" rel=""nofollow"">NeoGPS</a> instead, and use the F macro around double-quoted strings that you print:</p>

<pre><code>    sms.print( F(""Imposible ubicar equipo, intente mas tarde..."") );
</code></pre>

<p>That will save several hundred bytes of RAM.</p>

<p>Also, you may be sending multiple SMS's per second.  It depends on what sentences the GPS emits.  As it is, your sketch will send one SMS per sentence (i.e., one for each <code>encode</code>).  Even if you don't use NeoGPS, look at the example program <code>NMEAloc.ino</code> et al for the correct program structure.  The Troubleshooting section also contains some tips.</p>
"
"<p>Really simple question. I'm using an ATtiny85 and an Arduino Mega and need to find out how quickly they can execute a commands. I couldn't find anything in the datasheet so I was wondering if there was some kind of formula that you use to find clock speed.</p>

<p>Here are the datasheets:</p>

<p>ATtiny85: <a href=""http://www.atmel.com/Images/Atmel-2586-AVR-8-bit-Microcontroller-ATtiny25-ATtiny45-ATtiny85_Datasheet.pdf"" rel=""nofollow"">http://www.atmel.com/Images/Atmel-2586-AVR-8-bit-Microcontroller-ATtiny25-ATtiny45-ATtiny85_Datasheet.pdf</a></p>

<p>Arduino Mega: <a href=""http://www.robotshop.com/media/files/PDF/ArduinoMega2560Datasheet.pdf"" rel=""nofollow"">http://www.robotshop.com/media/files/PDF/ArduinoMega2560Datasheet.pdf</a></p>
"
"<p>Speed Grade
– ATtiny25V/45V/85V: 0 – 4 MHz @ 1.8 - 5.5V, 0 - 10 MHz @ 2.7 - 5.5V
– ATtiny25/45/85: 0 – 10 MHz @ 2.7 - 5.5V, <strong>0 - 20 MHz @ 4.5 - 5.5V</strong></p>
"
"<p>So, some of the other answer(s) are being a little too cute.</p>

<p>You have really asked two questions 1) what is the clock speed and 2) ""how quickly they can execute a commands"".</p>

<p>So, the faster the clock of the processor runs (1) then the faster that your given command sequence(2) runs.</p>

<p>But the reality is that this is not a simple question (unlike your statement) because it very much depends upon what your code is like and what instruction you need to use in your code. Some opcodes- take very few clocks and some take a lot and the mix is  not always predictable ahead of time.</p>
"
"<p>The datasheet for the microcontroller or microprocessor will show the maximum clock frequency, but the system designer sets the actual clock speed, which may be much less than the maximum.</p>

<p>Some microcontrollers have internal clock generators - the datasheet should state the default frequency, and perhaps how to change the internal clock frequency.  Most also allow the user to provide an external clock signal, usually generated by a crystal oscillator.</p>

<p>The datasheet often includes a table showing the number of clock cycles required by each instruction.</p>
"
"<p>There are two references to the clock speed for the Mega 2560 in the RobotShop datasheet that you had linked.</p>

<p>Page 2</p>

<p><a href=""http://i.stack.imgur.com/xvslU.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/xvslU.png"" alt=""enter image description here""></a></p>

<p>Page 3</p>

<p><a href=""http://i.stack.imgur.com/4TW3K.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/4TW3K.png"" alt=""enter image description here""></a></p>
"
"<p>The best place to look for Arduino specifications is Arduino.cc.</p>

<p>The <a href=""https://www.arduino.cc/en/Main/ArduinoBoardMega2560"" rel=""nofollow"">Arduino/Genuino mega product page</a> clearly states, right at the top, 16MHz.</p>

<p>The <a href=""http://www.atmel.com/Images/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_Summary.pdf"" rel=""nofollow"">Atmel datasheet for the ATmega2560</a> contains Chapter 8, ""Instruction Set Summary"". </p>

<p>The instruction set is deterministic; excluding interrupts, a mix of instructions <strong>is</strong> predictable ahead of time, if you know the data being manipulated. </p>

<p>Only the ""Branch"" instructions are data sensitive, they take different numbers of cycles depending on whether the branch is taken (when the condition is true) or not taken.</p>

<p>All the ""Arithmetic and Logic"", ""Bit and Bit-Test"", ""Data Transfer"" and ""MCU instructions"" execute in exactly the same number of cycles irrespective of the data, and the vast majority of instructions execute in 1 or 2 cycles. </p>

<p>The Atmel document <a href=""http://www.atmel.com/images/atmel-0856-avr-instruction-set-manual.pdf"" rel=""nofollow"">""AVR 8-bit Instruction Set. Instruction Set Manual""</a> describes the instructions in detail, including the ATtiny, whic takes a different number of cycles for a few instruction compared to the ATmega.</p>

<p>So, given the Arduino Mega (ATmega2560) clock is 16MHz, you can calculate the time for all non-branch instructions, and the time for all branch instructions if you know the data.</p>

<p>The ATtiny85 comes on several different boards, with slightly different system clocks. Worse, the same board may run at different speeds depending on context. For example, I believe the <a href=""http://digistump.com/wiki/digispark"" rel=""nofollow"">digispark</a> tries to adjust its clock to help synch with USB when it is connected to a host computer.</p>

<p>In the absence of information, I'd guess it is running at 16MHz, for some compatibility with the popular Arduino,  until you get better information. </p>

<p>ATtiny instruction cycle time is also described in the Atmel document <a href=""http://www.atmel.com/images/atmel-0856-avr-instruction-set-manual.pdf"" rel=""nofollow"">""AVR 8-bit Instruction Set. Instruction Set Manual""</a>, with a summary in Chapter 4 ""Complete Instruction Set Summary"", pages 11 to 4.</p>

<p>ATtiny runs some instructions in a different number of cycles than an ATmega, for example RCALL,    Relative Call Subroutine. They have note (5) in Chapter 4, ""Complete Instruction Set Summary"", pages 11 to 4.</p>

<p>I have not checked in some years, however, Atmel sold a simulator which claimed to be 'cycle accurate', and hence could calculate how many cycles it would take to run a piece code. However, you could write some simple programs to help yourself.</p>

<p>It is relatively easy to get assembler from a binary program using avr-objdump. </p>

<p>Then with a few hours work, you could write a script or program to annotate the assembly code with cycle time for each instruction. Then write a program or script to estimate cycle times between branch instructions. You'd need to analyse the programs behaviour to understand what is happening, and hence extrapolate overall run times.</p>

<p>It depends on the complexity of the code, and how precise and accurate you need the timing to be.</p>
"
"<p>For the ATtiny85...<BR>
<BR>
The maximum clock rates are shown near the bottom on the first page of the datasheet.<BR>
<BR>
You must select the clock source and division factor according to chapter 6 of the datasheet to set the actual clock rate.  By default the device will start up from the internal 8MHz RC oscillator with an 8X division factor.  So your default clock rate is 1MHz unless you change it by configuring the CKSEL, CKSEL0, and SUT register fields.<BR>
<BR>
In chapter 24 you will find an ""Instruction Set Summary"" table that shows every assembly instruction that the processor can execute.  In the right hand column it shows how many clock cycles each instruction takes to execute.<BR>
<BR>
For example if I executed the RET instruction it would take 4 clock cycles, and if the clock was set to 1MHz that would be 4 microseconds.<BR>
<BR>
If you are writing the code in C or some language other than assembly then you won't know how many clock cycles it will take until you compile it and either look at a disassembly listing or run the code on hardware or in the simulator.  Atmel Studio is free and comes with a decent simulator.<BR>
<BR>
The answer is similar for the ATMega parts.
<BR></p>
"
"<p>I am planning an uno based tachometer for my truck, which doesn't have a tachometer. With nothing in place for me to get a reliable signal, I started looking at other sources to read the rpm from the engine. </p>

<p>It seems to me that an engine should affect the power every time a cylinder fires --the power should spike in some way. So in theory I should be able to hook up to the 12v cigar lighter, count the spikes, and calculate the rpm. It would only need to be accurate within 500 rpm or so. </p>

<p>This is a two part question. </p>

<ol>
<li><p>How would I hook up the arduino to the 12v system? As in, what should I do to protect the io of the arduino?</p></li>
<li><p>How would I gather the test data to see if this is possible? Is there a way to hook the arduino up to the truck via the 12v and my computer via usb and send data back that I can record or monitor?</p></li>
</ol>
"
"<p>I was making a home automation system by making some of the appliances in the home like fans and lights voice activated. But by mistake I bought a remote controlled relay in place of a normal relay from a shop and return does not seems possible. So I want to know if I will be able to use that remote controlled relay in this project?</p>
"
"<p>For some time now I've been playing around with the latest version of Arduino IDE and my UNO and ATTiny with simple 433 RF links with the Manchester Library. It all worked fine, but for my next project I want to take the step up and use a better wireless thingy... like the nrf24l01 or the nfm12b.</p>

<p>And then starts the pain. Attiny does not have hardware serial, but people seems to have solved this by implementing software-serial. But then they have to use some other boards for ATTiny, because when I try to run the examples I get error messages that it could not find  and so on. I use the ATTiny boards I found over at <a href=""https://code.google.com/archive/p/arduino-tiny/"" rel=""nofollow"">google code</a>.</p>

<p>Regarding the RFM12B I got something to compile. If I went back and downloaded Arduino IDE 1.5.0 (no other!) it actually work with the JeeLib - hurray! Why is this, why can't I use the latest version of the Arduino IDE?</p>

<p>Regarding the NRF24 chip this case is unresolved. I have not found the correct combination of boards, IDE and library versions. Could anyone point me in the right direction?</p>

<p>What are the difference between the Arduino IDE's? Why can I get stuff to work on 1.5.0 but not the latest 1.6.x?</p>
"
"<blockquote>
  <p>How would I hook up the arduino to the 12v system? As in, what should I do to protect the io of the arduino?</p>
</blockquote>

<p>First you're going to need to do some investigative work. You're going to need to beg, steel, borrow (or use your own if you have one) an oscilloscope. You can then use that to examine the 12V power coming from the cigarette lighter.  Armed with that you can then tell:</p>

<ol>
<li>If there is any power fluctuation from the engine, and</li>
<li>What form that fluctuation takes.</li>
</ol>

<p>If there is any fluctuation it will appear as an AC component imposed on top of the 12V DC voltage. Removing the 12V DC offset is simple enough. All you need to do is pass the power through a <em>high pass</em> filter. That's simply a capacitor and a resistor. You need to ensure that the cut-off frequency of the filter is below the lowest frequency you want to measure (idle frequency) yet high enough to cut out the DC component effectively.</p>

<p>Once you have done that you can then clip the waveform using a diode to protect against negative voltage, and a resistor and zenner diode to limit the positive voltage.</p>

<p>For instance, something similar to the following (it's not exact - the source isn't creating spikes, but an offset low duty cycle PWM, which is kind of similar for demonstration purposes):</p>

<p><a href=""http://i.stack.imgur.com/lCfpI.png"" rel=""nofollow""><img src=""http://i.stack.imgur.com/lCfpI.png"" alt=""enter image description here""></a></p>

<p>The first point measured is the 12V signal with big high voltage spikes. Next the power has been high-pass filtered by the RC network and the lower portion of the waveform clipped by the reverse biased diode. Following that the zenner diode clips the upper portion of the waveform to within safe limits for the Arduino. The 100Ω resistor with the zenner is there to limit the current through the zenner.</p>

<p>Don't take any of those values as gospel, since the signal I am filtering there is not your signal. You need to know your signal first before you can work out exactly how it should be filtered, but that gives you the basic idea of how it can be done.</p>

<blockquote>
  <p>How would I gather the test data to see if this is possible? Is there a way to hook the arduino up to the truck via the 12v and my computer via usb and send data back that I can record or monitor?</p>
</blockquote>

<p>Connect the filtered and clipped signal to an interrupt input on the Arduino. Count the pulses within a given time period (1 second, 5 seconds, whatever you choose) and multiply up for number of pulses in a minute. Don't forget to then divide by 4 for a 4-cylinder engine, since I would expect you would see 4 sparks per revolution. How you then gather the data is up to you. It might be simplest to add an SD card shield to your Arduino and record the data onto an SD card. You can then place that card into your computer to process the data at your leisure. </p>

<p>The best way to power your Arduino is, of course, direct from the truck's power. The safest way, because of all those nasty spikes in the power, is to use car USB phone charger adapter. Plug that into the USB of the Arduino and all should be nice and happy.</p>
"
"<p>I intend to perform data logging from sensors and store it on SD card as CSV format. The data is related to weather and I would like to send it at the end of the day/
Any available codes how to deploy the SD files from Arduino to the cloud/online at specific time of the day?
Thank you in advance.</p>
"
"<p>I was experimenting little bit with <a href=""https://github.com/stanleyhuangyc/ArduinoOBD/blob/master/libraries/OBD/OBD.cpp"" rel=""nofollow"">this library</a>, but I can't find any example how to read DTC codes with this?</p>

<p>Should I just use this plain <code>sendCommand</code> and send <code>03\r</code> as command, and than convert that HEX response manually or I can reuse more of this functionality?</p>

<p>Or if there's other way, please share it with me.</p>
"
"<p>I have asked here, Arduino.cc forum, and Adafruit forum this question related to finding client ip using the Adafruit CC3000 Shield.  Answer from TisteAndii here:  <a href=""http://arduino.stackexchange.com/questions/24288/find-remote-ip-address-tcp"">Client IP</a> seems to be on-track, only problem is it does not return client IP every time. Is there a better, more consistent way of getting the client IP?</p>

<p><a href=""https://e2e.ti.com/support/wireless_connectivity/simplelink_wifi_cc3000/f/851/t/380635"" rel=""nofollow"">TI E2E community response to client IP function</a> Appears it should be possible; I do not understand the response.</p>

<p>Work done so far:  <a href=""https://drive.google.com/open?id=0Byo8QWKyqAT9LTNWVGtBZHVDZEU"" rel=""nofollow"">Answer so far</a>.</p>

<p>I looked for a way to delete my last question regarding client ip; that I asked poorly, I was unable to delete the question.</p>

<p>William</p>
"
"<p>I think your confusion stems from the fact that the MCU chip does not have built-in frequency. So It depends on whether you are talking about the MCUs themselves or a particular circuit board containing one of them. Each kind of chip will have a maximum clock speed it can run at (which in turn depends on the operating voltage), but the clock frequency is <em>usually</em>* determined by an external crystal. The actual frequency depends on the frequency of the crystal the board was built with. Arduino Mega2560 boards have a 16MHz crystal. Other boards using the same chip could be built differently.</p>

<p>* ""usually"", because the chips often have an internal clock, typically 8MHz, which can be selected when it is being electrically programmed. For most Arduino boards, this is seldom used, but it is an option to be aware of.</p>
"
"<p>I don't like to work with mains, so I use those outlets and connect a <a href=""http://www.ebay.com/itm/NEW-433Mhz-RF-transmitter-link-kit-for-Arduino-ARM-MC-U-Remote-control-Sale-/321975775117?hash=item4af7406f8d:g:ed8AAOSwFqJWlzgA"" rel=""nofollow"">433MHz transmitter</a> to the arduino to activate the outlets.</p>

<p>You'd have to check the frequency of the unit, and see if anyone have decoded the transmitted data package.</p>

<p>If that doesn't float you're boat, you could open up the unit, and remove/desolder the relay. Add a transistor, and flyback diode and you're done. Just be careful with mains power.</p>
"
"<p>I have this <a href=""http://www.obddiag.net/allpro.html"" rel=""nofollow"">AllPro OBD</a> adapter and OBD2 <a href=""https://www.scantool.net/ecusim-2000/"" rel=""nofollow"">simulator</a> hooked up. And so far everything works great, except for the getting VIN.</p>

<p>When I run <code>0902\r</code> command to get VIN number, I just get one raw as response. And from what I read there should be more than one row of HEX response, each one should contain row identifier etc. so from my single-line response I'm getting just first 3 letters of the VIN (and these letters matches with the hardcoded vin in simulator). </p>

<p>My question is, is there any command which I can use to read remaining data (to ask for additional rows (multi-rows response)?</p>

<p>And what could be the reason why I'm getting just one row for this command?</p>

<p>I check few other commands just to make sure that I'm not always getting single-line response, and I'm not, for some other commands I'm getting multi-line response, so I'm little bit confused what's wrong with this.</p>

<p><strong>UPDATE</strong></p>

<p>It looks like that <strong>AllPro OBD board is not working properly for that PID</strong>. Trough that board I'm getting just single line response, from other boards I'm getting full multiline response.</p>
"
"<p>still pretty new to AVR programming, I don't really understand what's going wrong here, and I don't know really how to solve it...</p>

<p><strong>The Concept:</strong></p>

<p>Play a sine wav saved as a char array in PROGMEM through a 8bit DAC connected to PORTC pins on the arduino mega.</p>

<p><strong>This Works:</strong></p>

<pre><code>//file just defines an array and a size 
#include ""sine440.h""
int i = 0;
void setup() {
  DDRC = B11111111;  
}

void loop() {
  PORTC = pgm_read_byte(&amp;sine[i++]);
  if(i &gt;= sine_size){
    i = i - sine_size;
  }

  delayMicroseconds(60);
}
</code></pre>

<p>The above code produces a sine wav of about 440hz, exactly what I wanted. Now, I'd like to move this into an interrupt routine, as follows:</p>

<p><strong>This Doesn't Work</strong></p>

<pre><code>#include ""sine440.h""
int i = 0;
void setup() {
  DDRC = B11111111;
  TCCR5B = (1 &lt;&lt; WGM52) | (1 &lt;&lt; CS50 );
  OCR5A =  16000000/16000;
  TIMSK5 = (1 &lt;&lt; OCIE5A);
}

ISR(TIMER5_COMPA_vect){
  PORTC = pgm_read_byte(&amp;sine[i++]);
  if(i &gt;= sine_size){
    i = i - sine_size;
  }
}

void loop() {

}
</code></pre>

<p>The above code produces a sine wave of 1721hz. I know that this means it's iterating through the array too fast, but I don't know how to change it. In order for it to produce 440hz, it needs to be preforming 16000 iterations per second, which is what I believe <code>OCR5A =  16000000/16000;</code> does. <strong>BUT</strong> it doesn't appear that changing the value of OCR5A does anything at all. Giving it the max value of 65,535 still produces 1721hz sine wav...</p>

<p>So what am I doing wrong here? How do I change the speed of this timer interrupt?  </p>
"
"<p>I am making an IoT device with the MKR1000.</p>

<p>As a part of the process, I would like to set up an HTTPS connection to <a href=""https://hit.tl8.co/api/ping"" rel=""nofollow"">https://hit.tl8.co/api/ping</a> (This is a website I have made and control).</p>

<p>The problem is that <code>client.connect(url, 443)</code> is returning false. I have tried normal HTTP and the URL works on a browser. I can also access <a href=""https://www.google.com"" rel=""nofollow"">https://www.google.com</a>. The code is a small variation of the example HTTP client.</p>

<p>As such, I believe that the TLS cert I am using is not accessible by the MKR1000. Running this <a href=""https://www.ssllabs.com/ssltest/analyze.html?d=hit.tl8.co&amp;s=2400%3a6180%3a0%3ad0%3a0%3a0%3a3e3%3a1&amp;latest"" rel=""nofollow"">report</a> shows that it is a RSA 2048 bits (e 65537) with SHA256withRSA cert. </p>

<p>Is there a way to get the MKR1000 to accept this cert? Failing that, what changes do I need to make to this cert for it to work?</p>

<p>Is there a software solution to get this cert working?</p>
"
"<p>Before I tear all my hair and teeth out, can anyone please help. I have tried googling an answer and have not found anything. </p>

<p>My Setup:</p>

<ol>
<li>Win7 64bit</li>
<li>Arduino 1.6.9 IDE freshly reinstalled</li>
<li>COM14 port in Arduino IDE checked</li>
<li>Under Device Manager COM14 shows as: ""USB Serial Port (COM14)"". Not as ""Arduino...(COM14)"" as some pages have shown</li>
<li>I am not sure if I have a real or copy of the Arduino. As far as I can figure out I have a real one, on the back I have the FT232RL chip</li>
<li>I have bought 2 Arduino Nanos and both show same error</li>
<li>Both Nanos came pre-soldered, (no noob soldering by me)</li>
<li>I have tried uploading sketches on my Win7 platform AND over a Raspberry Pi, both same error</li>
</ol>

<p>Now perhaps most importantly I previously ordered an Arduino from the same retailer and that one worked. The two I have now dont work.</p>

<p>The problem:</p>

<ol>
<li><p>When I try upload I get the same message every time: <strong>avrdude: stk500_recv(): programmer is not responding</strong></p>

<p>a. it does this 10 times and then fails</p>

<p>b. Rx and Tx LED's are ON and do NOT blink at all at any point in time</p>

<p>c. Green power LED is always ON, no blinking</p>

<p>d. Pin13 LED blinks consistently</p>

<p>e. I have tried the extreemly annoying reset ""trick"" before uploading, after uploading, at the same time, during uploading, and nothing works</p></li>
</ol>

<p>I am seriously at a loss here. I have had an Arduino Nano work on my pc.</p>

<p>Any help would be greatly appreciated please. </p>
"
"<p>I have wired up a 74HC595N with an Uno, and the standard 8 LEDs and resistors, per the usual youtube ""shift register tutorial"" and written a sketch that works.  For example, I wrote a routine to walk from values 0 through 255 and light up the LEDs as a hex number.  So my wiring and code are correct.</p>

<p>As an experiment, I tried disconnecting the pin on my breadboard's power rail that goes to the Arduino 5V, and the pin that goes to Arduino ground, and instead plugged in a breakout (if that's the right word) that plugs into the breadboard and provides 5V on the power rail when a 9V battery is plugged into it.  (It's been checked with a multimeter, it's just under 5V.)  The only pins still going to the Arduino are for DS, SHCP and STCP.</p>

<p>Things sort of work, but not really.  It seems clear to me that the shift register keeps getting reset. (All of the LEDs briefly light back up in each iteration as I'm running my hex number display routine.) All of the other wiring remains the same; specifically OE-bar is still connected to ground on the power rail.  But it still seems to reset.</p>

<p>Can someone explain why the shift register keeps resetting?  Also, am I doing anything that might burn up the Arduino and/or shift register?</p>
"
"<p>All ground connections except those which are explicitly isolated must be connected together in order to provide a common voltage reference for the circuit. Any breaks in the ground connection can result in gross misbehavior such as what you are experiencing.</p>
"
"<p>I am making an Arduino alarm. This is the error:</p>

<pre><code>exit status 1
invalid operands of types 'const char*' and 'const char [2]' to binary 'operator+'
</code></pre>

<p>Here is the code that triggers it: </p>

<pre><code>lcd.print(""0""+hours+"":""+minutes);
</code></pre>

<p>This code is similar, but worked before:</p>

<pre><code>String none=""00"";
lcd.print(none+"":""+none+"":""+minutes);
</code></pre>

<p>I can post the full code if you need it. How can this be fixed?</p>
"
"<p>Your first code took a <code>String</code> object, then added other strings (note lowercase) to it - which are characters enclosed in quotes. It is legal to add strings to <code>String</code> objects.</p>

<p>Your new code doesn't have any <code>String</code> objects at all - and you're not allowed to add strings to strings (both lowercase).</p>

<p>It will work if you change your new code to:</p>

<p><code>lcd.print(String(""0"")+hours+"":""+minutes);</code></p>

<p>That turns the original string <code>""0""</code> into a <code>String</code> object, and then adds more strings to it.</p>
"
